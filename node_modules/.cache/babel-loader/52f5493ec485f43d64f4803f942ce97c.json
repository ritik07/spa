{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { ext, vec2 } from '@antv/matrix-util';\nimport { isNumberEqual } from '@antv/util';\nimport Coordinate from './base';\n/**\n * 螺旋坐标系\n */\nvar Helix = /** @class */function (_super) {\n  __extends(Helix, _super);\n  function Helix(cfg) {\n    var _this = _super.call(this, cfg) || this;\n    _this.isHelix = true;\n    _this.type = 'helix';\n    var _a = cfg.startAngle,\n      startAngle = _a === void 0 ? 1.25 * Math.PI : _a,\n      _b = cfg.endAngle,\n      endAngle = _b === void 0 ? 7.25 * Math.PI : _b,\n      _c = cfg.innerRadius,\n      innerRadius = _c === void 0 ? 0 : _c,\n      radius = cfg.radius;\n    _this.startAngle = startAngle;\n    _this.endAngle = endAngle;\n    _this.innerRadius = innerRadius;\n    _this.radius = radius;\n    _this.initial();\n    return _this;\n  }\n  Helix.prototype.initial = function () {\n    _super.prototype.initial.call(this);\n    var index = (this.endAngle - this.startAngle) / (2 * Math.PI) + 1; // 螺线圈数\n    var maxRadius = Math.min(this.width, this.height) / 2;\n    if (this.radius && this.radius >= 0 && this.radius <= 1) {\n      maxRadius = maxRadius * this.radius;\n    }\n    this.d = Math.floor(maxRadius * (1 - this.innerRadius) / index);\n    this.a = this.d / (Math.PI * 2); // 螺线系数\n    this.x = {\n      start: this.startAngle,\n      end: this.endAngle\n    };\n    this.y = {\n      start: this.innerRadius * maxRadius,\n      end: this.innerRadius * maxRadius + this.d * 0.99\n    };\n  };\n  /**\n   * 将百分比数据变成屏幕坐标\n   * @param point 归一化的点坐标\n   * @return      返回对应的屏幕坐标\n   */\n  Helix.prototype.convertPoint = function (point) {\n    var _a;\n    var x = point.x,\n      y = point.y;\n    if (this.isTransposed) {\n      _a = [y, x], x = _a[0], y = _a[1];\n    }\n    var thi = this.convertDim(x, 'x');\n    var r = this.a * thi;\n    var newY = this.convertDim(y, 'y');\n    return {\n      x: this.center.x + Math.cos(thi) * (r + newY),\n      y: this.center.y + Math.sin(thi) * (r + newY)\n    };\n  };\n  /**\n   * 将屏幕坐标点还原成百分比数据\n   * @param point 屏幕坐标\n   * @return      返回对应的归一化后的数据\n   */\n  Helix.prototype.invertPoint = function (point) {\n    var _a;\n    var d = this.d + this.y.start;\n    var v = vec2.subtract([0, 0], [point.x, point.y], [this.center.x, this.center.y]);\n    var thi = ext.angleTo(v, [1, 0], true);\n    var rMin = thi * this.a; // 坐标与原点的连线在第一圈上的交点，最小r值\n    if (vec2.length(v) < rMin) {\n      // 坐标与原点的连线不可能小于最小r值，但不排除因小数计算产生的略小于rMin的情况\n      rMin = vec2.length(v);\n    }\n    var index = Math.floor((vec2.length(v) - rMin) / d); // 当前点位于第index圈\n    thi = 2 * index * Math.PI + thi;\n    var r = this.a * thi;\n    var newY = vec2.length(v) - r;\n    newY = isNumberEqual(newY, 0) ? 0 : newY;\n    var x = this.invertDim(thi, 'x');\n    var y = this.invertDim(newY, 'y');\n    x = isNumberEqual(x, 0) ? 0 : x;\n    y = isNumberEqual(y, 0) ? 0 : y;\n    if (this.isTransposed) {\n      _a = [y, x], x = _a[0], y = _a[1];\n    }\n    return {\n      x: x,\n      y: y\n    };\n  };\n  return Helix;\n}(Coordinate);\nexport default Helix;","map":{"version":3,"sources":["../../src/coord/helix.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __extends } from \"tslib\";\nimport { ext, vec2 } from '@antv/matrix-util';\nimport { isNumberEqual } from '@antv/util';\nimport Coordinate from './base';\n/**\n * 螺旋坐标系\n */\nvar Helix = /** @class */ (function (_super) {\n    __extends(Helix, _super);\n    function Helix(cfg) {\n        var _this = _super.call(this, cfg) || this;\n        _this.isHelix = true;\n        _this.type = 'helix';\n        var _a = cfg.startAngle, startAngle = _a === void 0 ? 1.25 * Math.PI : _a, _b = cfg.endAngle, endAngle = _b === void 0 ? 7.25 * Math.PI : _b, _c = cfg.innerRadius, innerRadius = _c === void 0 ? 0 : _c, radius = cfg.radius;\n        _this.startAngle = startAngle;\n        _this.endAngle = endAngle;\n        _this.innerRadius = innerRadius;\n        _this.radius = radius;\n        _this.initial();\n        return _this;\n    }\n    Helix.prototype.initial = function () {\n        _super.prototype.initial.call(this);\n        var index = (this.endAngle - this.startAngle) / (2 * Math.PI) + 1; // 螺线圈数\n        var maxRadius = Math.min(this.width, this.height) / 2;\n        if (this.radius && this.radius >= 0 && this.radius <= 1) {\n            maxRadius = maxRadius * this.radius;\n        }\n        this.d = Math.floor((maxRadius * (1 - this.innerRadius)) / index);\n        this.a = this.d / (Math.PI * 2); // 螺线系数\n        this.x = {\n            start: this.startAngle,\n            end: this.endAngle,\n        };\n        this.y = {\n            start: this.innerRadius * maxRadius,\n            end: this.innerRadius * maxRadius + this.d * 0.99,\n        };\n    };\n    /**\n     * 将百分比数据变成屏幕坐标\n     * @param point 归一化的点坐标\n     * @return      返回对应的屏幕坐标\n     */\n    Helix.prototype.convertPoint = function (point) {\n        var _a;\n        var x = point.x, y = point.y;\n        if (this.isTransposed) {\n            _a = [y, x], x = _a[0], y = _a[1];\n        }\n        var thi = this.convertDim(x, 'x');\n        var r = this.a * thi;\n        var newY = this.convertDim(y, 'y');\n        return {\n            x: this.center.x + Math.cos(thi) * (r + newY),\n            y: this.center.y + Math.sin(thi) * (r + newY),\n        };\n    };\n    /**\n     * 将屏幕坐标点还原成百分比数据\n     * @param point 屏幕坐标\n     * @return      返回对应的归一化后的数据\n     */\n    Helix.prototype.invertPoint = function (point) {\n        var _a;\n        var d = this.d + this.y.start;\n        var v = vec2.subtract([0, 0], [point.x, point.y], [this.center.x, this.center.y]);\n        var thi = ext.angleTo(v, [1, 0], true);\n        var rMin = thi * this.a; // 坐标与原点的连线在第一圈上的交点，最小r值\n        if (vec2.length(v) < rMin) {\n            // 坐标与原点的连线不可能小于最小r值，但不排除因小数计算产生的略小于rMin的情况\n            rMin = vec2.length(v);\n        }\n        var index = Math.floor((vec2.length(v) - rMin) / d); // 当前点位于第index圈\n        thi = 2 * index * Math.PI + thi;\n        var r = this.a * thi;\n        var newY = vec2.length(v) - r;\n        newY = isNumberEqual(newY, 0) ? 0 : newY;\n        var x = this.invertDim(thi, 'x');\n        var y = this.invertDim(newY, 'y');\n        x = isNumberEqual(x, 0) ? 0 : x;\n        y = isNumberEqual(y, 0) ? 0 : y;\n        if (this.isTransposed) {\n            _a = [y, x], x = _a[0], y = _a[1];\n        }\n        return { x: x, y: y };\n    };\n    return Helix;\n}(Coordinate));\nexport default Helix;\n//# sourceMappingURL=helix.js.map"]},"metadata":{},"sourceType":"module"}