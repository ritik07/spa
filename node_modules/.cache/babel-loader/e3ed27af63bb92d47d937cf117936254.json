{"ast":null,"code":"import { __spreadArrays } from \"tslib\";\nimport { catmullRom2Bezier } from '@antv/path-util';\nimport { Category, Linear } from '@antv/scale';\nimport { each, head, isEqual, map } from '@antv/util';\n/**\n * 点数组转 path\n * @param points\n */\nfunction pointsToPath(points) {\n  return map(points, function (p, idx) {\n    var command = idx === 0 ? 'M' : 'L';\n    var x = p[0],\n      y = p[1];\n    return [command, x, y];\n  });\n}\n/**\n * 将点连接成路径 path\n * @param points\n */\nexport function getLinePath(points) {\n  return pointsToPath(points);\n}\n/**\n * 将点连成平滑的曲线\n * @param points\n */\nexport function getSmoothLinePath(points) {\n  if (points.length <= 2) {\n    // 两点以内直接绘制成路径\n    return getLinePath(points);\n  }\n  var data = [];\n  each(points, function (p) {\n    // 当前点和上一个点一样的时候，忽略掉\n    if (!isEqual(p, data.slice(data.length - 2))) {\n      data.push(p[0], p[1]);\n    }\n  });\n  // const constraint = [ // 范围\n  //   [ 0, 0 ],\n  //   [ 1, 1 ],\n  // ];\n  var path = catmullRom2Bezier(data, false);\n  var _a = head(points),\n    x = _a[0],\n    y = _a[1];\n  path.unshift(['M', x, y]);\n  return path;\n}\n/**\n * 将数据转成 path，利用 scale 的归一化能力\n * @param data\n * @param width\n * @param height\n * @param smooth\n */\nexport function dataToPath(data, width, height, smooth) {\n  if (smooth === void 0) {\n    smooth = true;\n  }\n  // 利用 scale 来获取 y 上的映射\n  var y = new Linear({\n    values: data\n  });\n  var x = new Category({\n    values: map(data, function (v, idx) {\n      return idx;\n    })\n  });\n  var points = map(data, function (v, idx) {\n    return [x.scale(idx) * width, height - y.scale(v) * height];\n  });\n  return smooth ? getSmoothLinePath(points) : getLinePath(points);\n}\n/**\n * 获得 area 面积的横向连接线的 px 位置\n * @param data\n * @param width\n * @param height\n */\nexport function getAreaLineY(data, height) {\n  var y = new Linear({\n    values: data\n  });\n  // 当曲线全部为负数时，取最大值，当曲线全部为正数时，取最小值，当曲线有正有负，则取零点\n  var lineY = y.max < 0 ? y.max : Math.max(0, y.min);\n  return height - y.scale(lineY) * height;\n}\n/**\n * 线 path 转 area path\n * @param path\n * @param width\n * @param height\n */\nexport function linePathToAreaPath(path, width, height, data) {\n  var areaPath = __spreadArrays(path);\n  var lineYPx = getAreaLineY(data, height);\n  areaPath.push(['L', width, lineYPx]);\n  areaPath.push(['L', 0, lineYPx]);\n  areaPath.push(['Z']);\n  return areaPath;\n}","map":{"version":3,"sources":["../../src/trend/path.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __spreadArrays } from \"tslib\";\nimport { catmullRom2Bezier } from '@antv/path-util';\nimport { Category, Linear } from '@antv/scale';\nimport { each, head, isEqual, map } from '@antv/util';\n/**\n * 点数组转 path\n * @param points\n */\nfunction pointsToPath(points) {\n    return map(points, function (p, idx) {\n        var command = idx === 0 ? 'M' : 'L';\n        var x = p[0], y = p[1];\n        return [command, x, y];\n    });\n}\n/**\n * 将点连接成路径 path\n * @param points\n */\nexport function getLinePath(points) {\n    return pointsToPath(points);\n}\n/**\n * 将点连成平滑的曲线\n * @param points\n */\nexport function getSmoothLinePath(points) {\n    if (points.length <= 2) {\n        // 两点以内直接绘制成路径\n        return getLinePath(points);\n    }\n    var data = [];\n    each(points, function (p) {\n        // 当前点和上一个点一样的时候，忽略掉\n        if (!isEqual(p, data.slice(data.length - 2))) {\n            data.push(p[0], p[1]);\n        }\n    });\n    // const constraint = [ // 范围\n    //   [ 0, 0 ],\n    //   [ 1, 1 ],\n    // ];\n    var path = catmullRom2Bezier(data, false);\n    var _a = head(points), x = _a[0], y = _a[1];\n    path.unshift(['M', x, y]);\n    return path;\n}\n/**\n * 将数据转成 path，利用 scale 的归一化能力\n * @param data\n * @param width\n * @param height\n * @param smooth\n */\nexport function dataToPath(data, width, height, smooth) {\n    if (smooth === void 0) { smooth = true; }\n    // 利用 scale 来获取 y 上的映射\n    var y = new Linear({\n        values: data,\n    });\n    var x = new Category({\n        values: map(data, function (v, idx) { return idx; }),\n    });\n    var points = map(data, function (v, idx) {\n        return [x.scale(idx) * width, height - y.scale(v) * height];\n    });\n    return smooth ? getSmoothLinePath(points) : getLinePath(points);\n}\n/**\n * 获得 area 面积的横向连接线的 px 位置\n * @param data\n * @param width\n * @param height\n */\nexport function getAreaLineY(data, height) {\n    var y = new Linear({\n        values: data,\n    });\n    // 当曲线全部为负数时，取最大值，当曲线全部为正数时，取最小值，当曲线有正有负，则取零点\n    var lineY = y.max < 0 ? y.max : Math.max(0, y.min);\n    return height - y.scale(lineY) * height;\n}\n/**\n * 线 path 转 area path\n * @param path\n * @param width\n * @param height\n */\nexport function linePathToAreaPath(path, width, height, data) {\n    var areaPath = __spreadArrays(path);\n    var lineYPx = getAreaLineY(data, height);\n    areaPath.push(['L', width, lineYPx]);\n    areaPath.push(['L', 0, lineYPx]);\n    areaPath.push(['Z']);\n    return areaPath;\n}\n//# sourceMappingURL=path.js.map"]},"metadata":{},"sourceType":"module"}