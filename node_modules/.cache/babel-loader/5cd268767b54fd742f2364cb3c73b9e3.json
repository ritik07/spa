{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as _ from '@antv/util';\nimport Adjust from './adjust';\nvar Symmetric = /** @class */function (_super) {\n  __extends(Symmetric, _super);\n  function Symmetric() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  Symmetric.prototype.process = function (groupDataArray) {\n    var mergeData = _.flatten(groupDataArray);\n    var _a = this,\n      xField = _a.xField,\n      yField = _a.yField;\n    // 每个 x 值对应的 最大值\n    var cache = this.getXValuesMaxMap(mergeData);\n    // 所有数据的最大的值\n    var max = Math.max.apply(Math, Object.keys(cache).map(function (key) {\n      return cache[key];\n    }));\n    return _.map(groupDataArray, function (dataArray) {\n      return _.map(dataArray, function (data) {\n        var _a, _b;\n        var yValue = data[yField];\n        var xValue = data[xField];\n        // 数组处理逻辑\n        if (_.isArray(yValue)) {\n          var off_1 = (max - cache[xValue]) / 2;\n          return __assign(__assign({}, data), (_a = {}, _a[yField] = _.map(yValue, function (y) {\n            return off_1 + y;\n          }), _a));\n        }\n        // 非数组处理逻辑\n        var offset = (max - yValue) / 2;\n        return __assign(__assign({}, data), (_b = {}, _b[yField] = [offset, yValue + offset], _b));\n      });\n    });\n  };\n  // 获取每个 x 对应的最大的值\n  Symmetric.prototype.getXValuesMaxMap = function (mergeData) {\n    var _this = this;\n    var _a = this,\n      xField = _a.xField,\n      yField = _a.yField;\n    // 根据 xField 的值进行分组\n    var groupDataArray = _.groupBy(mergeData, function (data) {\n      return data[xField];\n    });\n    // 获取每个 xField 值中的最大值\n    return _.mapValues(groupDataArray, function (dataArray) {\n      return _this.getDimMaxValue(dataArray, yField);\n    });\n  };\n  Symmetric.prototype.getDimMaxValue = function (mergeData, dim) {\n    // 所有的 value 值\n    var dimValues = _.map(mergeData, function (data) {\n      return _.get(data, dim, []);\n    });\n    // 将数组打平（dim value 有可能是数组，比如 stack 之后的）\n    var flattenValues = _.flatten(dimValues);\n    // 求出数组的最大值\n    return Math.max.apply(Math, flattenValues);\n  };\n  return Symmetric;\n}(Adjust);\nexport default Symmetric;","map":{"version":3,"sources":["../../src/adjusts/symmetric.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __assign, __extends } from \"tslib\";\nimport * as _ from '@antv/util';\nimport Adjust from './adjust';\nvar Symmetric = /** @class */ (function (_super) {\n    __extends(Symmetric, _super);\n    function Symmetric() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Symmetric.prototype.process = function (groupDataArray) {\n        var mergeData = _.flatten(groupDataArray);\n        var _a = this, xField = _a.xField, yField = _a.yField;\n        // 每个 x 值对应的 最大值\n        var cache = this.getXValuesMaxMap(mergeData);\n        // 所有数据的最大的值\n        var max = Math.max.apply(Math, Object.keys(cache).map(function (key) { return cache[key]; }));\n        return _.map(groupDataArray, function (dataArray) {\n            return _.map(dataArray, function (data) {\n                var _a, _b;\n                var yValue = data[yField];\n                var xValue = data[xField];\n                // 数组处理逻辑\n                if (_.isArray(yValue)) {\n                    var off_1 = (max - cache[xValue]) / 2;\n                    return __assign(__assign({}, data), (_a = {}, _a[yField] = _.map(yValue, function (y) { return off_1 + y; }), _a));\n                }\n                // 非数组处理逻辑\n                var offset = (max - yValue) / 2;\n                return __assign(__assign({}, data), (_b = {}, _b[yField] = [offset, yValue + offset], _b));\n            });\n        });\n    };\n    // 获取每个 x 对应的最大的值\n    Symmetric.prototype.getXValuesMaxMap = function (mergeData) {\n        var _this = this;\n        var _a = this, xField = _a.xField, yField = _a.yField;\n        // 根据 xField 的值进行分组\n        var groupDataArray = _.groupBy(mergeData, function (data) { return data[xField]; });\n        // 获取每个 xField 值中的最大值\n        return _.mapValues(groupDataArray, function (dataArray) { return _this.getDimMaxValue(dataArray, yField); });\n    };\n    Symmetric.prototype.getDimMaxValue = function (mergeData, dim) {\n        // 所有的 value 值\n        var dimValues = _.map(mergeData, function (data) { return _.get(data, dim, []); });\n        // 将数组打平（dim value 有可能是数组，比如 stack 之后的）\n        var flattenValues = _.flatten(dimValues);\n        // 求出数组的最大值\n        return Math.max.apply(Math, flattenValues);\n    };\n    return Symmetric;\n}(Adjust));\nexport default Symmetric;\n//# sourceMappingURL=symmetric.js.map"]},"metadata":{},"sourceType":"module"}