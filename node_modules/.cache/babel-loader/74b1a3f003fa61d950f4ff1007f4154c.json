{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { getCirclePoint } from '../util/util';\nimport CrosshairBase from './base';\nvar LineCrosshair = /** @class */function (_super) {\n  __extends(LineCrosshair, _super);\n  function LineCrosshair() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  LineCrosshair.prototype.getDefaultCfg = function () {\n    var cfg = _super.prototype.getDefaultCfg.call(this);\n    return __assign(__assign({}, cfg), {\n      type: 'circle',\n      locationType: 'circle',\n      center: null,\n      radius: 100,\n      startAngle: -Math.PI / 2,\n      endAngle: Math.PI * 3 / 2\n    });\n  };\n  LineCrosshair.prototype.getRotateAngle = function () {\n    var _a = this.getLocation(),\n      startAngle = _a.startAngle,\n      endAngle = _a.endAngle;\n    var position = this.get('text').position;\n    var tangentAngle = position === 'start' ? startAngle + Math.PI / 2 : endAngle - Math.PI / 2;\n    return tangentAngle;\n  };\n  LineCrosshair.prototype.getTextPoint = function () {\n    var text = this.get('text');\n    var position = text.position,\n      offset = text.offset;\n    var _a = this.getLocation(),\n      center = _a.center,\n      radius = _a.radius,\n      startAngle = _a.startAngle,\n      endAngle = _a.endAngle;\n    var angle = position === 'start' ? startAngle : endAngle;\n    var tangentAngle = this.getRotateAngle() - Math.PI;\n    var point = getCirclePoint(center, radius, angle);\n    // 这个地方其实应该求切线向量然后在乘以 offset，但是太啰嗦了，直接给出结果\n    // const tangent = [Math.cos(tangentAngle), Math.sin(tangentAngle)];\n    // const offsetVector = vec2.scale([], tangent, offset);\n    var offsetX = Math.cos(tangentAngle) * offset;\n    var offsetY = Math.sin(tangentAngle) * offset;\n    return {\n      x: point.x + offsetX,\n      y: point.y + offsetY\n    };\n  };\n  LineCrosshair.prototype.getLinePath = function () {\n    var _a = this.getLocation(),\n      center = _a.center,\n      radius = _a.radius,\n      startAngle = _a.startAngle,\n      endAngle = _a.endAngle;\n    var path = null;\n    if (endAngle - startAngle === Math.PI * 2) {\n      // 整圆\n      var x = center.x,\n        y = center.y;\n      path = [['M', x, y - radius], ['A', radius, radius, 0, 1, 1, x, y + radius], ['A', radius, radius, 0, 1, 1, x, y - radius], ['Z']];\n    } else {\n      var startPoint = getCirclePoint(center, radius, startAngle);\n      var endPoint = getCirclePoint(center, radius, endAngle);\n      var large = Math.abs(endAngle - startAngle) > Math.PI ? 1 : 0;\n      var sweep = startAngle > endAngle ? 0 : 1;\n      path = [['M', startPoint.x, startPoint.y], ['A', radius, radius, 0, large, sweep, endPoint.x, endPoint.y]];\n    }\n    return path;\n  };\n  return LineCrosshair;\n}(CrosshairBase);\nexport default LineCrosshair;","map":{"version":3,"sources":["../../src/crosshair/circle.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __assign, __extends } from \"tslib\";\nimport { getCirclePoint } from '../util/util';\nimport CrosshairBase from './base';\nvar LineCrosshair = /** @class */ (function (_super) {\n    __extends(LineCrosshair, _super);\n    function LineCrosshair() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    LineCrosshair.prototype.getDefaultCfg = function () {\n        var cfg = _super.prototype.getDefaultCfg.call(this);\n        return __assign(__assign({}, cfg), { type: 'circle', locationType: 'circle', center: null, radius: 100, startAngle: -Math.PI / 2, endAngle: (Math.PI * 3) / 2 });\n    };\n    LineCrosshair.prototype.getRotateAngle = function () {\n        var _a = this.getLocation(), startAngle = _a.startAngle, endAngle = _a.endAngle;\n        var position = this.get('text').position;\n        var tangentAngle = position === 'start' ? startAngle + Math.PI / 2 : endAngle - Math.PI / 2;\n        return tangentAngle;\n    };\n    LineCrosshair.prototype.getTextPoint = function () {\n        var text = this.get('text');\n        var position = text.position, offset = text.offset;\n        var _a = this.getLocation(), center = _a.center, radius = _a.radius, startAngle = _a.startAngle, endAngle = _a.endAngle;\n        var angle = position === 'start' ? startAngle : endAngle;\n        var tangentAngle = this.getRotateAngle() - Math.PI;\n        var point = getCirclePoint(center, radius, angle);\n        // 这个地方其实应该求切线向量然后在乘以 offset，但是太啰嗦了，直接给出结果\n        // const tangent = [Math.cos(tangentAngle), Math.sin(tangentAngle)];\n        // const offsetVector = vec2.scale([], tangent, offset);\n        var offsetX = Math.cos(tangentAngle) * offset;\n        var offsetY = Math.sin(tangentAngle) * offset;\n        return {\n            x: point.x + offsetX,\n            y: point.y + offsetY,\n        };\n    };\n    LineCrosshair.prototype.getLinePath = function () {\n        var _a = this.getLocation(), center = _a.center, radius = _a.radius, startAngle = _a.startAngle, endAngle = _a.endAngle;\n        var path = null;\n        if (endAngle - startAngle === Math.PI * 2) {\n            // 整圆\n            var x = center.x, y = center.y;\n            path = [\n                ['M', x, y - radius],\n                ['A', radius, radius, 0, 1, 1, x, y + radius],\n                ['A', radius, radius, 0, 1, 1, x, y - radius],\n                ['Z'],\n            ];\n        }\n        else {\n            var startPoint = getCirclePoint(center, radius, startAngle);\n            var endPoint = getCirclePoint(center, radius, endAngle);\n            var large = Math.abs(endAngle - startAngle) > Math.PI ? 1 : 0;\n            var sweep = startAngle > endAngle ? 0 : 1;\n            path = [\n                ['M', startPoint.x, startPoint.y],\n                ['A', radius, radius, 0, large, sweep, endPoint.x, endPoint.y],\n            ];\n        }\n        return path;\n    };\n    return LineCrosshair;\n}(CrosshairBase));\nexport default LineCrosshair;\n//# sourceMappingURL=circle.js.map"]},"metadata":{},"sourceType":"module"}