{"ast":null,"code":"import { __assign } from \"tslib\";\n/**\n * @fileoverview path 的一些工具\n * @author dxq613@gmail.com\n */\nimport { PathUtil } from '@antv/g-base';\nimport { Quad as QuadUtil } from '@antv/g-math';\nimport { Cubic as CubicUtil } from '@antv/g-math';\nimport { ext } from '@antv/matrix-util';\nimport * as vec3 from 'gl-matrix/vec3';\nimport { inBox } from './util';\nimport inLine from './in-stroke/line';\nimport inArc from './in-stroke/arc';\nvar transform = ext.transform;\nfunction hasArc(path) {\n  var hasArc = false;\n  var count = path.length;\n  for (var i = 0; i < count; i++) {\n    var params = path[i];\n    var cmd = params[0];\n    if (cmd === 'C' || cmd === 'A' || cmd === 'Q') {\n      hasArc = true;\n      break;\n    }\n  }\n  return hasArc;\n}\nfunction isPointInStroke(segments, lineWidth, x, y, length) {\n  var isHit = false;\n  var halfWidth = lineWidth / 2;\n  for (var i = 0; i < segments.length; i++) {\n    var segment = segments[i];\n    var currentPoint = segment.currentPoint,\n      params = segment.params,\n      prePoint = segment.prePoint,\n      box = segment.box;\n    // 如果在前面已经生成过包围盒，直接按照包围盒计算\n    if (box && !inBox(box.x - halfWidth, box.y - halfWidth, box.width + lineWidth, box.height + lineWidth, x, y)) {\n      continue;\n    }\n    switch (segment.command) {\n      // L 和 Z 都是直线， M 不进行拾取\n      case 'L':\n      case 'Z':\n        isHit = inLine(prePoint[0], prePoint[1], currentPoint[0], currentPoint[1], lineWidth, x, y);\n        break;\n      case 'Q':\n        var qDistance = QuadUtil.pointDistance(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], x, y);\n        isHit = qDistance <= lineWidth / 2;\n        break;\n      case 'C':\n        var cDistance = CubicUtil.pointDistance(prePoint[0],\n        // 上一段结束位置, 即 C 的起始点\n        prePoint[1], params[1],\n        // 'C' 的参数，1、2 为第一个控制点，3、4 为第二个控制点，5、6 为结束点\n        params[2], params[3], params[4], params[5], params[6], x, y, length);\n        isHit = cDistance <= lineWidth / 2;\n        break;\n      case 'A':\n        // 计算点到椭圆圆弧的距离，暂时使用近似算法，后面可以改成切割法求最近距离\n        var arcParams = segment.arcParams;\n        var cx = arcParams.cx,\n          cy = arcParams.cy,\n          rx = arcParams.rx,\n          ry = arcParams.ry,\n          startAngle = arcParams.startAngle,\n          endAngle = arcParams.endAngle,\n          xRotation = arcParams.xRotation;\n        var p = [x, y, 1];\n        var r = rx > ry ? rx : ry;\n        var scaleX = rx > ry ? 1 : rx / ry;\n        var scaleY = rx > ry ? ry / rx : 1;\n        var m = transform(null, [['t', -cx, -cy], ['r', -xRotation], ['s', 1 / scaleX, 1 / scaleY]]);\n        vec3.transformMat3(p, p, m);\n        isHit = inArc(0, 0, r, startAngle, endAngle, lineWidth, p[0], p[1]);\n        break;\n      default:\n        break;\n    }\n    if (isHit) {\n      break;\n    }\n  }\n  return isHit;\n}\n/**\n * 提取出内部的闭合多边形和非闭合的多边形，假设 path 不存在圆弧\n * @param {Array} path 路径\n * @returns {Array} 点的集合\n */\nfunction extractPolygons(path) {\n  var count = path.length;\n  var polygons = [];\n  var polylines = [];\n  var points = []; // 防止第一个命令不是 'M'\n  for (var i = 0; i < count; i++) {\n    var params = path[i];\n    var cmd = params[0];\n    if (cmd === 'M') {\n      // 遇到 'M' 判定是否是新数组，新数组中没有点\n      if (points.length) {\n        // 如果存在点，则说明没有遇到 'Z'，开始了一个新的多边形\n        polylines.push(points);\n        points = []; // 创建新的点\n      }\n\n      points.push([params[1], params[2]]);\n    } else if (cmd === 'Z') {\n      if (points.length) {\n        // 存在点\n        polygons.push(points);\n        points = []; // 开始新的点集合\n      }\n      // 如果不存在点，同时 'Z'，则说明是错误，不处理\n    } else {\n      points.push([params[1], params[2]]);\n    }\n  }\n  // 说明 points 未放入 polygons 或者 polyline\n  // 仅当只有一个 M，没有 Z 时会发生这种情况\n  if (points.length > 0) {\n    polylines.push(points);\n  }\n  return {\n    polygons: polygons,\n    polylines: polylines\n  };\n}\nexport default __assign({\n  hasArc: hasArc,\n  extractPolygons: extractPolygons,\n  isPointInStroke: isPointInStroke\n}, PathUtil);","map":{"version":3,"sources":["../../src/util/path.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __assign } from \"tslib\";\n/**\n * @fileoverview path 的一些工具\n * @author dxq613@gmail.com\n */\nimport { PathUtil } from '@antv/g-base';\nimport { Quad as QuadUtil } from '@antv/g-math';\nimport { Cubic as CubicUtil } from '@antv/g-math';\nimport { ext } from '@antv/matrix-util';\nimport * as vec3 from 'gl-matrix/vec3';\nimport { inBox } from './util';\nimport inLine from './in-stroke/line';\nimport inArc from './in-stroke/arc';\nvar transform = ext.transform;\nfunction hasArc(path) {\n    var hasArc = false;\n    var count = path.length;\n    for (var i = 0; i < count; i++) {\n        var params = path[i];\n        var cmd = params[0];\n        if (cmd === 'C' || cmd === 'A' || cmd === 'Q') {\n            hasArc = true;\n            break;\n        }\n    }\n    return hasArc;\n}\nfunction isPointInStroke(segments, lineWidth, x, y, length) {\n    var isHit = false;\n    var halfWidth = lineWidth / 2;\n    for (var i = 0; i < segments.length; i++) {\n        var segment = segments[i];\n        var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint, box = segment.box;\n        // 如果在前面已经生成过包围盒，直接按照包围盒计算\n        if (box && !inBox(box.x - halfWidth, box.y - halfWidth, box.width + lineWidth, box.height + lineWidth, x, y)) {\n            continue;\n        }\n        switch (segment.command) {\n            // L 和 Z 都是直线， M 不进行拾取\n            case 'L':\n            case 'Z':\n                isHit = inLine(prePoint[0], prePoint[1], currentPoint[0], currentPoint[1], lineWidth, x, y);\n                break;\n            case 'Q':\n                var qDistance = QuadUtil.pointDistance(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], x, y);\n                isHit = qDistance <= lineWidth / 2;\n                break;\n            case 'C':\n                var cDistance = CubicUtil.pointDistance(prePoint[0], // 上一段结束位置, 即 C 的起始点\n                prePoint[1], params[1], // 'C' 的参数，1、2 为第一个控制点，3、4 为第二个控制点，5、6 为结束点\n                params[2], params[3], params[4], params[5], params[6], x, y, length);\n                isHit = cDistance <= lineWidth / 2;\n                break;\n            case 'A':\n                // 计算点到椭圆圆弧的距离，暂时使用近似算法，后面可以改成切割法求最近距离\n                var arcParams = segment.arcParams;\n                var cx = arcParams.cx, cy = arcParams.cy, rx = arcParams.rx, ry = arcParams.ry, startAngle = arcParams.startAngle, endAngle = arcParams.endAngle, xRotation = arcParams.xRotation;\n                var p = [x, y, 1];\n                var r = rx > ry ? rx : ry;\n                var scaleX = rx > ry ? 1 : rx / ry;\n                var scaleY = rx > ry ? ry / rx : 1;\n                var m = transform(null, [\n                    ['t', -cx, -cy],\n                    ['r', -xRotation],\n                    ['s', 1 / scaleX, 1 / scaleY],\n                ]);\n                vec3.transformMat3(p, p, m);\n                isHit = inArc(0, 0, r, startAngle, endAngle, lineWidth, p[0], p[1]);\n                break;\n            default:\n                break;\n        }\n        if (isHit) {\n            break;\n        }\n    }\n    return isHit;\n}\n/**\n * 提取出内部的闭合多边形和非闭合的多边形，假设 path 不存在圆弧\n * @param {Array} path 路径\n * @returns {Array} 点的集合\n */\nfunction extractPolygons(path) {\n    var count = path.length;\n    var polygons = [];\n    var polylines = [];\n    var points = []; // 防止第一个命令不是 'M'\n    for (var i = 0; i < count; i++) {\n        var params = path[i];\n        var cmd = params[0];\n        if (cmd === 'M') {\n            // 遇到 'M' 判定是否是新数组，新数组中没有点\n            if (points.length) {\n                // 如果存在点，则说明没有遇到 'Z'，开始了一个新的多边形\n                polylines.push(points);\n                points = []; // 创建新的点\n            }\n            points.push([params[1], params[2]]);\n        }\n        else if (cmd === 'Z') {\n            if (points.length) {\n                // 存在点\n                polygons.push(points);\n                points = []; // 开始新的点集合\n            }\n            // 如果不存在点，同时 'Z'，则说明是错误，不处理\n        }\n        else {\n            points.push([params[1], params[2]]);\n        }\n    }\n    // 说明 points 未放入 polygons 或者 polyline\n    // 仅当只有一个 M，没有 Z 时会发生这种情况\n    if (points.length > 0) {\n        polylines.push(points);\n    }\n    return {\n        polygons: polygons,\n        polylines: polylines,\n    };\n}\nexport default __assign({ hasArc: hasArc,\n    extractPolygons: extractPolygons,\n    isPointInStroke: isPointInStroke }, PathUtil);\n//# sourceMappingURL=path.js.map"]},"metadata":{},"sourceType":"module"}