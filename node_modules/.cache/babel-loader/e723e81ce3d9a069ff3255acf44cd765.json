{"ast":null,"code":"import { each } from '@antv/util';\nimport { getPathPoints } from '../util/get-path-points';\nimport { getStyle } from '../util/get-style';\nimport { getLinePath, getSplinePath } from '../util/path';\nfunction getPath(points, isInCircle, smooth, registeredShape, constraint) {\n  var path = [];\n  if (points.length) {\n    var topLinePoints_1 = []; // area 区域上部分\n    var bottomLinePoints_1 = []; // area 区域下部分\n    for (var i = 0, len = points.length; i < len; i++) {\n      var point = points[i];\n      topLinePoints_1.push(point[1]);\n      bottomLinePoints_1.push(point[0]);\n    }\n    bottomLinePoints_1 = bottomLinePoints_1.reverse();\n    each([topLinePoints_1, bottomLinePoints_1], function (pointsData, index) {\n      var subPath = [];\n      var parsedPoints = registeredShape.parsePoints(pointsData);\n      var p1 = parsedPoints[0];\n      if (topLinePoints_1.length === 1 && bottomLinePoints_1.length === 1) {\n        // 都只有一个点，绘制一条竖线\n        subPath = index === 0 ? [['M', p1.x - 0.5, p1.y], ['L', p1.x + 0.5, p1.y]] : [['L', p1.x + 0.5, p1.y], ['L', p1.x - 0.5, p1.y]];\n      } else {\n        if (isInCircle) {\n          parsedPoints.push({\n            x: p1.x,\n            y: p1.y\n          });\n        }\n        if (smooth) {\n          subPath = getSplinePath(parsedPoints, false, constraint);\n        } else {\n          subPath = getLinePath(parsedPoints, false);\n        }\n        if (index > 0) {\n          subPath[0][0] = 'L';\n        }\n      }\n      path = path.concat(subPath);\n    });\n    path.push(['Z']);\n  }\n  return path;\n}\n/**\n * @ignore\n * Gets shape attrs\n * @param cfg\n * @param isStroke\n * @param smooth\n * @param registeredShape\n * @param [constraint]\n * @returns\n */\nexport function getShapeAttrs(cfg, isStroke, smooth, registeredShape, constraint) {\n  var attrs = getStyle(cfg, isStroke, !isStroke, 'lineWidth');\n  var connectNulls = cfg.connectNulls,\n    isInCircle = cfg.isInCircle,\n    points = cfg.points,\n    showSinglePoint = cfg.showSinglePoint;\n  var pathPoints = getPathPoints(points, connectNulls, showSinglePoint); // 根据 connectNulls 配置获取图形关键点\n  var path = [];\n  for (var i = 0, len = pathPoints.length; i < len; i++) {\n    var eachPoints = pathPoints[i];\n    path = path.concat(getPath(eachPoints, isInCircle, smooth, registeredShape, constraint));\n  }\n  attrs.path = path;\n  return attrs;\n}\n/**\n * @ignore\n * Gets constraint\n * @param coordinate\n * @returns constraint\n */\nexport function getConstraint(coordinate) {\n  var start = coordinate.start,\n    end = coordinate.end;\n  return [[start.x, end.y], [end.x, start.y]];\n}","map":{"version":3,"sources":["../../../../src/geometry/shape/area/util.ts"],"names":[],"mappings":"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","sourcesContent":["import { each } from '@antv/util';\nimport { Coordinate, PathCommand } from '../../../dependents';\nimport { Point, Position, Shape, ShapeInfo } from '../../../interface';\n\nimport { getPathPoints } from '../util/get-path-points';\nimport { getStyle } from '../util/get-style';\nimport { getLinePath, getSplinePath } from '../util/path';\n\nfunction getPath(\n  points: Point[],\n  isInCircle: boolean,\n  smooth: boolean,\n  registeredShape: Shape,\n  constraint?: Position[]\n): PathCommand[] {\n  let path = [];\n\n  if (points.length) {\n    const topLinePoints = []; // area 区域上部分\n    let bottomLinePoints = []; // area 区域下部分\n    for (let i = 0, len = points.length; i < len; i++) {\n      const point = points[i];\n      topLinePoints.push(point[1]);\n      bottomLinePoints.push(point[0]);\n    }\n    bottomLinePoints = bottomLinePoints.reverse();\n\n    each([topLinePoints, bottomLinePoints], (pointsData, index) => {\n      let subPath = [];\n      const parsedPoints = registeredShape.parsePoints(pointsData);\n      const p1 = parsedPoints[0];\n\n      if (topLinePoints.length === 1 && bottomLinePoints.length === 1) {\n        // 都只有一个点，绘制一条竖线\n        subPath =\n          index === 0\n            ? [\n                ['M', p1.x - 0.5, p1.y],\n                ['L', p1.x + 0.5, p1.y],\n              ]\n            : [\n                ['L', p1.x + 0.5, p1.y],\n                ['L', p1.x - 0.5, p1.y],\n              ];\n      } else {\n        if (isInCircle) {\n          parsedPoints.push({ x: p1.x, y: p1.y });\n        }\n        if (smooth) {\n          subPath = getSplinePath(parsedPoints, false, constraint);\n        } else {\n          subPath = getLinePath(parsedPoints, false);\n        }\n        if (index > 0) {\n          subPath[0][0] = 'L';\n        }\n      }\n\n      path = path.concat(subPath);\n    });\n\n    path.push(['Z']);\n  }\n\n  return path;\n}\n\n/**\n * @ignore\n * Gets shape attrs\n * @param cfg\n * @param isStroke\n * @param smooth\n * @param registeredShape\n * @param [constraint]\n * @returns\n */\nexport function getShapeAttrs(\n  cfg: ShapeInfo,\n  isStroke: boolean,\n  smooth: boolean,\n  registeredShape: Shape,\n  constraint?: Position[]\n) {\n  const attrs = getStyle(cfg, isStroke, !isStroke, 'lineWidth');\n  const { connectNulls, isInCircle, points, showSinglePoint } = cfg;\n  const pathPoints = getPathPoints(points, connectNulls, showSinglePoint); // 根据 connectNulls 配置获取图形关键点\n\n  let path = [];\n  for (let i = 0, len = pathPoints.length; i < len; i++) {\n    const eachPoints = pathPoints[i];\n    path = path.concat(getPath(eachPoints, isInCircle, smooth, registeredShape, constraint));\n  }\n  attrs.path = path;\n\n  return attrs;\n}\n\n/**\n * @ignore\n * Gets constraint\n * @param coordinate\n * @returns constraint\n */\nexport function getConstraint(coordinate: Coordinate): Position[] {\n  const { start, end } = coordinate;\n  return [\n    [start.x, end.y],\n    [end.x, start.y],\n  ];\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}