{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { deepMix, each, get, isUndefined } from '@antv/util';\nimport { DIRECTION, COMPONENT_TYPE, LAYER } from '../../constant';\nimport { CircleAxis, CircleGrid, LineAxis, LineGrid } from '../../dependents';\nimport { DEFAULT_ANIMATE_CFG } from '../../animate/';\nimport { getAxisDirection, getAxisFactorByRegion, getAxisRegion, getAxisThemeCfg, getAxisTitleOptions, getAxisTitleText, getCircleAxisCenterRadius, isVertical } from '../../util/axis';\nimport { getAxisOption } from '../../util/axis';\nimport { getCircleGridItems, getGridThemeCfg, getLineGridItems, showGrid } from '../../util/grid';\nimport { omit } from '../../util/helper';\nimport { Controller } from './base';\n// update 组件的时候，忽略的数据更新\nvar OMIT_CFG = ['container'];\n// 坐标轴默认动画配置\nvar AXIS_DEFAULT_ANIMATE_CFG = __assign(__assign({}, DEFAULT_ANIMATE_CFG), {\n  appear: null\n});\n/**\n * @ignore\n * G2 Axis controller, will:\n *  - create component\n *    - axis\n *    - grid\n *  - life circle\n */\nvar Axis = /** @class */function (_super) {\n  __extends(Axis, _super);\n  function Axis(view) {\n    var _this = _super.call(this, view) || this;\n    /** 使用 object 存储组件 */\n    _this.cache = new Map();\n    // 先创建 gridContainer，将 grid 放到 axis 底层\n    _this.gridContainer = _this.view.getLayer(LAYER.BG).addGroup();\n    _this.gridForeContainer = _this.view.getLayer(LAYER.FORE).addGroup();\n    _this.axisContainer = _this.view.getLayer(LAYER.BG).addGroup();\n    _this.axisForeContainer = _this.view.getLayer(LAYER.FORE).addGroup();\n    return _this;\n  }\n  Object.defineProperty(Axis.prototype, \"name\", {\n    get: function () {\n      return 'axis';\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Axis.prototype.init = function () {};\n  Axis.prototype.render = function () {\n    this.update();\n  };\n  /**\n   * 更新组件布局，位置大小\n   */\n  Axis.prototype.layout = function () {\n    var _this = this;\n    var coordinate = this.view.getCoordinate();\n    each(this.getComponents(), function (co) {\n      var component = co.component,\n        direction = co.direction,\n        type = co.type,\n        extra = co.extra;\n      var dim = extra.dim,\n        scale = extra.scale,\n        alignTick = extra.alignTick;\n      var updated;\n      if (type === COMPONENT_TYPE.AXIS) {\n        if (coordinate.isPolar) {\n          if (dim === 'x') {\n            updated = coordinate.isTransposed ? getAxisRegion(coordinate, direction) : getCircleAxisCenterRadius(coordinate);\n          } else if (dim === 'y') {\n            updated = coordinate.isTransposed ? getCircleAxisCenterRadius(coordinate) : getAxisRegion(coordinate, direction);\n          }\n        } else {\n          updated = getAxisRegion(coordinate, direction);\n        }\n      } else if (type === COMPONENT_TYPE.GRID) {\n        if (coordinate.isPolar) {\n          var items = void 0;\n          if (coordinate.isTransposed) {\n            items = dim === 'x' ? getCircleGridItems(coordinate, _this.view.getYScales()[0], scale, alignTick, dim) : getLineGridItems(coordinate, scale, dim, alignTick);\n          } else {\n            items = dim === 'x' ? getLineGridItems(coordinate, scale, dim, alignTick) : getCircleGridItems(coordinate, _this.view.getXScale(), scale, alignTick, dim);\n          }\n          updated = {\n            items: items,\n            // coordinate 更新之后，center 也变化了\n            center: _this.view.getCoordinate().getCenter()\n          };\n        } else {\n          updated = {\n            items: getLineGridItems(coordinate, scale, dim, alignTick)\n          };\n        }\n      }\n      component.update(updated);\n    });\n  };\n  /**\n   * 更新 axis 组件\n   */\n  Axis.prototype.update = function () {\n    this.option = this.view.getOptions().axes;\n    var updatedCache = new Map();\n    this.updateXAxes(updatedCache);\n    this.updateYAxes(updatedCache);\n    // 处理完成之后，销毁删除的\n    // 不在处理中的\n    var newCache = new Map();\n    this.cache.forEach(function (co, key) {\n      if (updatedCache.has(key)) {\n        newCache.set(key, co);\n      } else {\n        // 不存在，则是所有需要被销毁的组件\n        co.component.destroy();\n      }\n    });\n    // 更新缓存\n    this.cache = newCache;\n  };\n  Axis.prototype.clear = function () {\n    _super.prototype.clear.call(this);\n    this.cache.clear();\n    this.gridContainer.clear();\n    this.gridForeContainer.clear();\n    this.axisContainer.clear();\n    this.axisForeContainer.clear();\n  };\n  Axis.prototype.destroy = function () {\n    _super.prototype.destroy.call(this);\n    this.gridContainer.remove(true);\n    this.gridForeContainer.remove(true);\n    this.axisContainer.remove(true);\n    this.axisForeContainer.remove(true);\n  };\n  /**\n   * @override\n   */\n  Axis.prototype.getComponents = function () {\n    var co = [];\n    this.cache.forEach(function (value) {\n      co.push(value);\n    });\n    return co;\n  };\n  /**\n   * 更新 x axis\n   * @param updatedCache\n   */\n  Axis.prototype.updateXAxes = function (updatedCache) {\n    // x axis\n    var scale = this.view.getXScale();\n    if (!scale || scale.isIdentity) {\n      return;\n    }\n    var xAxisOption = getAxisOption(this.option, scale.field);\n    if (xAxisOption === false) {\n      return;\n    }\n    var direction = getAxisDirection(xAxisOption, DIRECTION.BOTTOM);\n    var layer = LAYER.BG;\n    var dim = 'x';\n    var coordinate = this.view.getCoordinate();\n    var axisId = this.getId('axis', scale.field);\n    var gridId = this.getId('grid', scale.field);\n    if (coordinate.isRect) {\n      // 1. do axis update\n      var axis = this.cache.get(axisId);\n      // 存在则更新\n      if (axis) {\n        var cfg = this.getLineAxisCfg(scale, xAxisOption, direction);\n        omit(cfg, OMIT_CFG);\n        axis.component.update(cfg);\n        updatedCache.set(axisId, axis);\n      } else {\n        // 不存在，则创建\n        axis = this.createLineAxis(scale, xAxisOption, layer, direction, dim);\n        this.cache.set(axisId, axis);\n        updatedCache.set(axisId, axis);\n      }\n      // 2. do grid update\n      var grid = this.cache.get(gridId);\n      // 存在则更新\n      if (grid) {\n        var cfg = this.getLineGridCfg(scale, xAxisOption, direction, dim);\n        omit(cfg, OMIT_CFG);\n        grid.component.update(cfg);\n        updatedCache.set(gridId, grid);\n      } else {\n        // 不存在则创建\n        grid = this.createLineGrid(scale, xAxisOption, layer, direction, dim);\n        if (grid) {\n          this.cache.set(gridId, grid);\n          updatedCache.set(gridId, grid);\n        }\n      }\n    } else if (coordinate.isPolar) {\n      // 1. do axis update\n      var axis = this.cache.get(axisId);\n      // 存在则更新\n      if (axis) {\n        var cfg = coordinate.isTransposed ? this.getLineAxisCfg(scale, xAxisOption, DIRECTION.RADIUS) : this.getCircleAxisCfg(scale, xAxisOption, direction);\n        omit(cfg, OMIT_CFG);\n        axis.component.update(cfg);\n        updatedCache.set(axisId, axis);\n      } else {\n        // 不存在，则创建\n        if (coordinate.isTransposed) {\n          if (isUndefined(xAxisOption)) {\n            // 默认不渲染转置极坐标下的坐标轴\n            return;\n          } else {\n            // 如果用户打开了隐藏的坐标轴 chart.axis(true)/chart.axis('x', true)\n            // 那么对于转置了的极坐标，半径轴显示的是 x 轴对应的数据\n            axis = this.createLineAxis(scale, xAxisOption, layer, DIRECTION.RADIUS, dim);\n          }\n        } else {\n          axis = this.createCircleAxis(scale, xAxisOption, layer, direction, dim);\n        }\n        this.cache.set(axisId, axis);\n        updatedCache.set(axisId, axis);\n      }\n      // 2. do grid update\n      var grid = this.cache.get(gridId);\n      // 存在则更新\n      if (grid) {\n        var cfg = coordinate.isTransposed ? this.getCircleGridCfg(scale, xAxisOption, DIRECTION.RADIUS, dim) : this.getLineGridCfg(scale, xAxisOption, DIRECTION.CIRCLE, dim);\n        omit(cfg, OMIT_CFG);\n        grid.component.update(cfg);\n        updatedCache.set(gridId, grid);\n      } else {\n        // 不存在则创建\n        if (coordinate.isTransposed) {\n          if (isUndefined(xAxisOption)) {\n            return;\n          } else {\n            grid = this.createCircleGrid(scale, xAxisOption, layer, DIRECTION.RADIUS, dim);\n          }\n        } else {\n          // grid，极坐标下的 x 轴网格线沿着半径方向绘制\n          grid = this.createLineGrid(scale, xAxisOption, layer, DIRECTION.CIRCLE, dim);\n        }\n        if (grid) {\n          this.cache.set(gridId, grid);\n          updatedCache.set(gridId, grid);\n        }\n      }\n    } else {\n      // helix and other, do not draw axis\n    }\n  };\n  Axis.prototype.updateYAxes = function (updatedCache) {\n    var _this = this;\n    // y axes\n    var yScales = this.view.getYScales();\n    each(yScales, function (scale, idx) {\n      // @ts-ignore\n      if (!scale || scale.isIdentity) {\n        return;\n      }\n      var field = scale.field;\n      var yAxisOption = getAxisOption(_this.option, field);\n      if (yAxisOption !== false) {\n        var layer = LAYER.BG;\n        var dim = 'y';\n        var axisId = _this.getId('axis', field);\n        var gridId = _this.getId('grid', field);\n        var coordinate = _this.view.getCoordinate();\n        if (coordinate.isRect) {\n          var direction = getAxisDirection(yAxisOption, idx === 0 ? DIRECTION.LEFT : DIRECTION.RIGHT);\n          // 1. do axis update\n          var axis = _this.cache.get(axisId);\n          // 存在则更新\n          if (axis) {\n            var cfg = _this.getLineAxisCfg(scale, yAxisOption, direction);\n            omit(cfg, OMIT_CFG);\n            axis.component.update(cfg);\n            updatedCache.set(axisId, axis);\n          } else {\n            // 不存在，则创建\n            axis = _this.createLineAxis(scale, yAxisOption, layer, direction, dim);\n            _this.cache.set(axisId, axis);\n            updatedCache.set(axisId, axis);\n          }\n          // 2. do grid update\n          var grid = _this.cache.get(gridId);\n          // 存在则更新\n          if (grid) {\n            var cfg = _this.getLineGridCfg(scale, yAxisOption, direction, dim);\n            omit(cfg, OMIT_CFG);\n            grid.component.update(cfg);\n            updatedCache.set(gridId, grid);\n          } else {\n            // 不存在则创建\n            grid = _this.createLineGrid(scale, yAxisOption, layer, direction, dim);\n            if (grid) {\n              _this.cache.set(gridId, grid);\n              updatedCache.set(gridId, grid);\n            }\n          }\n        } else if (coordinate.isPolar) {\n          // 1. do axis update\n          var axis = _this.cache.get(axisId);\n          // 存在则更新\n          if (axis) {\n            var cfg = coordinate.isTransposed ? _this.getCircleAxisCfg(scale, yAxisOption, DIRECTION.CIRCLE) : _this.getLineAxisCfg(scale, yAxisOption, DIRECTION.RADIUS);\n            // @ts-ignore\n            omit(cfg, OMIT_CFG);\n            axis.component.update(cfg);\n            updatedCache.set(axisId, axis);\n          } else {\n            // 不存在，则创建\n            if (coordinate.isTransposed) {\n              if (isUndefined(yAxisOption)) {\n                return;\n              } else {\n                axis = _this.createCircleAxis(scale, yAxisOption, layer, DIRECTION.CIRCLE, dim);\n              }\n            } else {\n              axis = _this.createLineAxis(scale, yAxisOption, layer, DIRECTION.RADIUS, dim);\n            }\n            _this.cache.set(axisId, axis);\n            updatedCache.set(axisId, axis);\n          }\n          // 2. do grid update\n          var grid = _this.cache.get(gridId);\n          // 存在则更新\n          if (grid) {\n            var cfg = coordinate.isTransposed ? _this.getLineGridCfg(scale, yAxisOption, DIRECTION.CIRCLE, dim) : _this.getCircleGridCfg(scale, yAxisOption, DIRECTION.RADIUS, dim);\n            omit(cfg, OMIT_CFG);\n            grid.component.update(cfg);\n            updatedCache.set(gridId, grid);\n          } else {\n            // 不存在则创建\n            if (coordinate.isTransposed) {\n              if (isUndefined(yAxisOption)) {\n                return;\n              } else {\n                grid = _this.createLineGrid(scale, yAxisOption, layer, DIRECTION.CIRCLE, dim);\n              }\n            } else {\n              grid = _this.createCircleGrid(scale, yAxisOption, layer, DIRECTION.RADIUS, dim);\n            }\n            if (grid) {\n              _this.cache.set(gridId, grid);\n              updatedCache.set(gridId, grid);\n            }\n          }\n        } else {\n          // helix and other, do not draw axis\n        }\n      }\n    });\n  };\n  /**\n   * 创建 line axis\n   * @param scale\n   * @param option\n   * @param layer\n   * @param direction\n   * @param dim\n   */\n  Axis.prototype.createLineAxis = function (scale, option, layer, direction, dim) {\n    // axis\n    var axis = {\n      component: new LineAxis(this.getLineAxisCfg(scale, option, direction)),\n      layer: layer,\n      direction: direction === DIRECTION.RADIUS ? DIRECTION.NONE : direction,\n      type: COMPONENT_TYPE.AXIS,\n      extra: {\n        dim: dim,\n        scale: scale\n      }\n    };\n    axis.component.set('field', scale.field);\n    axis.component.init();\n    return axis;\n  };\n  Axis.prototype.createLineGrid = function (scale, option, layer, direction, dim) {\n    var cfg = this.getLineGridCfg(scale, option, direction, dim);\n    if (cfg) {\n      var grid = {\n        component: new LineGrid(cfg),\n        layer: layer,\n        direction: DIRECTION.NONE,\n        type: COMPONENT_TYPE.GRID,\n        extra: {\n          dim: dim,\n          scale: scale,\n          alignTick: get(cfg, 'alignTick', true)\n        }\n      };\n      grid.component.init();\n      return grid;\n    }\n  };\n  Axis.prototype.createCircleAxis = function (scale, option, layer, direction, dim) {\n    var axis = {\n      component: new CircleAxis(this.getCircleAxisCfg(scale, option, direction)),\n      layer: layer,\n      direction: direction,\n      type: COMPONENT_TYPE.AXIS,\n      extra: {\n        dim: dim,\n        scale: scale\n      }\n    };\n    axis.component.set('field', scale.field);\n    axis.component.init();\n    return axis;\n  };\n  Axis.prototype.createCircleGrid = function (scale, option, layer, direction, dim) {\n    var cfg = this.getCircleGridCfg(scale, option, direction, dim);\n    if (cfg) {\n      var grid = {\n        component: new CircleGrid(cfg),\n        layer: layer,\n        direction: DIRECTION.NONE,\n        type: COMPONENT_TYPE.GRID,\n        extra: {\n          dim: dim,\n          scale: scale,\n          alignTick: get(cfg, 'alignTick', true)\n        }\n      };\n      grid.component.init();\n      return grid;\n    }\n  };\n  /**\n   * generate line axis cfg\n   * @param scale\n   * @param axisOption\n   * @param direction\n   * @return line axis cfg\n   */\n  Axis.prototype.getLineAxisCfg = function (scale, axisOption, direction) {\n    var container = get(axisOption, ['top']) ? this.axisForeContainer : this.axisContainer;\n    var coordinate = this.view.getCoordinate();\n    var region = getAxisRegion(coordinate, direction);\n    var titleText = getAxisTitleText(scale, axisOption);\n    var axisThemeCfg = getAxisThemeCfg(this.view.getTheme(), direction);\n    // the cfg order should be ensure\n    var optionWithTitle = get(axisOption, ['title']) ? deepMix({\n      title: {\n        style: {\n          text: titleText\n        }\n      }\n    }, {\n      title: getAxisTitleOptions(this.view.getTheme(), direction, axisOption.title)\n    }, axisOption) : axisOption;\n    var cfg = deepMix(__assign(__assign({\n      container: container\n    }, region), {\n      ticks: scale.getTicks().map(function (tick) {\n        return {\n          id: \"\".concat(tick.tickValue),\n          name: tick.text,\n          value: tick.value\n        };\n      }),\n      verticalFactor: coordinate.isPolar ? getAxisFactorByRegion(region, coordinate.getCenter()) * -1 : getAxisFactorByRegion(region, coordinate.getCenter()),\n      theme: axisThemeCfg\n    }), axisThemeCfg, optionWithTitle);\n    var _a = this.getAnimateCfg(cfg),\n      animate = _a.animate,\n      animateOption = _a.animateOption;\n    cfg.animateOption = animateOption;\n    cfg.animate = animate;\n    // 计算 verticalLimitLength\n    var isAxisVertical = isVertical(region);\n    // TODO: 1 / 3 等默认值需要有一个全局的配置的地方\n    var verticalLimitLength = get(cfg, 'verticalLimitLength', isAxisVertical ? 1 / 3 : 1 / 2);\n    if (verticalLimitLength <= 1) {\n      // 配置的相对值，相对于画布\n      var canvasWidth = this.view.getCanvas().get('width');\n      var canvasHeight = this.view.getCanvas().get('height');\n      cfg.verticalLimitLength = verticalLimitLength * (isAxisVertical ? canvasWidth : canvasHeight);\n    }\n    return cfg;\n  };\n  /**\n   * generate line grid cfg\n   * @param scale\n   * @param axisOption\n   * @param direction\n   * @param dim\n   * @return line grid cfg\n   */\n  Axis.prototype.getLineGridCfg = function (scale, axisOption, direction, dim) {\n    if (!showGrid(getAxisThemeCfg(this.view.getTheme(), direction), axisOption)) {\n      return undefined;\n    }\n    var gridThemeCfg = getGridThemeCfg(this.view.getTheme(), direction);\n    // the cfg order should be ensure\n    // grid 动画以 axis 为准\n    var gridCfg = deepMix({\n      container: get(axisOption, ['top']) ? this.gridForeContainer : this.gridContainer\n    }, gridThemeCfg, get(axisOption, 'grid'), this.getAnimateCfg(axisOption));\n    gridCfg.items = getLineGridItems(this.view.getCoordinate(), scale, dim, get(gridCfg, 'alignTick', true));\n    return gridCfg;\n  };\n  /**\n   * generate circle axis cfg\n   * @param scale\n   * @param axisOption\n   * @param direction\n   * @return circle axis cfg\n   */\n  Axis.prototype.getCircleAxisCfg = function (scale, axisOption, direction) {\n    var container = get(axisOption, ['top']) ? this.axisForeContainer : this.axisContainer;\n    var coordinate = this.view.getCoordinate();\n    var ticks = scale.getTicks().map(function (tick) {\n      return {\n        id: \"\".concat(tick.tickValue),\n        name: tick.text,\n        value: tick.value\n      };\n    });\n    if (!scale.isCategory && Math.abs(coordinate.endAngle - coordinate.startAngle) === Math.PI * 2) {\n      // x 轴对应的值如果是非 cat 类型，在整圆的情况下坐标轴第一个和最后一个文本会重叠，默认只展示第一个文本\n      ticks.pop();\n    }\n    var titleText = getAxisTitleText(scale, axisOption);\n    var axisThemeCfg = getAxisThemeCfg(this.view.getTheme(), DIRECTION.CIRCLE);\n    // the cfg order should be ensure\n    var optionWithTitle = get(axisOption, ['title']) ? deepMix({\n      title: {\n        style: {\n          text: titleText\n        }\n      }\n    }, {\n      title: getAxisTitleOptions(this.view.getTheme(), direction, axisOption.title)\n    }, axisOption) : axisOption;\n    var cfg = deepMix(__assign(__assign({\n      container: container\n    }, getCircleAxisCenterRadius(this.view.getCoordinate())), {\n      ticks: ticks,\n      verticalFactor: 1,\n      theme: axisThemeCfg\n    }), axisThemeCfg, optionWithTitle);\n    var _a = this.getAnimateCfg(cfg),\n      animate = _a.animate,\n      animateOption = _a.animateOption;\n    cfg.animate = animate;\n    cfg.animateOption = animateOption;\n    return cfg;\n  };\n  /**\n   * generate circle grid cfg\n   * @param scale\n   * @param axisOption\n   * @param direction\n   * @return circle grid cfg\n   */\n  Axis.prototype.getCircleGridCfg = function (scale, axisOption, direction, dim) {\n    if (!showGrid(getAxisThemeCfg(this.view.getTheme(), direction), axisOption)) {\n      return undefined;\n    }\n    // the cfg order should be ensure\n    // grid 动画以 axis 为准\n    var gridThemeCfg = getGridThemeCfg(this.view.getTheme(), DIRECTION.RADIUS);\n    var gridCfg = deepMix({\n      container: get(axisOption, ['top']) ? this.gridForeContainer : this.gridContainer,\n      center: this.view.getCoordinate().getCenter()\n    }, gridThemeCfg, get(axisOption, 'grid'), this.getAnimateCfg(axisOption));\n    var alignTick = get(gridCfg, 'alignTick', true);\n    var verticalScale = dim === 'x' ? this.view.getYScales()[0] : this.view.getXScale();\n    gridCfg.items = getCircleGridItems(this.view.getCoordinate(), verticalScale, scale, alignTick, dim);\n    // the cfg order should be ensure\n    // grid 动画以 axis 为准\n    return gridCfg;\n  };\n  Axis.prototype.getId = function (name, key) {\n    var coordinate = this.view.getCoordinate();\n    // 坐标系类型也作为组件的 key\n    return \"\".concat(name, \"-\").concat(key, \"-\").concat(coordinate.type);\n  };\n  Axis.prototype.getAnimateCfg = function (cfg) {\n    return {\n      animate: this.view.getOptions().animate && get(cfg, 'animate'),\n      animateOption: cfg && cfg.animateOption ? deepMix({}, AXIS_DEFAULT_ANIMATE_CFG, cfg.animateOption) : AXIS_DEFAULT_ANIMATE_CFG\n    };\n  };\n  return Axis;\n}(Controller);\nexport default Axis;","map":{"version":3,"sources":["../../../src/chart/controller/axis.ts"],"names":[],"mappings":"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","sourcesContent":["import { deepMix, each, get, isUndefined } from '@antv/util';\nimport { DIRECTION, COMPONENT_TYPE, LAYER } from '../../constant';\nimport { CircleAxis, CircleGrid, IGroup, LineAxis, LineGrid, Scale } from '../../dependents';\nimport { AxisCfg, AxisOption, ComponentOption } from '../../interface';\n\nimport { DEFAULT_ANIMATE_CFG } from '../../animate/';\n\nimport {\n  getAxisDirection,\n  getAxisFactorByRegion,\n  getAxisRegion,\n  getAxisThemeCfg,\n  getAxisTitleOptions,\n  getAxisTitleText,\n  getCircleAxisCenterRadius,\n  isVertical,\n} from '../../util/axis';\nimport { getAxisOption } from '../../util/axis';\nimport { getCircleGridItems, getGridThemeCfg, getLineGridItems, showGrid } from '../../util/grid';\nimport { omit } from '../../util/helper';\nimport View from '../view';\nimport { Controller } from './base';\n\ntype Option = Record<string, AxisOption> | boolean;\n\ntype Cache = Map<string, ComponentOption>;\n\n// update 组件的时候，忽略的数据更新\nconst OMIT_CFG = ['container'];\n\n// 坐标轴默认动画配置\nconst AXIS_DEFAULT_ANIMATE_CFG = {\n  ...DEFAULT_ANIMATE_CFG,\n  appear: null,\n};\n\n/**\n * @ignore\n * G2 Axis controller, will:\n *  - create component\n *    - axis\n *    - grid\n *  - life circle\n */\nexport default class Axis extends Controller<Option> {\n  /** the draw group of axis */\n  private axisContainer: IGroup;\n  private axisForeContainer: IGroup;\n  private gridContainer: IGroup;\n  private gridForeContainer: IGroup;\n\n  /** 使用 object 存储组件 */\n  private cache: Cache = new Map<string, ComponentOption>();\n\n  constructor(view: View) {\n    super(view);\n\n    // 先创建 gridContainer，将 grid 放到 axis 底层\n    this.gridContainer = this.view.getLayer(LAYER.BG).addGroup();\n    this.gridForeContainer = this.view.getLayer(LAYER.FORE).addGroup();\n    this.axisContainer = this.view.getLayer(LAYER.BG).addGroup();\n    this.axisForeContainer = this.view.getLayer(LAYER.FORE).addGroup();\n  }\n\n  public get name(): string {\n    return 'axis';\n  }\n\n  public init() {}\n\n  public render() {\n    this.update();\n  }\n\n  /**\n   * 更新组件布局，位置大小\n   */\n  public layout() {\n    const coordinate = this.view.getCoordinate();\n\n    each(this.getComponents(), (co: ComponentOption) => {\n      const { component, direction, type, extra } = co;\n      const { dim, scale, alignTick } = extra;\n\n      let updated;\n\n      if (type === COMPONENT_TYPE.AXIS) {\n        if (coordinate.isPolar) {\n          if (dim === 'x') {\n            updated = coordinate.isTransposed\n              ? getAxisRegion(coordinate, direction)\n              : getCircleAxisCenterRadius(coordinate);\n          } else if (dim === 'y') {\n            updated = coordinate.isTransposed\n              ? getCircleAxisCenterRadius(coordinate)\n              : getAxisRegion(coordinate, direction);\n          }\n        } else {\n          updated = getAxisRegion(coordinate, direction);\n        }\n      } else if (type === COMPONENT_TYPE.GRID) {\n        if (coordinate.isPolar) {\n          let items;\n          if (coordinate.isTransposed) {\n            items =\n              dim === 'x'\n                ? getCircleGridItems(coordinate, this.view.getYScales()[0], scale, alignTick, dim)\n                : getLineGridItems(coordinate, scale, dim, alignTick);\n          } else {\n            items =\n              dim === 'x'\n                ? getLineGridItems(coordinate, scale, dim, alignTick)\n                : getCircleGridItems(coordinate, this.view.getXScale(), scale, alignTick, dim);\n          }\n          updated = {\n            items,\n            // coordinate 更新之后，center 也变化了\n            center: this.view.getCoordinate().getCenter(),\n          };\n        } else {\n          updated = { items: getLineGridItems(coordinate, scale, dim, alignTick) };\n        }\n      }\n      component.update(updated);\n    });\n  }\n\n  /**\n   * 更新 axis 组件\n   */\n  public update() {\n    this.option = this.view.getOptions().axes;\n\n    const updatedCache = new Map<string, ComponentOption>();\n\n    this.updateXAxes(updatedCache);\n    this.updateYAxes(updatedCache);\n\n    // 处理完成之后，销毁删除的\n    // 不在处理中的\n    const newCache = new Map<string, ComponentOption>();\n\n    this.cache.forEach((co: ComponentOption, key: string) => {\n      if (updatedCache.has(key)) {\n        newCache.set(key, co);\n      } else {\n        // 不存在，则是所有需要被销毁的组件\n        co.component.destroy();\n      }\n    });\n\n    // 更新缓存\n    this.cache = newCache;\n  }\n\n  public clear() {\n    super.clear();\n\n    this.cache.clear();\n    this.gridContainer.clear();\n    this.gridForeContainer.clear();\n    this.axisContainer.clear();\n    this.axisForeContainer.clear();\n  }\n\n  public destroy() {\n    super.destroy();\n\n    this.gridContainer.remove(true);\n    this.gridForeContainer.remove(true);\n    this.axisContainer.remove(true);\n    this.axisForeContainer.remove(true);\n  }\n\n  /**\n   * @override\n   */\n  public getComponents(): ComponentOption[] {\n    const co = [];\n\n    this.cache.forEach((value: ComponentOption) => {\n      co.push(value);\n    });\n\n    return co;\n  }\n\n  /**\n   * 更新 x axis\n   * @param updatedCache\n   */\n  private updateXAxes(updatedCache: Cache) {\n    // x axis\n    const scale = this.view.getXScale();\n\n    if (!scale || scale.isIdentity) {\n      return;\n    }\n\n    const xAxisOption = getAxisOption(this.option, scale.field);\n    if (xAxisOption === false) {\n      return;\n    }\n\n    const direction = getAxisDirection(xAxisOption, DIRECTION.BOTTOM);\n    const layer = LAYER.BG;\n    const dim = 'x';\n\n    const coordinate = this.view.getCoordinate();\n\n    const axisId = this.getId('axis', scale.field);\n    const gridId = this.getId('grid', scale.field);\n\n    if (coordinate.isRect) {\n      // 1. do axis update\n      let axis = this.cache.get(axisId);\n      // 存在则更新\n      if (axis) {\n        const cfg = this.getLineAxisCfg(scale, xAxisOption, direction);\n        omit(cfg, OMIT_CFG);\n        axis.component.update(cfg);\n        updatedCache.set(axisId, axis);\n      } else {\n        // 不存在，则创建\n        axis = this.createLineAxis(scale, xAxisOption, layer, direction, dim);\n        this.cache.set(axisId, axis);\n        updatedCache.set(axisId, axis);\n      }\n\n      // 2. do grid update\n      let grid = this.cache.get(gridId);\n      // 存在则更新\n      if (grid) {\n        const cfg = this.getLineGridCfg(scale, xAxisOption, direction, dim);\n        omit(cfg, OMIT_CFG);\n        grid.component.update(cfg);\n        updatedCache.set(gridId, grid);\n      } else {\n        // 不存在则创建\n        grid = this.createLineGrid(scale, xAxisOption, layer, direction, dim);\n        if (grid) {\n          this.cache.set(gridId, grid);\n          updatedCache.set(gridId, grid);\n        }\n      }\n    } else if (coordinate.isPolar) {\n      // 1. do axis update\n      let axis = this.cache.get(axisId);\n      // 存在则更新\n      if (axis) {\n        const cfg = coordinate.isTransposed\n          ? this.getLineAxisCfg(scale, xAxisOption, DIRECTION.RADIUS)\n          : this.getCircleAxisCfg(scale, xAxisOption, direction);\n\n        omit(cfg, OMIT_CFG);\n        axis.component.update(cfg);\n        updatedCache.set(axisId, axis);\n      } else {\n        // 不存在，则创建\n        if (coordinate.isTransposed) {\n          if (isUndefined(xAxisOption)) {\n            // 默认不渲染转置极坐标下的坐标轴\n            return;\n          } else {\n            // 如果用户打开了隐藏的坐标轴 chart.axis(true)/chart.axis('x', true)\n            // 那么对于转置了的极坐标，半径轴显示的是 x 轴对应的数据\n            axis = this.createLineAxis(scale, xAxisOption, layer, DIRECTION.RADIUS, dim);\n          }\n        } else {\n          axis = this.createCircleAxis(scale, xAxisOption, layer, direction, dim);\n        }\n        this.cache.set(axisId, axis);\n        updatedCache.set(axisId, axis);\n      }\n\n      // 2. do grid update\n      let grid = this.cache.get(gridId);\n      // 存在则更新\n      if (grid) {\n        const cfg = coordinate.isTransposed\n          ? this.getCircleGridCfg(scale, xAxisOption, DIRECTION.RADIUS, dim)\n          : this.getLineGridCfg(scale, xAxisOption, DIRECTION.CIRCLE, dim);\n        omit(cfg, OMIT_CFG);\n        grid.component.update(cfg);\n        updatedCache.set(gridId, grid);\n      } else {\n        // 不存在则创建\n        if (coordinate.isTransposed) {\n          if (isUndefined(xAxisOption)) {\n            return;\n          } else {\n            grid = this.createCircleGrid(scale, xAxisOption, layer, DIRECTION.RADIUS, dim);\n          }\n        } else {\n          // grid，极坐标下的 x 轴网格线沿着半径方向绘制\n          grid = this.createLineGrid(scale, xAxisOption, layer, DIRECTION.CIRCLE, dim);\n        }\n\n        if (grid) {\n          this.cache.set(gridId, grid);\n          updatedCache.set(gridId, grid);\n        }\n      }\n    } else {\n      // helix and other, do not draw axis\n    }\n  }\n\n  private updateYAxes(updatedCache: Cache) {\n    // y axes\n    const yScales = this.view.getYScales();\n\n    each(yScales, (scale: Scale, idx: number) => {\n      // @ts-ignore\n      if (!scale || scale.isIdentity) {\n        return;\n      }\n      const { field } = scale;\n      const yAxisOption = getAxisOption(this.option, field);\n\n      if (yAxisOption !== false) {\n        const layer = LAYER.BG;\n        const dim = 'y';\n        const axisId = this.getId('axis', field);\n        const gridId = this.getId('grid', field);\n\n        const coordinate = this.view.getCoordinate();\n\n        if (coordinate.isRect) {\n          const direction = getAxisDirection(yAxisOption, idx === 0 ? DIRECTION.LEFT : DIRECTION.RIGHT);\n\n          // 1. do axis update\n          let axis = this.cache.get(axisId);\n          // 存在则更新\n          if (axis) {\n            const cfg = this.getLineAxisCfg(scale, yAxisOption, direction);\n            omit(cfg, OMIT_CFG);\n            axis.component.update(cfg);\n            updatedCache.set(axisId, axis);\n          } else {\n            // 不存在，则创建\n            axis = this.createLineAxis(scale, yAxisOption, layer, direction, dim);\n            this.cache.set(axisId, axis);\n            updatedCache.set(axisId, axis);\n          }\n\n          // 2. do grid update\n          let grid = this.cache.get(gridId);\n          // 存在则更新\n          if (grid) {\n            const cfg = this.getLineGridCfg(scale, yAxisOption, direction, dim);\n            omit(cfg, OMIT_CFG);\n            grid.component.update(cfg);\n            updatedCache.set(gridId, grid);\n          } else {\n            // 不存在则创建\n            grid = this.createLineGrid(scale, yAxisOption, layer, direction, dim);\n            if (grid) {\n              this.cache.set(gridId, grid);\n              updatedCache.set(gridId, grid);\n            }\n          }\n        } else if (coordinate.isPolar) {\n          // 1. do axis update\n          let axis = this.cache.get(axisId);\n          // 存在则更新\n          if (axis) {\n            const cfg = coordinate.isTransposed\n              ? this.getCircleAxisCfg(scale, yAxisOption, DIRECTION.CIRCLE)\n              : this.getLineAxisCfg(scale, yAxisOption, DIRECTION.RADIUS);\n\n            // @ts-ignore\n            omit(cfg, OMIT_CFG);\n            axis.component.update(cfg);\n            updatedCache.set(axisId, axis);\n          } else {\n            // 不存在，则创建\n            if (coordinate.isTransposed) {\n              if (isUndefined(yAxisOption)) {\n                return;\n              } else {\n                axis = this.createCircleAxis(scale, yAxisOption, layer, DIRECTION.CIRCLE, dim);\n              }\n            } else {\n              axis = this.createLineAxis(scale, yAxisOption, layer, DIRECTION.RADIUS, dim);\n            }\n\n            this.cache.set(axisId, axis);\n            updatedCache.set(axisId, axis);\n          }\n\n          // 2. do grid update\n          let grid = this.cache.get(gridId);\n          // 存在则更新\n          if (grid) {\n            const cfg = coordinate.isTransposed\n              ? this.getLineGridCfg(scale, yAxisOption, DIRECTION.CIRCLE, dim)\n              : this.getCircleGridCfg(scale, yAxisOption, DIRECTION.RADIUS, dim);\n            omit(cfg, OMIT_CFG);\n            grid.component.update(cfg);\n            updatedCache.set(gridId, grid);\n          } else {\n            // 不存在则创建\n            if (coordinate.isTransposed) {\n              if (isUndefined(yAxisOption)) {\n                return;\n              } else {\n                grid = this.createLineGrid(scale, yAxisOption, layer, DIRECTION.CIRCLE, dim);\n              }\n            } else {\n              grid = this.createCircleGrid(scale, yAxisOption, layer, DIRECTION.RADIUS, dim);\n            }\n\n            if (grid) {\n              this.cache.set(gridId, grid);\n              updatedCache.set(gridId, grid);\n            }\n          }\n        } else {\n          // helix and other, do not draw axis\n        }\n      }\n    });\n  }\n\n  /**\n   * 创建 line axis\n   * @param scale\n   * @param option\n   * @param layer\n   * @param direction\n   * @param dim\n   */\n  private createLineAxis(\n    scale: Scale,\n    option: AxisCfg,\n    layer: LAYER,\n    direction: DIRECTION,\n    dim: string\n  ): ComponentOption {\n    // axis\n    const axis = {\n      component: new LineAxis(this.getLineAxisCfg(scale, option, direction)),\n      layer,\n      direction: direction === DIRECTION.RADIUS ? DIRECTION.NONE : direction,\n      type: COMPONENT_TYPE.AXIS,\n      extra: { dim, scale },\n    };\n    axis.component.set('field', scale.field);\n    axis.component.init();\n\n    return axis;\n  }\n\n  private createLineGrid(\n    scale: Scale,\n    option: AxisCfg,\n    layer: LAYER,\n    direction: DIRECTION,\n    dim: string\n  ): ComponentOption {\n    const cfg = this.getLineGridCfg(scale, option, direction, dim);\n    if (cfg) {\n      const grid = {\n        component: new LineGrid(cfg),\n        layer,\n        direction: DIRECTION.NONE,\n        type: COMPONENT_TYPE.GRID,\n        extra: {\n          dim,\n          scale,\n          alignTick: get(cfg, 'alignTick', true),\n        },\n      };\n      grid.component.init();\n\n      return grid;\n    }\n  }\n\n  private createCircleAxis(\n    scale: Scale,\n    option: AxisCfg,\n    layer: LAYER,\n    direction: DIRECTION,\n    dim: string\n  ): ComponentOption {\n    const axis = {\n      component: new CircleAxis(this.getCircleAxisCfg(scale, option, direction)),\n      layer,\n      direction,\n      type: COMPONENT_TYPE.AXIS,\n      extra: { dim, scale },\n    };\n    axis.component.set('field', scale.field);\n\n    axis.component.init();\n\n    return axis;\n  }\n\n  private createCircleGrid(\n    scale: Scale,\n    option: AxisCfg,\n    layer: LAYER,\n    direction: DIRECTION,\n    dim: string\n  ): ComponentOption {\n    const cfg = this.getCircleGridCfg(scale, option, direction, dim);\n    if (cfg) {\n      const grid = {\n        component: new CircleGrid(cfg),\n        layer,\n        direction: DIRECTION.NONE,\n        type: COMPONENT_TYPE.GRID,\n        extra: {\n          dim,\n          scale,\n          alignTick: get(cfg, 'alignTick', true),\n        },\n      };\n\n      grid.component.init();\n      return grid;\n    }\n  }\n\n  /**\n   * generate line axis cfg\n   * @param scale\n   * @param axisOption\n   * @param direction\n   * @return line axis cfg\n   */\n  private getLineAxisCfg(scale: Scale, axisOption: AxisCfg, direction: DIRECTION) {\n    const container = get(axisOption, ['top']) ? this.axisForeContainer : this.axisContainer;\n    const coordinate = this.view.getCoordinate();\n    const region = getAxisRegion(coordinate, direction);\n    const titleText = getAxisTitleText(scale, axisOption);\n    const axisThemeCfg = getAxisThemeCfg(this.view.getTheme(), direction);\n    // the cfg order should be ensure\n    const optionWithTitle = get(axisOption, ['title'])\n      ? deepMix(\n          { title: { style: { text: titleText } } },\n          { title: getAxisTitleOptions(this.view.getTheme(), direction, axisOption.title) },\n          axisOption\n        )\n      : axisOption;\n\n    const cfg = deepMix(\n      {\n        container,\n        ...region,\n        ticks: scale.getTicks().map((tick) => ({ id: `${tick.tickValue}`, name: tick.text, value: tick.value })),\n        verticalFactor: coordinate.isPolar\n          ? getAxisFactorByRegion(region, coordinate.getCenter()) * -1\n          : getAxisFactorByRegion(region, coordinate.getCenter()),\n        theme: axisThemeCfg,\n      },\n      axisThemeCfg,\n      optionWithTitle\n    );\n    const { animate, animateOption } = this.getAnimateCfg(cfg);\n    cfg.animateOption = animateOption;\n    cfg.animate = animate;\n\n    // 计算 verticalLimitLength\n    const isAxisVertical = isVertical(region);\n    // TODO: 1 / 3 等默认值需要有一个全局的配置的地方\n    const verticalLimitLength = get(cfg, 'verticalLimitLength', isAxisVertical ? 1 / 3 : 1 / 2);\n    if (verticalLimitLength <= 1) {\n      // 配置的相对值，相对于画布\n      const canvasWidth = this.view.getCanvas().get('width');\n      const canvasHeight = this.view.getCanvas().get('height');\n      cfg.verticalLimitLength = verticalLimitLength * (isAxisVertical ? canvasWidth : canvasHeight);\n    }\n\n    return cfg;\n  }\n\n  /**\n   * generate line grid cfg\n   * @param scale\n   * @param axisOption\n   * @param direction\n   * @param dim\n   * @return line grid cfg\n   */\n  private getLineGridCfg(scale: Scale, axisOption: AxisCfg, direction: DIRECTION, dim: string) {\n    if (!showGrid(getAxisThemeCfg(this.view.getTheme(), direction), axisOption)) {\n      return undefined;\n    }\n    const gridThemeCfg = getGridThemeCfg(this.view.getTheme(), direction);\n    // the cfg order should be ensure\n    // grid 动画以 axis 为准\n    const gridCfg = deepMix(\n      {\n        container: get(axisOption, ['top']) ? this.gridForeContainer : this.gridContainer,\n      },\n      gridThemeCfg,\n      get(axisOption, 'grid'),\n      this.getAnimateCfg(axisOption)\n    );\n    gridCfg.items = getLineGridItems(this.view.getCoordinate(), scale, dim, get(gridCfg, 'alignTick', true));\n\n    return gridCfg;\n  }\n\n  /**\n   * generate circle axis cfg\n   * @param scale\n   * @param axisOption\n   * @param direction\n   * @return circle axis cfg\n   */\n  private getCircleAxisCfg(scale: Scale, axisOption: AxisCfg, direction: DIRECTION) {\n    const container = get(axisOption, ['top']) ? this.axisForeContainer : this.axisContainer;\n    const coordinate = this.view.getCoordinate();\n\n    const ticks = scale.getTicks().map((tick) => ({ id: `${tick.tickValue}`, name: tick.text, value: tick.value }));\n    if (!scale.isCategory && Math.abs(coordinate.endAngle - coordinate.startAngle) === Math.PI * 2) {\n      // x 轴对应的值如果是非 cat 类型，在整圆的情况下坐标轴第一个和最后一个文本会重叠，默认只展示第一个文本\n      ticks.pop();\n    }\n\n    const titleText = getAxisTitleText(scale, axisOption);\n    const axisThemeCfg = getAxisThemeCfg(this.view.getTheme(), DIRECTION.CIRCLE);\n    // the cfg order should be ensure\n    const optionWithTitle = get(axisOption, ['title'])\n      ? deepMix(\n          { title: { style: { text: titleText } } },\n          { title: getAxisTitleOptions(this.view.getTheme(), direction, axisOption.title) },\n          axisOption\n        )\n      : axisOption;\n    const cfg = deepMix(\n      {\n        container,\n        ...getCircleAxisCenterRadius(this.view.getCoordinate()),\n        ticks,\n        verticalFactor: 1,\n        theme: axisThemeCfg,\n      },\n      axisThemeCfg,\n      optionWithTitle\n    );\n    const { animate, animateOption } = this.getAnimateCfg(cfg);\n    cfg.animate = animate;\n    cfg.animateOption = animateOption;\n\n    return cfg;\n  }\n\n  /**\n   * generate circle grid cfg\n   * @param scale\n   * @param axisOption\n   * @param direction\n   * @return circle grid cfg\n   */\n  private getCircleGridCfg(scale: Scale, axisOption: AxisCfg, direction: DIRECTION, dim: string) {\n    if (!showGrid(getAxisThemeCfg(this.view.getTheme(), direction), axisOption)) {\n      return undefined;\n    }\n\n    // the cfg order should be ensure\n    // grid 动画以 axis 为准\n    const gridThemeCfg = getGridThemeCfg(this.view.getTheme(), DIRECTION.RADIUS);\n    const gridCfg = deepMix(\n      {\n        container: get(axisOption, ['top']) ? this.gridForeContainer : this.gridContainer,\n        center: this.view.getCoordinate().getCenter(),\n      },\n      gridThemeCfg,\n      get(axisOption, 'grid'),\n      this.getAnimateCfg(axisOption)\n    );\n    const alignTick = get(gridCfg, 'alignTick', true);\n    const verticalScale = dim === 'x' ? this.view.getYScales()[0] : this.view.getXScale();\n    gridCfg.items = getCircleGridItems(this.view.getCoordinate(), verticalScale, scale, alignTick, dim);\n    // the cfg order should be ensure\n    // grid 动画以 axis 为准\n    return gridCfg;\n  }\n\n  private getId(name: string, key: string): string {\n    const coordinate = this.view.getCoordinate();\n    // 坐标系类型也作为组件的 key\n    return `${name}-${key}-${coordinate.type}`;\n  }\n\n  private getAnimateCfg(cfg) {\n    return {\n      animate: this.view.getOptions().animate && get(cfg, 'animate'), // 如果 view 关闭动画，则不执行动画\n      animateOption:\n        cfg && cfg.animateOption ? deepMix({}, AXIS_DEFAULT_ANIMATE_CFG, cfg.animateOption) : AXIS_DEFAULT_ANIMATE_CFG,\n    };\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}