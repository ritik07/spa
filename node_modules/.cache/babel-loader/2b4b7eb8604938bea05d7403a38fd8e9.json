{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { getTextPoint } from '../util/util';\nimport CrosshairBase from './base';\nvar LineCrosshair = /** @class */function (_super) {\n  __extends(LineCrosshair, _super);\n  function LineCrosshair() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  LineCrosshair.prototype.getDefaultCfg = function () {\n    var cfg = _super.prototype.getDefaultCfg.call(this);\n    return __assign(__assign({}, cfg), {\n      type: 'line',\n      locationType: 'region',\n      start: null,\n      end: null\n    });\n  };\n  // 直线的文本需要同直线垂直\n  LineCrosshair.prototype.getRotateAngle = function () {\n    var _a = this.getLocation(),\n      start = _a.start,\n      end = _a.end;\n    var position = this.get('text').position;\n    var angle = Math.atan2(end.y - start.y, end.x - start.x);\n    var tangentAngle = position === 'start' ? angle - Math.PI / 2 : angle + Math.PI / 2;\n    return tangentAngle;\n  };\n  LineCrosshair.prototype.getTextPoint = function () {\n    var _a = this.getLocation(),\n      start = _a.start,\n      end = _a.end;\n    var _b = this.get('text'),\n      position = _b.position,\n      offset = _b.offset;\n    return getTextPoint(start, end, position, offset);\n  };\n  LineCrosshair.prototype.getLinePath = function () {\n    var _a = this.getLocation(),\n      start = _a.start,\n      end = _a.end;\n    return [['M', start.x, start.y], ['L', end.x, end.y]];\n  };\n  return LineCrosshair;\n}(CrosshairBase);\nexport default LineCrosshair;","map":{"version":3,"sources":["../../src/crosshair/line.ts"],"names":[],"mappings":";AAEA,SAAS,YAAY,QAAQ,cAAc;AAC3C,OAAO,aAAa,MAAM,QAAQ;AAElC,IAAA,aAAA,GAAA,aAAA,UAAA,MAAA,EAAA;EAA4B,SAAA,CAAA,aAAA,EAAA,MAAA,CAAA;EAA5B,SAAA,aAAA,GAAA;;EAkCA;EAjCS,aAAA,CAAA,SAAA,CAAA,aAAa,GAApB,YAAA;IACE,IAAM,GAAG,GAAG,MAAA,CAAA,SAAA,CAAM,aAAa,CAAA,IAAA,CAAA,IAAA,CAAE;IACjC,OAAA,QAAA,CAAA,QAAA,CAAA,CAAA,CAAA,EACK,GAAG,CAAA,EAAA;MACN,IAAI,EAAE,MAAM;MACZ,YAAY,EAAE,QAAQ;MACtB,KAAK,EAAE,IAAI;MACX,GAAG,EAAE;IAAI,CAAA,CAAA;EAEb,CAAC;EAED;EACU,aAAA,CAAA,SAAA,CAAA,cAAc,GAAxB,YAAA;IACQ,IAAA,EAAA,GAAiB,IAAI,CAAC,WAAW,EAAE;MAAjC,KAAK,GAAA,EAAA,CAAA,KAAA;MAAE,GAAG,GAAA,EAAA,CAAA,GAAuB;IACjC,IAAA,QAAQ,GAAK,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,CAAA,QAArB;IAChB,IAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC;IAC1D,IAAM,YAAY,GAAG,QAAQ,KAAK,OAAO,GAAG,KAAK,GAAG,IAAI,CAAC,EAAE,GAAG,CAAC,GAAG,KAAK,GAAG,IAAI,CAAC,EAAE,GAAG,CAAC;IACrF,OAAO,YAAY;EACrB,CAAC;EAES,aAAA,CAAA,SAAA,CAAA,YAAY,GAAtB,YAAA;IACQ,IAAA,EAAA,GAAiB,IAAI,CAAC,WAAW,EAAE;MAAjC,KAAK,GAAA,EAAA,CAAA,KAAA;MAAE,GAAG,GAAA,EAAA,CAAA,GAAuB;IACnC,IAAA,EAAA,GAAuB,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC;MAArC,QAAQ,GAAA,EAAA,CAAA,QAAA;MAAE,MAAM,GAAA,EAAA,CAAA,MAAqB;IAC7C,OAAO,YAAY,CAAC,KAAK,EAAE,GAAG,EAAE,QAAQ,EAAE,MAAM,CAAC;EACnD,CAAC;EAES,aAAA,CAAA,SAAA,CAAA,WAAW,GAArB,YAAA;IACQ,IAAA,EAAA,GAAiB,IAAI,CAAC,WAAW,EAAE;MAAjC,KAAK,GAAA,EAAA,CAAA,KAAA;MAAE,GAAG,GAAA,EAAA,CAAA,GAAuB;IACzC,OAAO,CACL,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC,EACvB,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC,CACpB;EACH,CAAC;EACH,OAAA,aAAC;AAAD,CAAC,CAlC2B,aAAa,CAAA;AAoCzC,eAAe,aAAa","sourceRoot":"","sourcesContent":["import { __assign, __extends } from \"tslib\";\nimport { getTextPoint } from '../util/util';\nimport CrosshairBase from './base';\nvar LineCrosshair = /** @class */ (function (_super) {\n    __extends(LineCrosshair, _super);\n    function LineCrosshair() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    LineCrosshair.prototype.getDefaultCfg = function () {\n        var cfg = _super.prototype.getDefaultCfg.call(this);\n        return __assign(__assign({}, cfg), { type: 'line', locationType: 'region', start: null, end: null });\n    };\n    // 直线的文本需要同直线垂直\n    LineCrosshair.prototype.getRotateAngle = function () {\n        var _a = this.getLocation(), start = _a.start, end = _a.end;\n        var position = this.get('text').position;\n        var angle = Math.atan2(end.y - start.y, end.x - start.x);\n        var tangentAngle = position === 'start' ? angle - Math.PI / 2 : angle + Math.PI / 2;\n        return tangentAngle;\n    };\n    LineCrosshair.prototype.getTextPoint = function () {\n        var _a = this.getLocation(), start = _a.start, end = _a.end;\n        var _b = this.get('text'), position = _b.position, offset = _b.offset;\n        return getTextPoint(start, end, position, offset);\n    };\n    LineCrosshair.prototype.getLinePath = function () {\n        var _a = this.getLocation(), start = _a.start, end = _a.end;\n        return [\n            ['M', start.x, start.y],\n            ['L', end.x, end.y],\n        ];\n    };\n    return LineCrosshair;\n}(CrosshairBase));\nexport default LineCrosshair;\n//# sourceMappingURL=line.js.map"]},"metadata":{},"sourceType":"module"}