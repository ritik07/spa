{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { get, deepMix, isArray } from '@antv/util';\nimport GeometryLabel from './base';\n/**\n * 柱状图 label\n */\nvar IntervalLabel = /** @class */function (_super) {\n  __extends(IntervalLabel, _super);\n  function IntervalLabel() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * 获取 interval label 的方向，取决于 value 的值是正还是负\n   * @param labelCfg\n   */\n  IntervalLabel.prototype.getLabelValueDir = function (mappingData) {\n    // points 中的 x/y 和 transpose 无关\n    var dim = 'y';\n    var points = mappingData.points;\n    return points[0][dim] <= points[2][dim] ? 1 : -1;\n  };\n  /**\n   * 重载：根据 interval 值的正负来调整 label 偏移量\n   * @param labelCfg\n   * @param index\n   * @param total\n   */\n  IntervalLabel.prototype.getLabelOffsetPoint = function (labelCfg, index, total, position) {\n    var _a;\n    var point = _super.prototype.getLabelOffsetPoint.call(this, labelCfg, index, total);\n    var coordinate = this.getCoordinate();\n    var transposed = coordinate.isTransposed;\n    var dim = transposed ? 'x' : 'y';\n    var dir = this.getLabelValueDir(labelCfg.mappingData);\n    point = __assign(__assign({}, point), (_a = {}, _a[dim] = point[dim] * dir, _a));\n    if (coordinate.isReflect('x')) {\n      point = __assign(__assign({}, point), {\n        x: point.x * -1\n      });\n    }\n    if (coordinate.isReflect('y')) {\n      point = __assign(__assign({}, point), {\n        y: point.y * -1\n      });\n    }\n    return point;\n  };\n  /**\n   * 重载：定制 interval label 的默认主题配置\n   * @param labelCfg\n   */\n  IntervalLabel.prototype.getThemedLabelCfg = function (labelCfg) {\n    var geometry = this.geometry;\n    var defaultLabelCfg = this.getDefaultLabelCfg();\n    var theme = geometry.theme;\n    // 如果 interval label position 设置为 middle，则将主题中的 offset 覆盖为 0\n    return deepMix({}, defaultLabelCfg, theme.labels, labelCfg.position === 'middle' ? {\n      offset: 0\n    } : {}, labelCfg);\n  };\n  IntervalLabel.prototype.setLabelPosition = function (labelPointCfg, mappingData, index, position) {\n    var coordinate = this.getCoordinate();\n    var transposed = coordinate.isTransposed;\n    var shapePoints = mappingData.points;\n    var point0 = coordinate.convert(shapePoints[0]);\n    var point2 = coordinate.convert(shapePoints[2]);\n    var dir = this.getLabelValueDir(mappingData);\n    var top;\n    var right;\n    var bottom;\n    var left;\n    var shape = isArray(mappingData.shape) ? mappingData.shape[0] : mappingData.shape;\n    if (shape === 'funnel' || shape === 'pyramid') {\n      // 处理漏斗图\n      var nextPoints = get(mappingData, 'nextPoints');\n      var points = get(mappingData, 'points');\n      if (nextPoints) {\n        // 非漏斗图底部\n        var p0 = coordinate.convert(points[0]);\n        var p1 = coordinate.convert(points[1]);\n        var nextP0 = coordinate.convert(nextPoints[0]);\n        var nextP1 = coordinate.convert(nextPoints[1]);\n        // TODO: 使用包围盒的计算方法\n        if (transposed) {\n          top = Math.min(nextP0.y, p0.y);\n          bottom = Math.max(nextP0.y, p0.y);\n          right = (p1.x + nextP1.x) / 2;\n          left = (p0.x + nextP0.x) / 2;\n        } else {\n          top = Math.min((p1.y + nextP1.y) / 2, (p0.y + nextP0.y) / 2);\n          bottom = Math.max((p1.y + nextP1.y) / 2, (p0.y + nextP0.y) / 2);\n          right = nextP1.x;\n          left = p0.x;\n        }\n      } else {\n        top = Math.min(point2.y, point0.y);\n        bottom = Math.max(point2.y, point0.y);\n        right = point2.x;\n        left = point0.x;\n      }\n    } else {\n      top = Math.min(point2.y, point0.y);\n      bottom = Math.max(point2.y, point0.y);\n      right = point2.x;\n      left = point0.x;\n    }\n    switch (position) {\n      case 'right':\n        labelPointCfg.x = right;\n        labelPointCfg.y = (top + bottom) / 2;\n        labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', dir > 0 ? 'left' : 'right');\n        break;\n      case 'left':\n        labelPointCfg.x = left;\n        labelPointCfg.y = (top + bottom) / 2;\n        labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', dir > 0 ? 'left' : 'right');\n        break;\n      case 'bottom':\n        if (transposed) {\n          labelPointCfg.x = (right + left) / 2;\n        }\n        labelPointCfg.y = bottom;\n        labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', 'center');\n        labelPointCfg.textBaseline = get(labelPointCfg, 'textBaseline', dir > 0 ? 'bottom' : 'top');\n        break;\n      case 'middle':\n        if (transposed) {\n          labelPointCfg.x = (right + left) / 2;\n        }\n        labelPointCfg.y = (top + bottom) / 2;\n        labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', 'center');\n        labelPointCfg.textBaseline = get(labelPointCfg, 'textBaseline', 'middle');\n        break;\n      case 'top':\n        if (transposed) {\n          labelPointCfg.x = (right + left) / 2;\n        }\n        labelPointCfg.y = top;\n        labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', 'center');\n        labelPointCfg.textBaseline = get(labelPointCfg, 'textBaseline', dir > 0 ? 'bottom' : 'top');\n        break;\n      default:\n        break;\n    }\n  };\n  return IntervalLabel;\n}(GeometryLabel);\nexport default IntervalLabel;","map":{"version":3,"sources":["../../../src/geometry/label/interval.ts"],"names":[],"mappings":"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","sourcesContent":["import { get, deepMix, isArray } from '@antv/util';\nimport { Writeable } from '../../util/types';\nimport { MappingDatum, Point } from '../../interface';\nimport GeometryLabel from './base';\nimport { LabelCfg, LabelItem, LabelPointCfg, TextAlign } from './interface';\n\n/**\n * 柱状图 label\n */\nexport default class IntervalLabel extends GeometryLabel {\n  /**\n   * 获取 interval label 的方向，取决于 value 的值是正还是负\n   * @param labelCfg\n   */\n  private getLabelValueDir(mappingData: MappingDatum) {\n    // points 中的 x/y 和 transpose 无关\n    const dim = 'y';\n    const { points } = mappingData;\n\n    return points[0][dim] <= points[2][dim] ? 1 : -1;\n  }\n\n  /**\n   * 重载：根据 interval 值的正负来调整 label 偏移量\n   * @param labelCfg\n   * @param index\n   * @param total\n   */\n  protected getLabelOffsetPoint(labelCfg: LabelCfg, index: number, total: number, position?: string) {\n    let point = super.getLabelOffsetPoint(labelCfg, index, total);\n    const coordinate = this.getCoordinate();\n    const transposed = coordinate.isTransposed;\n    const dim = transposed ? 'x' : 'y';\n    const dir = this.getLabelValueDir(labelCfg.mappingData);\n    point = { ...point, [dim]: point[dim] * dir };\n\n    if (coordinate.isReflect('x')) {\n      point = {\n        ...point,\n        x: point.x * -1,\n      };\n    }\n    if (coordinate.isReflect('y')) {\n      point = {\n        ...point,\n        y: point.y * -1,\n      };\n    }\n\n    return point;\n  }\n\n  /**\n   * 重载：定制 interval label 的默认主题配置\n   * @param labelCfg\n   */\n  protected getThemedLabelCfg(labelCfg: LabelCfg) {\n    const geometry = this.geometry;\n    const defaultLabelCfg = this.getDefaultLabelCfg();\n    const { theme } = geometry;\n\n    // 如果 interval label position 设置为 middle，则将主题中的 offset 覆盖为 0\n    return deepMix({}, defaultLabelCfg, theme.labels, labelCfg.position === 'middle' ? { offset: 0 } : {}, labelCfg);\n  }\n\n  protected setLabelPosition(\n    labelPointCfg: Writeable<LabelPointCfg>,\n    mappingData: MappingDatum,\n    index: number,\n    position: string\n  ) {\n    const coordinate = this.getCoordinate();\n    const transposed = coordinate.isTransposed;\n    const shapePoints = mappingData.points as Point[];\n    const point0 = coordinate.convert(shapePoints[0]);\n    const point2 = coordinate.convert(shapePoints[2]);\n    const dir = this.getLabelValueDir(mappingData);\n\n    let top;\n    let right;\n    let bottom;\n    let left;\n\n    const shape = isArray(mappingData.shape) ? mappingData.shape[0] : mappingData.shape;\n    if (shape === 'funnel' || shape === 'pyramid') {\n      // 处理漏斗图\n      const nextPoints = get(mappingData, 'nextPoints');\n      const points = get(mappingData, 'points');\n      if (nextPoints) {\n        // 非漏斗图底部\n        const p0 = coordinate.convert(points[0] as Point);\n        const p1 = coordinate.convert(points[1] as Point);\n        const nextP0 = coordinate.convert(nextPoints[0] as Point);\n        const nextP1 = coordinate.convert(nextPoints[1] as Point);\n\n        // TODO: 使用包围盒的计算方法\n        if (transposed) {\n          top = Math.min(nextP0.y, p0.y);\n          bottom = Math.max(nextP0.y, p0.y);\n          right = (p1.x + nextP1.x) / 2;\n          left = (p0.x + nextP0.x) / 2;\n        } else {\n          top = Math.min((p1.y + nextP1.y) / 2, (p0.y + nextP0.y) / 2);\n          bottom = Math.max((p1.y + nextP1.y) / 2, (p0.y + nextP0.y) / 2);\n          right = nextP1.x;\n          left = p0.x;\n        }\n      } else {\n        top = Math.min(point2.y, point0.y);\n        bottom = Math.max(point2.y, point0.y);\n        right = point2.x;\n        left = point0.x;\n      }\n    } else {\n      top = Math.min(point2.y, point0.y);\n      bottom = Math.max(point2.y, point0.y);\n      right = point2.x;\n      left = point0.x;\n    }\n\n    switch (position) {\n      case 'right':\n        labelPointCfg.x = right;\n        labelPointCfg.y = (top + bottom) / 2;\n        labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', dir > 0 ? 'left' : 'right');\n        break;\n      case 'left':\n        labelPointCfg.x = left;\n        labelPointCfg.y = (top + bottom) / 2;\n        labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', dir > 0 ? 'left' : 'right');\n        break;\n      case 'bottom':\n        if (transposed) {\n          labelPointCfg.x = (right + left) / 2;\n        }\n        labelPointCfg.y = bottom;\n        labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', 'center');\n        labelPointCfg.textBaseline = get(labelPointCfg, 'textBaseline', dir > 0 ? 'bottom' : 'top');\n        break;\n      case 'middle':\n        if (transposed) {\n          labelPointCfg.x = (right + left) / 2;\n        }\n        labelPointCfg.y = (top + bottom) / 2;\n        labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', 'center');\n        labelPointCfg.textBaseline = get(labelPointCfg, 'textBaseline', 'middle');\n        break;\n      case 'top':\n        if (transposed) {\n          labelPointCfg.x = (right + left) / 2;\n        }\n        labelPointCfg.y = top;\n        labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', 'center');\n        labelPointCfg.textBaseline = get(labelPointCfg, 'textBaseline', dir > 0 ? 'bottom' : 'top');\n        break;\n      default:\n        break;\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}