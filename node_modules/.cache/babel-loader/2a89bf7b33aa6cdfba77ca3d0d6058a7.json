{"ast":null,"code":"import { __assign, __read } from \"tslib\";\nimport { getArcParams } from '@antv/g-canvas';\nimport { isNumberEqual, isEqual } from '@antv/util';\nimport { getArcPath, getSectorPath } from '../../util/graphics';\nfunction getAngle(startPoint, arcPath) {\n  var _a;\n  var _b = getArcParams(startPoint, arcPath),\n    startAngle = _b.startAngle,\n    endAngle = _b.endAngle;\n  if (!isNumberEqual(startAngle, -Math.PI * 0.5) && startAngle < -Math.PI * 0.5) {\n    startAngle += Math.PI * 2;\n  }\n  if (!isNumberEqual(endAngle, -Math.PI * 0.5) && endAngle < -Math.PI * 0.5) {\n    endAngle += Math.PI * 2;\n  }\n  if (arcPath[5] === 0) {\n    // 逆时针，需要将 startAngle 和 endAngle 转置，因为 G2 极坐标系为顺时针方向\n    _a = __read([endAngle, startAngle], 2), startAngle = _a[0], endAngle = _a[1];\n  }\n  if (isNumberEqual(startAngle, Math.PI * 1.5)) {\n    startAngle = Math.PI * -0.5;\n  }\n  // 当 startAngle, endAngle 接近相等时，不进行 endAngle = Math.PI * 1.5 防止变化从整个圆开始\n  if (isNumberEqual(endAngle, Math.PI * -0.5) && !isNumberEqual(startAngle, endAngle)) {\n    endAngle = Math.PI * 1.5;\n  }\n  return {\n    startAngle: startAngle,\n    endAngle: endAngle\n  };\n}\nfunction getArcStartPoint(path) {\n  var startPoint;\n  if (path[0] === 'M' || path[0] === 'L') {\n    startPoint = [path[1], path[2]];\n  } else if (path[0] === 'a' || path[0] === 'A' || path[0] === 'C') {\n    startPoint = [path[path.length - 2], path[path.length - 1]];\n  }\n  return startPoint;\n}\n/**\n * path 存在以下情况\n * 1. 饼图不为整圆的 path，命令为 M, L, A, L, Z\n * 2. 饼图为整圆的 path，命令为 M, M, A, A, M, Z\n * 3. 环图不为整圆的 path，命令为 M, A, L, A, L, Z\n * 4. 环图为整圆的 path，命令为 M, A, A, M, A, A, M, Z\n * 5. radial-line, 不为整圆时的 path, 命令为 M, A, A, Z\n * 6. radial-line, 为整圆时的 path，命令为 M, A, A, A, A, Z\n * @param path theta 坐标系下圆弧的 path 命令\n */\nexport function getArcInfo(path) {\n  var _a;\n  var startAngle;\n  var endAngle;\n  var arcPaths = path.filter(function (command) {\n    return command[0] === 'A' || command[0] === 'a';\n  });\n  if (arcPaths.length === 0) {\n    return {\n      startAngle: 0,\n      endAngle: 0,\n      radius: 0,\n      innerRadius: 0\n    };\n  }\n  var firstArcPathCommand = arcPaths[0];\n  var lastArcPathCommand = arcPaths.length > 1 ? arcPaths[1] : arcPaths[0];\n  var firstIndex = path.indexOf(firstArcPathCommand);\n  var lastIndex = path.indexOf(lastArcPathCommand);\n  var firstStartPoint = getArcStartPoint(path[firstIndex - 1]);\n  var lastStartPoint = getArcStartPoint(path[lastIndex - 1]);\n  var _b = getAngle(firstStartPoint, firstArcPathCommand),\n    firstStartAngle = _b.startAngle,\n    firstEndAngle = _b.endAngle;\n  var _c = getAngle(lastStartPoint, lastArcPathCommand),\n    lastStartAngle = _c.startAngle,\n    lastEndAngle = _c.endAngle;\n  if (isNumberEqual(firstStartAngle, lastStartAngle) && isNumberEqual(firstEndAngle, lastEndAngle)) {\n    startAngle = firstStartAngle;\n    endAngle = firstEndAngle;\n  } else {\n    startAngle = Math.min(firstStartAngle, lastStartAngle);\n    endAngle = Math.max(firstEndAngle, lastEndAngle);\n  }\n  var radius = firstArcPathCommand[1];\n  var innerRadius = arcPaths[arcPaths.length - 1][1];\n  if (radius < innerRadius) {\n    _a = __read([innerRadius, radius], 2), radius = _a[0], innerRadius = _a[1];\n  } else if (radius === innerRadius) {\n    innerRadius = 0;\n  }\n  return {\n    startAngle: startAngle,\n    endAngle: endAngle,\n    radius: radius,\n    innerRadius: innerRadius\n  };\n}\n/**\n * @ignore\n * 饼图更新动画\n * @param shape 文本图形\n * @param animateCfg\n * @param cfg\n */\nexport function sectorPathUpdate(shape, animateCfg, cfg) {\n  var toAttrs = cfg.toAttrs,\n    coordinate = cfg.coordinate;\n  var path = toAttrs.path || [];\n  var pathCommands = path.map(function (command) {\n    return command[0];\n  });\n  if (path.length < 1) return;\n  var _a = getArcInfo(path),\n    curStartAngle = _a.startAngle,\n    curEndAngle = _a.endAngle,\n    radius = _a.radius,\n    innerRadius = _a.innerRadius;\n  var _b = getArcInfo(shape.attr('path')),\n    preStartAngle = _b.startAngle,\n    preEndAngle = _b.endAngle;\n  var center = coordinate.getCenter();\n  var diffStartAngle = curStartAngle - preStartAngle;\n  var diffEndAngle = curEndAngle - preEndAngle;\n  // 没有 diff 时直接返回最终 attrs，不需要额外动画\n  if (diffStartAngle === 0 && diffEndAngle === 0) {\n    shape.attr('path', path);\n    return;\n  }\n  shape.animate(function (ratio) {\n    var onFrameStartAngle = preStartAngle + ratio * diffStartAngle;\n    var onFrameEndAngle = preEndAngle + ratio * diffEndAngle;\n    return __assign(__assign({}, toAttrs), {\n      path:\n      // hack, 兼容 /examples/bar/basic/demo/radial-line.ts 动画\n      isEqual(pathCommands, ['M', 'A', 'A', 'Z']) ? getArcPath(center.x, center.y, radius, onFrameStartAngle, onFrameEndAngle) : getSectorPath(center.x, center.y, radius, onFrameStartAngle, onFrameEndAngle, innerRadius)\n    });\n  }, __assign(__assign({}, animateCfg), {\n    callback: function () {\n      // 将 path 保持原始态，否则会影响 setState() 的动画\n      shape.attr('path', path);\n    }\n  }));\n}","map":{"version":3,"sources":["../../../src/animate/animation/sector-path-update.ts"],"names":[],"mappings":"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","sourcesContent":["import { getArcParams } from '@antv/g-canvas';\nimport { isNumberEqual, isEqual } from '@antv/util';\n\nimport { IShape, PathCommand } from '../../dependents';\nimport { GAnimateCfg } from '../../interface';\nimport { AnimateExtraCfg } from '../interface';\n\nimport { getArcPath, getSectorPath } from '../../util/graphics';\n\nfunction getAngle(startPoint: number[], arcPath: PathCommand) {\n  let { startAngle, endAngle } = getArcParams(startPoint, arcPath);\n\n  if (!isNumberEqual(startAngle, -Math.PI * 0.5) && startAngle < -Math.PI * 0.5) {\n    startAngle += Math.PI * 2;\n  }\n  if (!isNumberEqual(endAngle, -Math.PI * 0.5) && endAngle < -Math.PI * 0.5) {\n    endAngle += Math.PI * 2;\n  }\n\n  if (arcPath[5] === 0) {\n    // 逆时针，需要将 startAngle 和 endAngle 转置，因为 G2 极坐标系为顺时针方向\n    [startAngle, endAngle] = [endAngle, startAngle];\n  }\n\n  if (isNumberEqual(startAngle, Math.PI * 1.5)) {\n    startAngle = Math.PI * -0.5;\n  }\n\n  // 当 startAngle, endAngle 接近相等时，不进行 endAngle = Math.PI * 1.5 防止变化从整个圆开始\n  if (isNumberEqual(endAngle, Math.PI * -0.5) && !isNumberEqual(startAngle, endAngle)) {\n    endAngle = Math.PI * 1.5;\n  }\n\n  return {\n    startAngle,\n    endAngle,\n  };\n}\n\nfunction getArcStartPoint(path: PathCommand) {\n  let startPoint;\n  if (path[0] === 'M' || path[0] === 'L') {\n    startPoint = [path[1], path[2]];\n  } else if (path[0] === 'a' || path[0] === 'A' || path[0] === 'C') {\n    startPoint = [path[path.length - 2], path[path.length - 1]];\n  }\n\n  return startPoint;\n}\n\n/**\n * path 存在以下情况\n * 1. 饼图不为整圆的 path，命令为 M, L, A, L, Z\n * 2. 饼图为整圆的 path，命令为 M, M, A, A, M, Z\n * 3. 环图不为整圆的 path，命令为 M, A, L, A, L, Z\n * 4. 环图为整圆的 path，命令为 M, A, A, M, A, A, M, Z\n * 5. radial-line, 不为整圆时的 path, 命令为 M, A, A, Z\n * 6. radial-line, 为整圆时的 path，命令为 M, A, A, A, A, Z\n * @param path theta 坐标系下圆弧的 path 命令\n */\nexport function getArcInfo(path: PathCommand[]) {\n  let startAngle;\n  let endAngle;\n\n  const arcPaths = path.filter((command) => {\n    return command[0] === 'A' || command[0] === 'a';\n  });\n\n  if (arcPaths.length === 0) {\n    return {\n      startAngle: 0,\n      endAngle: 0,\n      radius: 0,\n      innerRadius: 0,\n    };\n  }\n\n  const firstArcPathCommand = arcPaths[0];\n  const lastArcPathCommand = arcPaths.length > 1 ? arcPaths[1] : arcPaths[0];\n  const firstIndex = path.indexOf(firstArcPathCommand);\n  const lastIndex = path.indexOf(lastArcPathCommand);\n  const firstStartPoint = getArcStartPoint(path[firstIndex - 1]);\n  const lastStartPoint = getArcStartPoint(path[lastIndex - 1]);\n\n  const { startAngle: firstStartAngle, endAngle: firstEndAngle } = getAngle(firstStartPoint, firstArcPathCommand);\n  const { startAngle: lastStartAngle, endAngle: lastEndAngle } = getAngle(lastStartPoint, lastArcPathCommand);\n\n  if (isNumberEqual(firstStartAngle, lastStartAngle) && isNumberEqual(firstEndAngle, lastEndAngle)) {\n    startAngle = firstStartAngle;\n    endAngle = firstEndAngle;\n  } else {\n    startAngle = Math.min(firstStartAngle, lastStartAngle);\n    endAngle = Math.max(firstEndAngle, lastEndAngle);\n  }\n\n  let radius = firstArcPathCommand[1];\n  let innerRadius = arcPaths[arcPaths.length - 1][1];\n  if (radius < innerRadius) {\n    [radius, innerRadius] = [innerRadius, radius];\n  } else if (radius === innerRadius) {\n    innerRadius = 0;\n  }\n\n  return {\n    startAngle,\n    endAngle,\n    radius,\n    innerRadius,\n  };\n}\n\n/**\n * @ignore\n * 饼图更新动画\n * @param shape 文本图形\n * @param animateCfg\n * @param cfg\n */\nexport function sectorPathUpdate(shape: IShape, animateCfg: GAnimateCfg, cfg: AnimateExtraCfg) {\n  const { toAttrs, coordinate } = cfg;\n  const path = (toAttrs as { path: PathCommand[] }).path || [];\n  const pathCommands = path.map((command) => command[0]);\n\n  if (path.length < 1) return;\n\n  const { startAngle: curStartAngle, endAngle: curEndAngle, radius, innerRadius } = getArcInfo(path);\n  const { startAngle: preStartAngle, endAngle: preEndAngle } = getArcInfo(shape.attr('path'));\n\n  const center = coordinate.getCenter();\n  const diffStartAngle = curStartAngle - preStartAngle;\n  const diffEndAngle = curEndAngle - preEndAngle;\n  // 没有 diff 时直接返回最终 attrs，不需要额外动画\n  if (diffStartAngle === 0 && diffEndAngle === 0) {\n    shape.attr('path', path);\n    return;\n  }\n\n  shape.animate(\n    (ratio) => {\n      const onFrameStartAngle = preStartAngle + ratio * diffStartAngle;\n      const onFrameEndAngle = preEndAngle + ratio * diffEndAngle;\n      return {\n        ...toAttrs,\n        path:\n          // hack, 兼容 /examples/bar/basic/demo/radial-line.ts 动画\n          isEqual(pathCommands, ['M', 'A', 'A', 'Z'])\n            ? getArcPath(center.x, center.y, radius, onFrameStartAngle, onFrameEndAngle)\n            : getSectorPath(center.x, center.y, radius, onFrameStartAngle, onFrameEndAngle, innerRadius),\n      };\n    },\n    {\n      ...animateCfg,\n      callback: () => {\n        // 将 path 保持原始态，否则会影响 setState() 的动画\n        shape.attr('path', path);\n      },\n    }\n  );\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}