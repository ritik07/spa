{"ast":null,"code":"import { ext, vec2, vec3 } from '@antv/matrix-util';\nvar identityMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\nexport function getMatrixByAngle(point, angle, matrix) {\n  if (matrix === void 0) {\n    matrix = identityMatrix;\n  }\n  if (!angle) {\n    // 角度为 0 或者 null 时返回 null\n    return null;\n  }\n  var m = ext.transform(matrix, [['t', -point.x, -point.y], ['r', angle], ['t', point.x, point.y]]);\n  return m;\n}\nexport function getMatrixByTranslate(point, currentMatrix) {\n  if (!point.x && !point.y) {\n    // 0，0 或者 nan 的情况下返回 null\n    return null;\n  }\n  return ext.transform(currentMatrix || identityMatrix, [['t', point.x, point.y]]);\n}\n// 从矩阵获取旋转的角度\nexport function getAngleByMatrix(matrix) {\n  var xVector = [1, 0, 0];\n  var out = [0, 0, 0];\n  vec3.transformMat3(out, xVector, matrix);\n  return Math.atan2(out[1], out[0]);\n}\n// 矩阵 * 向量\nfunction multiplyVec2(matrix, v) {\n  var out = [0, 0];\n  vec2.transformMat3(out, v, matrix);\n  return out;\n}\nexport function applyMatrix2BBox(matrix, bbox) {\n  var topLeft = multiplyVec2(matrix, [bbox.minX, bbox.minY]);\n  var topRight = multiplyVec2(matrix, [bbox.maxX, bbox.minY]);\n  var bottomLeft = multiplyVec2(matrix, [bbox.minX, bbox.maxY]);\n  var bottomRight = multiplyVec2(matrix, [bbox.maxX, bbox.maxY]);\n  var minX = Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);\n  var maxX = Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);\n  var minY = Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);\n  var maxY = Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);\n  return {\n    x: minX,\n    y: minY,\n    minX: minX,\n    minY: minY,\n    maxX: maxX,\n    maxY: maxY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nexport function applyRotate(shape, rotate, x, y) {\n  if (rotate) {\n    var matrix = getMatrixByAngle({\n      x: x,\n      y: y\n    }, rotate, shape.getMatrix());\n    shape.setMatrix(matrix);\n  }\n}\nexport function applyTranslate(shape, x, y) {\n  var translateMatrix = getMatrixByTranslate({\n    x: x,\n    y: y\n  });\n  shape.attr('matrix', translateMatrix);\n}","map":{"version":3,"sources":["../../src/util/matrix.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { ext, vec2, vec3 } from '@antv/matrix-util';\nvar identityMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\nexport function getMatrixByAngle(point, angle, matrix) {\n    if (matrix === void 0) { matrix = identityMatrix; }\n    if (!angle) {\n        // 角度为 0 或者 null 时返回 null\n        return null;\n    }\n    var m = ext.transform(matrix, [\n        ['t', -point.x, -point.y],\n        ['r', angle],\n        ['t', point.x, point.y],\n    ]);\n    return m;\n}\nexport function getMatrixByTranslate(point, currentMatrix) {\n    if (!point.x && !point.y) {\n        // 0，0 或者 nan 的情况下返回 null\n        return null;\n    }\n    return ext.transform(currentMatrix || identityMatrix, [['t', point.x, point.y]]);\n}\n// 从矩阵获取旋转的角度\nexport function getAngleByMatrix(matrix) {\n    var xVector = [1, 0, 0];\n    var out = [0, 0, 0];\n    vec3.transformMat3(out, xVector, matrix);\n    return Math.atan2(out[1], out[0]);\n}\n// 矩阵 * 向量\nfunction multiplyVec2(matrix, v) {\n    var out = [0, 0];\n    vec2.transformMat3(out, v, matrix);\n    return out;\n}\nexport function applyMatrix2BBox(matrix, bbox) {\n    var topLeft = multiplyVec2(matrix, [bbox.minX, bbox.minY]);\n    var topRight = multiplyVec2(matrix, [bbox.maxX, bbox.minY]);\n    var bottomLeft = multiplyVec2(matrix, [bbox.minX, bbox.maxY]);\n    var bottomRight = multiplyVec2(matrix, [bbox.maxX, bbox.maxY]);\n    var minX = Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);\n    var maxX = Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);\n    var minY = Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);\n    var maxY = Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);\n    return {\n        x: minX,\n        y: minY,\n        minX: minX,\n        minY: minY,\n        maxX: maxX,\n        maxY: maxY,\n        width: maxX - minX,\n        height: maxY - minY,\n    };\n}\nexport function applyRotate(shape, rotate, x, y) {\n    if (rotate) {\n        var matrix = getMatrixByAngle({ x: x, y: y }, rotate, shape.getMatrix());\n        shape.setMatrix(matrix);\n    }\n}\nexport function applyTranslate(shape, x, y) {\n    var translateMatrix = getMatrixByTranslate({ x: x, y: y });\n    shape.attr('matrix', translateMatrix);\n}\n//# sourceMappingURL=matrix.js.map"]},"metadata":{},"sourceType":"module"}