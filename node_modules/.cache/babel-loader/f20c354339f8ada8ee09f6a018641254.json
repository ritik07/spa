{"ast":null,"code":"import { each, isNil, getEllipsisText, pick } from '@antv/util';\nimport { ellipsisString, strLen } from './text';\nvar ELLIPSIS_CODE = '\\u2026';\nvar ELLIPSIS_CODE_LENGTH = 2; // 省略号的长度\n/** 大数据量阈值 */\nvar OPTIMIZE_THRESHOLD = 400;\n/**\n * 针对大数据量做优化的 getMaxLabelWidth，做法不是直接去比较每一个 label 的最大宽度\n * 而是先通过比较每个 label 每个的字符串的长度，这里区分了下中英文字符\n * 最终是去字符串最“长”的那个 label 的宽度。\n * @param labels\n */\nfunction getMaxLabelWidthOptimized(labels) {\n  var texts = labels.map(function (label) {\n    var text = label.attr('text');\n    return isNil(text) ? '' : \"\" + text;\n  });\n  var maxLen = 0;\n  var maxIdx = 0;\n  for (var i = 0; i < texts.length; i += 1) {\n    var len = 0;\n    for (var j = 0; j <= texts[i].length; j += 1) {\n      var code = texts[i].charCodeAt(j);\n      if (code >= 19968 && code <= 40869) {\n        len += 2;\n      } else {\n        len += 1;\n      }\n    }\n    if (len > maxLen) {\n      maxLen = len;\n      maxIdx = i;\n    }\n  }\n  return labels[maxIdx].getBBox().width;\n}\n/** 获取最长的 label */\nexport function getMaxLabelWidth(labels) {\n  if (labels.length > OPTIMIZE_THRESHOLD) {\n    return getMaxLabelWidthOptimized(labels);\n  }\n  var max = 0;\n  each(labels, function (label) {\n    var bbox = label.getBBox();\n    var width = bbox.width;\n    if (max < width) {\n      max = width;\n    }\n  });\n  return max;\n}\n/** 获取label长度 */\nexport function getLabelLength(isVertical, label) {\n  var bbox = label.getCanvasBBox();\n  return isVertical ? bbox.width : bbox.height;\n}\n/* label长度是否超过约束值 */\nexport function testLabel(label, limitLength) {\n  return label.getBBox().width < limitLength;\n}\n/** 处理 text shape 的自动省略 */\nexport function ellipsisLabel(isVertical, label, limitLength, position) {\n  var _a;\n  if (position === void 0) {\n    position = 'tail';\n  }\n  var text = (_a = label.attr('text')) !== null && _a !== void 0 ? _a : ''; // 避免出现null、undefined\n  if (position === 'tail') {\n    // component 里的缩略处理做得很糟糕，文字长度测算完全不准确\n    // 这里暂时只对 tail 做处理\n    var font = pick(label.attr(), ['fontSize', 'fontFamily', 'fontWeight', 'fontStyle', 'fontVariant']);\n    var ellipsisText = getEllipsisText(text, limitLength, font, '…');\n    if (text !== ellipsisText) {\n      label.attr('text', ellipsisText);\n      label.set('tip', text);\n      return true;\n    }\n    label.set('tip', null);\n    return false;\n  }\n  var labelLength = getLabelLength(isVertical, label);\n  var codeLength = strLen(text);\n  var ellipsisFlag = false;\n  if (limitLength < labelLength) {\n    var reserveLength = Math.floor(limitLength / labelLength * codeLength) - ELLIPSIS_CODE_LENGTH; // 计算出来的应该保存的长度\n    var newText = void 0;\n    if (reserveLength >= 0) {\n      newText = ellipsisString(text, reserveLength, position);\n    } else {\n      newText = ELLIPSIS_CODE;\n    }\n    if (newText) {\n      label.attr('text', newText);\n      ellipsisFlag = true;\n    }\n  }\n  if (ellipsisFlag) {\n    label.set('tip', text);\n  } else {\n    label.set('tip', null);\n  }\n  return ellipsisFlag;\n}","map":{"version":3,"sources":["../../src/util/label.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { each, isNil, getEllipsisText, pick } from '@antv/util';\nimport { ellipsisString, strLen } from './text';\nvar ELLIPSIS_CODE = '\\u2026';\nvar ELLIPSIS_CODE_LENGTH = 2; // 省略号的长度\n/** 大数据量阈值 */\nvar OPTIMIZE_THRESHOLD = 400;\n/**\n * 针对大数据量做优化的 getMaxLabelWidth，做法不是直接去比较每一个 label 的最大宽度\n * 而是先通过比较每个 label 每个的字符串的长度，这里区分了下中英文字符\n * 最终是去字符串最“长”的那个 label 的宽度。\n * @param labels\n */\nfunction getMaxLabelWidthOptimized(labels) {\n    var texts = labels.map(function (label) {\n        var text = label.attr('text');\n        return isNil(text) ? '' : \"\" + text;\n    });\n    var maxLen = 0;\n    var maxIdx = 0;\n    for (var i = 0; i < texts.length; i += 1) {\n        var len = 0;\n        for (var j = 0; j <= texts[i].length; j += 1) {\n            var code = texts[i].charCodeAt(j);\n            if (code >= 19968 && code <= 40869) {\n                len += 2;\n            }\n            else {\n                len += 1;\n            }\n        }\n        if (len > maxLen) {\n            maxLen = len;\n            maxIdx = i;\n        }\n    }\n    return labels[maxIdx].getBBox().width;\n}\n/** 获取最长的 label */\nexport function getMaxLabelWidth(labels) {\n    if (labels.length > OPTIMIZE_THRESHOLD) {\n        return getMaxLabelWidthOptimized(labels);\n    }\n    var max = 0;\n    each(labels, function (label) {\n        var bbox = label.getBBox();\n        var width = bbox.width;\n        if (max < width) {\n            max = width;\n        }\n    });\n    return max;\n}\n/** 获取label长度 */\nexport function getLabelLength(isVertical, label) {\n    var bbox = label.getCanvasBBox();\n    return isVertical ? bbox.width : bbox.height;\n}\n/* label长度是否超过约束值 */\nexport function testLabel(label, limitLength) {\n    return label.getBBox().width < limitLength;\n}\n/** 处理 text shape 的自动省略 */\nexport function ellipsisLabel(isVertical, label, limitLength, position) {\n    var _a;\n    if (position === void 0) { position = 'tail'; }\n    var text = (_a = label.attr('text')) !== null && _a !== void 0 ? _a : ''; // 避免出现null、undefined\n    if (position === 'tail') {\n        // component 里的缩略处理做得很糟糕，文字长度测算完全不准确\n        // 这里暂时只对 tail 做处理\n        var font = pick(label.attr(), ['fontSize', 'fontFamily', 'fontWeight', 'fontStyle', 'fontVariant']);\n        var ellipsisText = getEllipsisText(text, limitLength, font, '…');\n        if (text !== ellipsisText) {\n            label.attr('text', ellipsisText);\n            label.set('tip', text);\n            return true;\n        }\n        label.set('tip', null);\n        return false;\n    }\n    var labelLength = getLabelLength(isVertical, label);\n    var codeLength = strLen(text);\n    var ellipsisFlag = false;\n    if (limitLength < labelLength) {\n        var reserveLength = Math.floor((limitLength / labelLength) * codeLength) - ELLIPSIS_CODE_LENGTH; // 计算出来的应该保存的长度\n        var newText = void 0;\n        if (reserveLength >= 0) {\n            newText = ellipsisString(text, reserveLength, position);\n        }\n        else {\n            newText = ELLIPSIS_CODE;\n        }\n        if (newText) {\n            label.attr('text', newText);\n            ellipsisFlag = true;\n        }\n    }\n    if (ellipsisFlag) {\n        label.set('tip', text);\n    }\n    else {\n        label.set('tip', null);\n    }\n    return ellipsisFlag;\n}\n//# sourceMappingURL=label.js.map"]},"metadata":{},"sourceType":"module"}