{"ast":null,"code":"import { vec2 } from '@antv/matrix-util';\nfunction smoothBezier(points, smooth, isLoop, constraint) {\n  var cps = [];\n  var hasConstraint = !!constraint;\n  var prevPoint;\n  var nextPoint;\n  var min;\n  var max;\n  var nextCp0;\n  var cp1;\n  var cp0;\n  if (hasConstraint) {\n    min = constraint[0], max = constraint[1];\n    for (var i = 0, l = points.length; i < l; i += 1) {\n      var point = points[i];\n      min = vec2.min([0, 0], min, point);\n      max = vec2.max([0, 0], max, point);\n    }\n  }\n  for (var i = 0, len = points.length; i < len; i += 1) {\n    var point = points[i];\n    if (i === 0 && !isLoop) {\n      cp0 = point;\n    } else if (i === len - 1 && !isLoop) {\n      cp1 = point;\n      cps.push(cp0);\n      cps.push(cp1);\n    } else {\n      var prevIdx = [i ? i - 1 : len - 1, i - 1][isLoop ? 0 : 1];\n      prevPoint = points[prevIdx];\n      nextPoint = points[isLoop ? (i + 1) % len : i + 1];\n      var v = [0, 0];\n      v = vec2.sub(v, nextPoint, prevPoint);\n      v = vec2.scale(v, v, smooth);\n      var d0 = vec2.distance(point, prevPoint);\n      var d1 = vec2.distance(point, nextPoint);\n      var sum = d0 + d1;\n      if (sum !== 0) {\n        d0 /= sum;\n        d1 /= sum;\n      }\n      var v1 = vec2.scale([0, 0], v, -d0);\n      var v2 = vec2.scale([0, 0], v, d1);\n      cp1 = vec2.add([0, 0], point, v1);\n      nextCp0 = vec2.add([0, 0], point, v2);\n      // 下一个控制点必须在这个点和下一个点之间\n      nextCp0 = vec2.min([0, 0], nextCp0, vec2.max([0, 0], nextPoint, point));\n      nextCp0 = vec2.max([0, 0], nextCp0, vec2.min([0, 0], nextPoint, point));\n      // 重新计算 cp1 的值\n      v1 = vec2.sub([0, 0], nextCp0, point);\n      v1 = vec2.scale([0, 0], v1, -d0 / d1);\n      cp1 = vec2.add([0, 0], point, v1);\n      // 上一个控制点必须要在上一个点和这一个点之间\n      cp1 = vec2.min([0, 0], cp1, vec2.max([0, 0], prevPoint, point));\n      cp1 = vec2.max([0, 0], cp1, vec2.min([0, 0], prevPoint, point));\n      // 重新计算 nextCp0 的值\n      v2 = vec2.sub([0, 0], point, cp1);\n      v2 = vec2.scale([0, 0], v2, d1 / d0);\n      nextCp0 = vec2.add([0, 0], point, v2);\n      if (hasConstraint) {\n        cp1 = vec2.max([0, 0], cp1, min);\n        cp1 = vec2.min([0, 0], cp1, max);\n        nextCp0 = vec2.max([0, 0], nextCp0, min);\n        nextCp0 = vec2.min([0, 0], nextCp0, max);\n      }\n      cps.push(cp0);\n      cps.push(cp1);\n      cp0 = nextCp0;\n    }\n  }\n  if (isLoop) {\n    cps.push(cps.shift());\n  }\n  return cps;\n}\n/**\n * create bezier spline from catmull rom spline\n * @param {Array} crp Catmull Rom Points\n * @param {boolean} z Spline is loop\n * @param {Array} constraint Constraint\n */\nfunction catmullRom2Bezier(crp, z, constraint) {\n  if (z === void 0) {\n    z = false;\n  }\n  if (constraint === void 0) {\n    constraint = [[0, 0], [1, 1]];\n  }\n  var isLoop = !!z;\n  var pointList = [];\n  for (var i = 0, l = crp.length; i < l; i += 2) {\n    pointList.push([crp[i], crp[i + 1]]);\n  }\n  var controlPointList = smoothBezier(pointList, 0.4, isLoop, constraint);\n  var len = pointList.length;\n  var d1 = [];\n  var cp1;\n  var cp2;\n  var p;\n  for (var i = 0; i < len - 1; i += 1) {\n    cp1 = controlPointList[i * 2];\n    cp2 = controlPointList[i * 2 + 1];\n    p = pointList[i + 1];\n    d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);\n  }\n  if (isLoop) {\n    cp1 = controlPointList[len];\n    cp2 = controlPointList[len + 1];\n    p = pointList[0];\n    d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);\n  }\n  return d1;\n}\nexport default catmullRom2Bezier;","map":{"version":3,"sources":["../src/catmull-rom-2-bezier.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { vec2 } from '@antv/matrix-util';\nfunction smoothBezier(points, smooth, isLoop, constraint) {\n    var cps = [];\n    var hasConstraint = !!constraint;\n    var prevPoint;\n    var nextPoint;\n    var min;\n    var max;\n    var nextCp0;\n    var cp1;\n    var cp0;\n    if (hasConstraint) {\n        min = constraint[0], max = constraint[1];\n        for (var i = 0, l = points.length; i < l; i += 1) {\n            var point = points[i];\n            min = vec2.min([0, 0], min, point);\n            max = vec2.max([0, 0], max, point);\n        }\n    }\n    for (var i = 0, len = points.length; i < len; i += 1) {\n        var point = points[i];\n        if (i === 0 && !isLoop) {\n            cp0 = point;\n        }\n        else if (i === len - 1 && !isLoop) {\n            cp1 = point;\n            cps.push(cp0);\n            cps.push(cp1);\n        }\n        else {\n            var prevIdx = [i ? i - 1 : len - 1, i - 1][isLoop ? 0 : 1];\n            prevPoint = points[prevIdx];\n            nextPoint = points[isLoop ? (i + 1) % len : i + 1];\n            var v = [0, 0];\n            v = vec2.sub(v, nextPoint, prevPoint);\n            v = vec2.scale(v, v, smooth);\n            var d0 = vec2.distance(point, prevPoint);\n            var d1 = vec2.distance(point, nextPoint);\n            var sum = d0 + d1;\n            if (sum !== 0) {\n                d0 /= sum;\n                d1 /= sum;\n            }\n            var v1 = vec2.scale([0, 0], v, -d0);\n            var v2 = vec2.scale([0, 0], v, d1);\n            cp1 = vec2.add([0, 0], point, v1);\n            nextCp0 = vec2.add([0, 0], point, v2);\n            // 下一个控制点必须在这个点和下一个点之间\n            nextCp0 = vec2.min([0, 0], nextCp0, vec2.max([0, 0], nextPoint, point));\n            nextCp0 = vec2.max([0, 0], nextCp0, vec2.min([0, 0], nextPoint, point));\n            // 重新计算 cp1 的值\n            v1 = vec2.sub([0, 0], nextCp0, point);\n            v1 = vec2.scale([0, 0], v1, -d0 / d1);\n            cp1 = vec2.add([0, 0], point, v1);\n            // 上一个控制点必须要在上一个点和这一个点之间\n            cp1 = vec2.min([0, 0], cp1, vec2.max([0, 0], prevPoint, point));\n            cp1 = vec2.max([0, 0], cp1, vec2.min([0, 0], prevPoint, point));\n            // 重新计算 nextCp0 的值\n            v2 = vec2.sub([0, 0], point, cp1);\n            v2 = vec2.scale([0, 0], v2, d1 / d0);\n            nextCp0 = vec2.add([0, 0], point, v2);\n            if (hasConstraint) {\n                cp1 = vec2.max([0, 0], cp1, min);\n                cp1 = vec2.min([0, 0], cp1, max);\n                nextCp0 = vec2.max([0, 0], nextCp0, min);\n                nextCp0 = vec2.min([0, 0], nextCp0, max);\n            }\n            cps.push(cp0);\n            cps.push(cp1);\n            cp0 = nextCp0;\n        }\n    }\n    if (isLoop) {\n        cps.push(cps.shift());\n    }\n    return cps;\n}\n/**\n * create bezier spline from catmull rom spline\n * @param {Array} crp Catmull Rom Points\n * @param {boolean} z Spline is loop\n * @param {Array} constraint Constraint\n */\nfunction catmullRom2Bezier(crp, z, constraint) {\n    if (z === void 0) { z = false; }\n    if (constraint === void 0) { constraint = [\n        [0, 0],\n        [1, 1],\n    ]; }\n    var isLoop = !!z;\n    var pointList = [];\n    for (var i = 0, l = crp.length; i < l; i += 2) {\n        pointList.push([crp[i], crp[i + 1]]);\n    }\n    var controlPointList = smoothBezier(pointList, 0.4, isLoop, constraint);\n    var len = pointList.length;\n    var d1 = [];\n    var cp1;\n    var cp2;\n    var p;\n    for (var i = 0; i < len - 1; i += 1) {\n        cp1 = controlPointList[i * 2];\n        cp2 = controlPointList[i * 2 + 1];\n        p = pointList[i + 1];\n        d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);\n    }\n    if (isLoop) {\n        cp1 = controlPointList[len];\n        cp2 = controlPointList[len + 1];\n        p = pointList[0];\n        d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);\n    }\n    return d1;\n}\nexport default catmullRom2Bezier;\n//# sourceMappingURL=catmull-rom-2-bezier.js.map"]},"metadata":{},"sourceType":"module"}