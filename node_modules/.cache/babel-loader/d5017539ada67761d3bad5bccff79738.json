{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { Polyline as PolylineUtil } from '@antv/g-math';\nimport { Line as LineUtil } from '@antv/g-math';\nimport { each, isArray, isNil } from '@antv/util';\nimport { SVG_ATTR_MAP } from '../constant';\nimport ShapeBase from './base';\nvar Polyline = /** @class */function (_super) {\n  __extends(Polyline, _super);\n  function Polyline() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = 'polyline';\n    _this.canFill = true;\n    _this.canStroke = true;\n    return _this;\n  }\n  Polyline.prototype.getDefaultAttrs = function () {\n    var attrs = _super.prototype.getDefaultAttrs.call(this);\n    return __assign(__assign({}, attrs), {\n      startArrow: false,\n      endArrow: false\n    });\n  };\n  // 更新属性时，检测是否更改了 points\n  Polyline.prototype.onAttrChange = function (name, value, originValue) {\n    _super.prototype.onAttrChange.call(this, name, value, originValue);\n    if (['points'].indexOf(name) !== -1) {\n      this._resetCache();\n    }\n  };\n  Polyline.prototype._resetCache = function () {\n    this.set('totalLength', null);\n    this.set('tCache', null);\n  };\n  Polyline.prototype.createPath = function (context, targetAttrs) {\n    var attrs = this.attr();\n    var el = this.get('el');\n    each(targetAttrs || attrs, function (value, attr) {\n      if (attr === 'points' && isArray(value) && value.length >= 2) {\n        el.setAttribute('points', value.map(function (point) {\n          return point[0] + \",\" + point[1];\n        }).join(' '));\n      } else if (SVG_ATTR_MAP[attr]) {\n        el.setAttribute(SVG_ATTR_MAP[attr], value);\n      }\n    });\n  };\n  /**\n   * Get length of polyline\n   * @return {number} length\n   */\n  Polyline.prototype.getTotalLength = function () {\n    var points = this.attr().points;\n    // get totalLength from cache\n    var totalLength = this.get('totalLength');\n    if (!isNil(totalLength)) {\n      return totalLength;\n    }\n    this.set('totalLength', PolylineUtil.length(points));\n    return this.get('totalLength');\n  };\n  /**\n   * Get point according to ratio\n   * @param {number} ratio\n   * @return {Point} point\n   */\n  Polyline.prototype.getPoint = function (ratio) {\n    var points = this.attr().points;\n    // get tCache from cache\n    var tCache = this.get('tCache');\n    if (!tCache) {\n      this._setTcache();\n      tCache = this.get('tCache');\n    }\n    var subt;\n    var index;\n    each(tCache, function (v, i) {\n      if (ratio >= v[0] && ratio <= v[1]) {\n        subt = (ratio - v[0]) / (v[1] - v[0]);\n        index = i;\n      }\n    });\n    return LineUtil.pointAt(points[index][0], points[index][1], points[index + 1][0], points[index + 1][1], subt);\n  };\n  Polyline.prototype._setTcache = function () {\n    var points = this.attr().points;\n    if (!points || points.length === 0) {\n      return;\n    }\n    var totalLength = this.getTotalLength();\n    if (totalLength <= 0) {\n      return;\n    }\n    var tempLength = 0;\n    var tCache = [];\n    var segmentT;\n    var segmentL;\n    each(points, function (p, i) {\n      if (points[i + 1]) {\n        segmentT = [];\n        segmentT[0] = tempLength / totalLength;\n        segmentL = LineUtil.length(p[0], p[1], points[i + 1][0], points[i + 1][1]);\n        tempLength += segmentL;\n        segmentT[1] = tempLength / totalLength;\n        tCache.push(segmentT);\n      }\n    });\n    this.set('tCache', tCache);\n  };\n  /**\n   * Get start tangent vector\n   * @return {Array}\n   */\n  Polyline.prototype.getStartTangent = function () {\n    var points = this.attr().points;\n    var result = [];\n    result.push([points[1][0], points[1][1]]);\n    result.push([points[0][0], points[0][1]]);\n    return result;\n  };\n  /**\n   * Get end tangent vector\n   * @return {Array}\n   */\n  Polyline.prototype.getEndTangent = function () {\n    var points = this.attr().points;\n    var l = points.length - 1;\n    var result = [];\n    result.push([points[l - 1][0], points[l - 1][1]]);\n    result.push([points[l][0], points[l][1]]);\n    return result;\n  };\n  return Polyline;\n}(ShapeBase);\nexport default Polyline;","map":{"version":3,"sources":["../../src/shape/polyline.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __assign, __extends } from \"tslib\";\nimport { Polyline as PolylineUtil } from '@antv/g-math';\nimport { Line as LineUtil } from '@antv/g-math';\nimport { each, isArray, isNil } from '@antv/util';\nimport { SVG_ATTR_MAP } from '../constant';\nimport ShapeBase from './base';\nvar Polyline = /** @class */ (function (_super) {\n    __extends(Polyline, _super);\n    function Polyline() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.type = 'polyline';\n        _this.canFill = true;\n        _this.canStroke = true;\n        return _this;\n    }\n    Polyline.prototype.getDefaultAttrs = function () {\n        var attrs = _super.prototype.getDefaultAttrs.call(this);\n        return __assign(__assign({}, attrs), { startArrow: false, endArrow: false });\n    };\n    // 更新属性时，检测是否更改了 points\n    Polyline.prototype.onAttrChange = function (name, value, originValue) {\n        _super.prototype.onAttrChange.call(this, name, value, originValue);\n        if (['points'].indexOf(name) !== -1) {\n            this._resetCache();\n        }\n    };\n    Polyline.prototype._resetCache = function () {\n        this.set('totalLength', null);\n        this.set('tCache', null);\n    };\n    Polyline.prototype.createPath = function (context, targetAttrs) {\n        var attrs = this.attr();\n        var el = this.get('el');\n        each(targetAttrs || attrs, function (value, attr) {\n            if (attr === 'points' && isArray(value) && value.length >= 2) {\n                el.setAttribute('points', value.map(function (point) { return point[0] + \",\" + point[1]; }).join(' '));\n            }\n            else if (SVG_ATTR_MAP[attr]) {\n                el.setAttribute(SVG_ATTR_MAP[attr], value);\n            }\n        });\n    };\n    /**\n     * Get length of polyline\n     * @return {number} length\n     */\n    Polyline.prototype.getTotalLength = function () {\n        var points = this.attr().points;\n        // get totalLength from cache\n        var totalLength = this.get('totalLength');\n        if (!isNil(totalLength)) {\n            return totalLength;\n        }\n        this.set('totalLength', PolylineUtil.length(points));\n        return this.get('totalLength');\n    };\n    /**\n     * Get point according to ratio\n     * @param {number} ratio\n     * @return {Point} point\n     */\n    Polyline.prototype.getPoint = function (ratio) {\n        var points = this.attr().points;\n        // get tCache from cache\n        var tCache = this.get('tCache');\n        if (!tCache) {\n            this._setTcache();\n            tCache = this.get('tCache');\n        }\n        var subt;\n        var index;\n        each(tCache, function (v, i) {\n            if (ratio >= v[0] && ratio <= v[1]) {\n                subt = (ratio - v[0]) / (v[1] - v[0]);\n                index = i;\n            }\n        });\n        return LineUtil.pointAt(points[index][0], points[index][1], points[index + 1][0], points[index + 1][1], subt);\n    };\n    Polyline.prototype._setTcache = function () {\n        var points = this.attr().points;\n        if (!points || points.length === 0) {\n            return;\n        }\n        var totalLength = this.getTotalLength();\n        if (totalLength <= 0) {\n            return;\n        }\n        var tempLength = 0;\n        var tCache = [];\n        var segmentT;\n        var segmentL;\n        each(points, function (p, i) {\n            if (points[i + 1]) {\n                segmentT = [];\n                segmentT[0] = tempLength / totalLength;\n                segmentL = LineUtil.length(p[0], p[1], points[i + 1][0], points[i + 1][1]);\n                tempLength += segmentL;\n                segmentT[1] = tempLength / totalLength;\n                tCache.push(segmentT);\n            }\n        });\n        this.set('tCache', tCache);\n    };\n    /**\n     * Get start tangent vector\n     * @return {Array}\n     */\n    Polyline.prototype.getStartTangent = function () {\n        var points = this.attr().points;\n        var result = [];\n        result.push([points[1][0], points[1][1]]);\n        result.push([points[0][0], points[0][1]]);\n        return result;\n    };\n    /**\n     * Get end tangent vector\n     * @return {Array}\n     */\n    Polyline.prototype.getEndTangent = function () {\n        var points = this.attr().points;\n        var l = points.length - 1;\n        var result = [];\n        result.push([points[l - 1][0], points[l - 1][1]]);\n        result.push([points[l][0], points[l][1]]);\n        return result;\n    };\n    return Polyline;\n}(ShapeBase));\nexport default Polyline;\n//# sourceMappingURL=polyline.js.map"]},"metadata":{},"sourceType":"module"}