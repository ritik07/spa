{"ast":null,"code":"import { getSectorPath } from './graphics';\nimport { isBetween } from './helper';\nimport { BBox } from './bbox';\n/**\n * @ignore\n * Gets x dimension length\n * @param coordinate\n * @returns x dimension length\n */\nexport function getXDimensionLength(coordinate) {\n  if (coordinate.isPolar && !coordinate.isTransposed) {\n    // 极坐标系下 width 为弧长\n    return (coordinate.endAngle - coordinate.startAngle) * coordinate.getRadius();\n  }\n  // 直角坐标系\n  var start = coordinate.convert({\n    x: 0,\n    y: 0\n  });\n  var end = coordinate.convert({\n    x: 1,\n    y: 0\n  });\n  // 坐标系有可能发生 transpose 等变换，所有通过两点之间的距离进行计算\n  return Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));\n}\n/**\n * @ignore\n * Determines whether full circle is\n * @param coordinate\n * @returns true if full circle\n */\nexport function isFullCircle(coordinate) {\n  if (coordinate.isPolar) {\n    var startAngle = coordinate.startAngle,\n      endAngle = coordinate.endAngle;\n    return endAngle - startAngle === Math.PI * 2;\n  }\n  return false;\n}\n/**\n * @ignore\n * 获取当前点到坐标系圆心的距离\n * @param coordinate 坐标系\n * @param point 当前点\n * @returns distance to center\n */\nexport function getDistanceToCenter(coordinate, point) {\n  var center = coordinate.getCenter();\n  return Math.sqrt(Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2));\n}\n/**\n * @ignore\n * 坐标点是否在坐标系中\n * @param coordinate\n * @param point\n */\nexport function isPointInCoordinate(coordinate, point) {\n  var result = false;\n  if (coordinate) {\n    if (coordinate.type === 'theta') {\n      var start = coordinate.start,\n        end = coordinate.end;\n      result = isBetween(point.x, start.x, end.x) && isBetween(point.y, start.y, end.y);\n    } else {\n      var invertPoint = coordinate.invert(point);\n      result = isBetween(invertPoint.x, 0, 1) && isBetween(invertPoint.y, 0, 1);\n    }\n  }\n  return result;\n}\n/**\n * @ignore\n * 获取点到圆心的连线与水平方向的夹角\n */\nexport function getAngleByPoint(coordinate, point) {\n  var center = coordinate.getCenter();\n  return Math.atan2(point.y - center.y, point.x - center.x);\n}\n/**\n * @ignore\n * 获取同坐标系范围相同的剪切区域\n * @param coordinate\n * @returns\n */\nexport function getCoordinateClipCfg(coordinate, margin) {\n  if (margin === void 0) {\n    margin = 0;\n  }\n  var start = coordinate.start,\n    end = coordinate.end;\n  var width = coordinate.getWidth();\n  var height = coordinate.getHeight();\n  if (coordinate.isPolar) {\n    var startAngle_1 = coordinate.startAngle,\n      endAngle_1 = coordinate.endAngle;\n    var center_1 = coordinate.getCenter();\n    var radius_1 = coordinate.getRadius();\n    return {\n      type: 'path',\n      startState: {\n        path: getSectorPath(center_1.x, center_1.y, radius_1 + margin, startAngle_1, startAngle_1)\n      },\n      endState: function (ratio) {\n        var diff = (endAngle_1 - startAngle_1) * ratio + startAngle_1;\n        var path = getSectorPath(center_1.x, center_1.y, radius_1 + margin, startAngle_1, diff);\n        return {\n          path: path\n        };\n      },\n      attrs: {\n        path: getSectorPath(center_1.x, center_1.y, radius_1 + margin, startAngle_1, endAngle_1)\n      }\n    };\n  }\n  var endState;\n  if (coordinate.isTransposed) {\n    endState = {\n      height: height + margin * 2\n    };\n  } else {\n    endState = {\n      width: width + margin * 2\n    };\n  }\n  return {\n    type: 'rect',\n    startState: {\n      x: start.x - margin,\n      y: end.y - margin,\n      width: coordinate.isTransposed ? width + margin * 2 : 0,\n      height: coordinate.isTransposed ? 0 : height + margin * 2\n    },\n    endState: endState,\n    attrs: {\n      x: start.x - margin,\n      y: end.y - margin,\n      width: width + margin * 2,\n      height: height + margin * 2\n    }\n  };\n}\n/**\n * 获取坐标系范围的 BBox\n * @param coordinate\n * @param margin\n */\nexport function getCoordinateBBox(coordinate, margin) {\n  if (margin === void 0) {\n    margin = 0;\n  }\n  var start = coordinate.start,\n    end = coordinate.end;\n  var width = coordinate.getWidth();\n  var height = coordinate.getHeight();\n  var minX = Math.min(start.x, end.x);\n  var minY = Math.min(start.y, end.y);\n  return BBox.fromRange(minX - margin, minY - margin, minX + width + margin, minY + height + margin);\n}","map":{"version":3,"sources":["../../src/util/coordinate.ts"],"names":[],"mappings":"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","sourcesContent":["import { Coordinate } from '../dependents';\nimport { Point } from '../interface';\nimport { getSectorPath } from './graphics';\nimport { isBetween } from './helper';\nimport { BBox } from './bbox';\n\n/**\n * @ignore\n * Gets x dimension length\n * @param coordinate\n * @returns x dimension length\n */\nexport function getXDimensionLength(coordinate): number {\n  if (coordinate.isPolar && !coordinate.isTransposed) {\n    // 极坐标系下 width 为弧长\n    return (coordinate.endAngle - coordinate.startAngle) * coordinate.getRadius();\n  }\n\n  // 直角坐标系\n  const start = coordinate.convert({ x: 0, y: 0 });\n  const end = coordinate.convert({ x: 1, y: 0 });\n  // 坐标系有可能发生 transpose 等变换，所有通过两点之间的距离进行计算\n  return Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));\n}\n\n/**\n * @ignore\n * Determines whether full circle is\n * @param coordinate\n * @returns true if full circle\n */\nexport function isFullCircle(coordinate: Coordinate): boolean {\n  if (coordinate.isPolar) {\n    const { startAngle, endAngle } = coordinate;\n    return endAngle - startAngle === Math.PI * 2;\n  }\n  return false;\n}\n\n/**\n * @ignore\n * 获取当前点到坐标系圆心的距离\n * @param coordinate 坐标系\n * @param point 当前点\n * @returns distance to center\n */\nexport function getDistanceToCenter(coordinate: Coordinate, point: Point): number {\n  const center = coordinate.getCenter() as Point;\n  return Math.sqrt((point.x - center.x) ** 2 + (point.y - center.y) ** 2);\n}\n\n/**\n * @ignore\n * 坐标点是否在坐标系中\n * @param coordinate\n * @param point\n */\nexport function isPointInCoordinate(coordinate: Coordinate, point: Point) {\n  let result = false;\n\n  if (coordinate) {\n    if (coordinate.type === 'theta') {\n      const { start, end } = coordinate;\n      result = isBetween(point.x, start.x, end.x) && isBetween(point.y, start.y, end.y);\n    } else {\n      const invertPoint = coordinate.invert(point);\n    \n      result = isBetween(invertPoint.x, 0, 1) && isBetween(invertPoint.y, 0, 1);\n    }\n  }\n\n  return result;\n}\n\n/**\n * @ignore\n * 获取点到圆心的连线与水平方向的夹角\n */\nexport function getAngleByPoint(coordinate: Coordinate, point: Point): number {\n  const center = coordinate.getCenter();\n  return Math.atan2(point.y - center.y, point.x - center.x);\n}\n\n/**\n * @ignore\n * 获取同坐标系范围相同的剪切区域\n * @param coordinate\n * @returns\n */\nexport function getCoordinateClipCfg(coordinate: Coordinate, margin: number = 0) {\n  const { start, end } = coordinate;\n  const width = coordinate.getWidth();\n  const height = coordinate.getHeight();\n\n  if (coordinate.isPolar) {\n    const { startAngle, endAngle } = coordinate;\n    const center = coordinate.getCenter();\n    const radius = coordinate.getRadius();\n\n    return {\n      type: 'path',\n      startState: {\n        path: getSectorPath(center.x, center.y, radius + margin, startAngle, startAngle),\n      },\n      endState: (ratio) => {\n        const diff = (endAngle - startAngle) * ratio + startAngle;\n        const path = getSectorPath(center.x, center.y, radius + margin, startAngle, diff);\n        return {\n          path,\n        };\n      },\n      attrs: {\n        path: getSectorPath(center.x, center.y, radius + margin, startAngle, endAngle),\n      },\n    };\n  }\n\n  let endState;\n  if (coordinate.isTransposed) {\n    endState = {\n      height: height + margin * 2,\n    };\n  } else {\n    endState = {\n      width: width + margin * 2,\n    };\n  }\n\n  return {\n    type: 'rect',\n    startState: {\n      x: start.x - margin,\n      y: end.y - margin,\n      width: coordinate.isTransposed ? width + margin * 2 : 0,\n      height: coordinate.isTransposed ? 0 : height + margin * 2,\n    },\n    endState,\n    attrs: {\n      x: start.x - margin,\n      y: end.y - margin,\n      width: width + margin * 2,\n      height: height + margin * 2,\n    },\n  };\n}\n\n/**\n * 获取坐标系范围的 BBox\n * @param coordinate\n * @param margin\n */\nexport function getCoordinateBBox(coordinate: Coordinate, margin = 0) {\n  const { start, end } = coordinate;\n  const width = coordinate.getWidth();\n  const height = coordinate.getHeight();\n  const minX = Math.min(start.x, end.x);\n  const minY = Math.min(start.y, end.y);\n\n  return BBox.fromRange(minX - margin, minY - margin, minX + width + margin, minY + height + margin);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}