{"ast":null,"code":"/**\n * @fileoverview 文本\n * @author dxq613@gmail.com\n */\nimport { __assign, __extends } from \"tslib\";\nimport ShapeBase from './base';\nimport { isNil, isString, each } from '../util/util';\nimport { getTextHeight, assembleFont } from '@antv/g-base';\nvar Text = /** @class */function (_super) {\n  __extends(Text, _super);\n  function Text() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  // 默认文本属性\n  Text.prototype.getDefaultAttrs = function () {\n    var attrs = _super.prototype.getDefaultAttrs.call(this);\n    return __assign(__assign({}, attrs), {\n      x: 0,\n      y: 0,\n      text: null,\n      fontSize: 12,\n      fontFamily: 'sans-serif',\n      fontStyle: 'normal',\n      fontWeight: 'normal',\n      fontVariant: 'normal',\n      textAlign: 'start',\n      textBaseline: 'bottom'\n    });\n  };\n  // 仅仅使用包围盒检测来进行拾取\n  Text.prototype.isOnlyHitBox = function () {\n    return true;\n  };\n  // 初始化时组合 font，同时判断 text 是否换行\n  Text.prototype.initAttrs = function (attrs) {\n    this._assembleFont();\n    if (attrs.text) {\n      this._setText(attrs.text);\n    }\n  };\n  // 组装字体\n  Text.prototype._assembleFont = function () {\n    var attrs = this.attrs;\n    attrs.font = assembleFont(attrs);\n  };\n  // 如果文本换行，则缓存数组\n  Text.prototype._setText = function (text) {\n    var textArr = null;\n    if (isString(text) && text.indexOf('\\n') !== -1) {\n      textArr = text.split('\\n');\n    }\n    this.set('textArr', textArr);\n  };\n  // 更新属性时，检测是否更改了 font、text\n  Text.prototype.onAttrChange = function (name, value, originValue) {\n    _super.prototype.onAttrChange.call(this, name, value, originValue);\n    if (name.startsWith('font')) {\n      this._assembleFont();\n    }\n    if (name === 'text') {\n      this._setText(value);\n    }\n  };\n  // 这个方法在 text 时没有可以做的事情，如果要支持文字背景时可以考虑\n  // createPath(context) {\n  // }\n  // 如果文本多行，需要获取文本间距\n  Text.prototype._getSpaceingY = function () {\n    var attrs = this.attrs;\n    var lineHeight = attrs.lineHeight;\n    var fontSize = attrs.fontSize * 1;\n    return lineHeight ? lineHeight - fontSize : fontSize * 0.14;\n  };\n  // 绘制文本，考虑多行的场景\n  Text.prototype._drawTextArr = function (context, textArr, isFill) {\n    var attrs = this.attrs;\n    var textBaseline = attrs.textBaseline;\n    var x = attrs.x;\n    var y = attrs.y;\n    var fontSize = attrs.fontSize * 1;\n    var spaceingY = this._getSpaceingY();\n    var height = getTextHeight(attrs.text, attrs.fontSize, attrs.lineHeight);\n    var subY;\n    each(textArr, function (subText, index) {\n      subY = y + index * (spaceingY + fontSize) - height + fontSize; // bottom;\n      if (textBaseline === 'middle') subY += height - fontSize - (height - fontSize) / 2;\n      if (textBaseline === 'top') subY += height - fontSize;\n      if (!isNil(subText)) {\n        if (isFill) {\n          context.fillText(subText, x, subY);\n        } else {\n          context.strokeText(subText, x, subY);\n        }\n      }\n    });\n  };\n  // 绘制文本，同时考虑填充和绘制边框\n  Text.prototype._drawText = function (context, isFill) {\n    var attrs = this.attr();\n    var x = attrs.x;\n    var y = attrs.y;\n    var textArr = this.get('textArr');\n    if (textArr) {\n      this._drawTextArr(context, textArr, isFill);\n    } else {\n      var text = attrs.text;\n      if (!isNil(text)) {\n        if (isFill) {\n          context.fillText(text, x, y);\n        } else {\n          context.strokeText(text, x, y);\n        }\n      }\n    }\n  };\n  // 复写绘制和填充的逻辑：对于文本，应该先绘制边框，再进行填充\n  Text.prototype.strokeAndFill = function (context) {\n    var _a = this.attrs,\n      lineWidth = _a.lineWidth,\n      opacity = _a.opacity,\n      strokeOpacity = _a.strokeOpacity,\n      fillOpacity = _a.fillOpacity;\n    if (this.isStroke()) {\n      if (lineWidth > 0) {\n        if (!isNil(strokeOpacity) && strokeOpacity !== 1) {\n          context.globalAlpha = opacity;\n        }\n        this.stroke(context);\n      }\n    }\n    if (this.isFill()) {\n      if (!isNil(fillOpacity) && fillOpacity !== 1) {\n        context.globalAlpha = fillOpacity;\n        this.fill(context);\n        context.globalAlpha = opacity;\n      } else {\n        this.fill(context);\n      }\n    }\n    this.afterDrawPath(context);\n  };\n  // 复写填充逻辑\n  Text.prototype.fill = function (context) {\n    this._drawText(context, true);\n  };\n  // 复写绘制边框的逻辑\n  Text.prototype.stroke = function (context) {\n    this._drawText(context, false);\n  };\n  return Text;\n}(ShapeBase);\nexport default Text;","map":{"version":3,"sources":["../../src/shape/text.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @fileoverview 文本\n * @author dxq613@gmail.com\n */\nimport { __assign, __extends } from \"tslib\";\nimport ShapeBase from './base';\nimport { isNil, isString, each } from '../util/util';\nimport { getTextHeight, assembleFont } from '@antv/g-base';\nvar Text = /** @class */ (function (_super) {\n    __extends(Text, _super);\n    function Text() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    // 默认文本属性\n    Text.prototype.getDefaultAttrs = function () {\n        var attrs = _super.prototype.getDefaultAttrs.call(this);\n        return __assign(__assign({}, attrs), { x: 0, y: 0, text: null, fontSize: 12, fontFamily: 'sans-serif', fontStyle: 'normal', fontWeight: 'normal', fontVariant: 'normal', textAlign: 'start', textBaseline: 'bottom' });\n    };\n    // 仅仅使用包围盒检测来进行拾取\n    Text.prototype.isOnlyHitBox = function () {\n        return true;\n    };\n    // 初始化时组合 font，同时判断 text 是否换行\n    Text.prototype.initAttrs = function (attrs) {\n        this._assembleFont();\n        if (attrs.text) {\n            this._setText(attrs.text);\n        }\n    };\n    // 组装字体\n    Text.prototype._assembleFont = function () {\n        var attrs = this.attrs;\n        attrs.font = assembleFont(attrs);\n    };\n    // 如果文本换行，则缓存数组\n    Text.prototype._setText = function (text) {\n        var textArr = null;\n        if (isString(text) && text.indexOf('\\n') !== -1) {\n            textArr = text.split('\\n');\n        }\n        this.set('textArr', textArr);\n    };\n    // 更新属性时，检测是否更改了 font、text\n    Text.prototype.onAttrChange = function (name, value, originValue) {\n        _super.prototype.onAttrChange.call(this, name, value, originValue);\n        if (name.startsWith('font')) {\n            this._assembleFont();\n        }\n        if (name === 'text') {\n            this._setText(value);\n        }\n    };\n    // 这个方法在 text 时没有可以做的事情，如果要支持文字背景时可以考虑\n    // createPath(context) {\n    // }\n    // 如果文本多行，需要获取文本间距\n    Text.prototype._getSpaceingY = function () {\n        var attrs = this.attrs;\n        var lineHeight = attrs.lineHeight;\n        var fontSize = attrs.fontSize * 1;\n        return lineHeight ? lineHeight - fontSize : fontSize * 0.14;\n    };\n    // 绘制文本，考虑多行的场景\n    Text.prototype._drawTextArr = function (context, textArr, isFill) {\n        var attrs = this.attrs;\n        var textBaseline = attrs.textBaseline;\n        var x = attrs.x;\n        var y = attrs.y;\n        var fontSize = attrs.fontSize * 1;\n        var spaceingY = this._getSpaceingY();\n        var height = getTextHeight(attrs.text, attrs.fontSize, attrs.lineHeight);\n        var subY;\n        each(textArr, function (subText, index) {\n            subY = y + index * (spaceingY + fontSize) - height + fontSize; // bottom;\n            if (textBaseline === 'middle')\n                subY += height - fontSize - (height - fontSize) / 2;\n            if (textBaseline === 'top')\n                subY += height - fontSize;\n            if (!isNil(subText)) {\n                if (isFill) {\n                    context.fillText(subText, x, subY);\n                }\n                else {\n                    context.strokeText(subText, x, subY);\n                }\n            }\n        });\n    };\n    // 绘制文本，同时考虑填充和绘制边框\n    Text.prototype._drawText = function (context, isFill) {\n        var attrs = this.attr();\n        var x = attrs.x;\n        var y = attrs.y;\n        var textArr = this.get('textArr');\n        if (textArr) {\n            this._drawTextArr(context, textArr, isFill);\n        }\n        else {\n            var text = attrs.text;\n            if (!isNil(text)) {\n                if (isFill) {\n                    context.fillText(text, x, y);\n                }\n                else {\n                    context.strokeText(text, x, y);\n                }\n            }\n        }\n    };\n    // 复写绘制和填充的逻辑：对于文本，应该先绘制边框，再进行填充\n    Text.prototype.strokeAndFill = function (context) {\n        var _a = this.attrs, lineWidth = _a.lineWidth, opacity = _a.opacity, strokeOpacity = _a.strokeOpacity, fillOpacity = _a.fillOpacity;\n        if (this.isStroke()) {\n            if (lineWidth > 0) {\n                if (!isNil(strokeOpacity) && strokeOpacity !== 1) {\n                    context.globalAlpha = opacity;\n                }\n                this.stroke(context);\n            }\n        }\n        if (this.isFill()) {\n            if (!isNil(fillOpacity) && fillOpacity !== 1) {\n                context.globalAlpha = fillOpacity;\n                this.fill(context);\n                context.globalAlpha = opacity;\n            }\n            else {\n                this.fill(context);\n            }\n        }\n        this.afterDrawPath(context);\n    };\n    // 复写填充逻辑\n    Text.prototype.fill = function (context) {\n        this._drawText(context, true);\n    };\n    // 复写绘制边框的逻辑\n    Text.prototype.stroke = function (context) {\n        this._drawText(context, false);\n    };\n    return Text;\n}(ShapeBase));\nexport default Text;\n//# sourceMappingURL=text.js.map"]},"metadata":{},"sourceType":"module"}