{"ast":null,"code":"import { __assign, __awaiter, __generator } from \"tslib\";\nimport { get, each } from '@antv/util';\nimport { intersect } from '../../../util/collision-detect';\nimport { getLabelBackgroundInfo } from '../util';\nimport { createWorker } from '../util/createWorker';\nimport { code as layoutCode } from './worker/hide-overlap';\nvar layout = function (items) {\n  var boxes = items.slice();\n  for (var i = 0; i < boxes.length; i++) {\n    var box1 = boxes[i];\n    if (box1.visible) {\n      for (var j = i + 1; j < boxes.length; j++) {\n        var box2 = boxes[j];\n        if (box1 !== box2 && box2.visible) {\n          if (intersect(box1, box2)) {\n            box2.visible = false;\n          }\n        }\n      }\n    }\n  }\n  return boxes;\n};\nvar cache = new Map();\nvar worker = createWorker(layoutCode);\n/**\n * label 防遮挡布局：在不改变 label 位置的情况下对相互重叠的 label 进行隐藏（非移除）\n * 不同于 'overlap' 类型的布局，该布局不会对 label 的位置进行偏移调整。\n * @param labels 参与布局调整的 label 数组集合\n */\nexport function hideOverlap(labelItems, labels, shapes, region) {\n  return __awaiter(this, void 0, void 0, function () {\n    var boxes, memoKey, cb, params, res, e_1;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          boxes = labels.map(function (d, idx) {\n            return __assign(__assign({}, getLabelBackgroundInfo(d, labelItems[idx], get(labelItems[idx], 'background.padding'))), {\n              visible: true\n            });\n          });\n          memoKey = JSON.stringify(boxes);\n          cb = function (items) {\n            cache.set(memoKey, items);\n            each(items, function (_a, idx) {\n              var visible = _a.visible;\n              var labelShape = labels[idx];\n              if (visible) {\n                labelShape === null || labelShape === void 0 ? void 0 : labelShape.show();\n              } else {\n                labelShape === null || labelShape === void 0 ? void 0 : labelShape.hide();\n              }\n            });\n            return items;\n          };\n          if (!cache.get(memoKey)) return [3 /*break*/, 1];\n          cb(cache.get(memoKey));\n          return [3 /*break*/, 7];\n        case 1:\n          if (!worker) return [3 /*break*/, 6];\n          _a.label = 2;\n        case 2:\n          _a.trys.push([2, 4,, 5]);\n          params = JSON.stringify({\n            type: 'hide-overlap',\n            items: boxes\n          });\n          return [4 /*yield*/, worker.post(params, function () {\n            return cb(layout(boxes));\n          })];\n        case 3:\n          res = _a.sent();\n          cb(Array.isArray(res.data) ? res.data : []);\n          return [3 /*break*/, 5];\n        case 4:\n          e_1 = _a.sent();\n          console.error(e_1);\n          cb(layout(boxes));\n          return [3 /*break*/, 5];\n        case 5:\n          return [3 /*break*/, 7];\n        case 6:\n          // Normal layout in main thread.\n          cb(layout(boxes));\n          _a.label = 7;\n        case 7:\n          return [2 /*return*/];\n      }\n    });\n  });\n}","map":{"version":3,"sources":["../../../../src/geometry/label/layout/hide-overlap.ts"],"names":[],"mappings":"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","sourcesContent":["import { get, each } from '@antv/util';\nimport { BBox, IGroup, IShape } from '../../../dependents';\nimport { intersect } from '../../../util/collision-detect';\nimport { LabelItem } from '../interface';\nimport { getLabelBackgroundInfo } from '../util';\nimport { createWorker } from '../util/createWorker';\nimport { code as layoutCode } from './worker/hide-overlap';\n\ntype Item = {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  rotation?: number;\n  visible?: boolean;\n};\n\nconst layout = (items: Item[]): Item[] => {\n  const boxes = items.slice();\n  for (let i = 0; i < boxes.length; i++) {\n    const box1 = boxes[i];\n    if (box1.visible) {\n      for (let j = i + 1; j < boxes.length; j++) {\n        const box2 = boxes[j];\n        if (box1 !== box2 && box2.visible) {\n          if (intersect(box1, box2)) {\n            box2.visible = false;\n          }\n        }\n      }\n    }\n  }\n  return boxes;\n};\n\nconst cache: Map<string, any> = new Map();\nconst worker = createWorker(layoutCode);\n\n/**\n * label 防遮挡布局：在不改变 label 位置的情况下对相互重叠的 label 进行隐藏（非移除）\n * 不同于 'overlap' 类型的布局，该布局不会对 label 的位置进行偏移调整。\n * @param labels 参与布局调整的 label 数组集合\n */\nexport async function hideOverlap(\n  labelItems: LabelItem[],\n  labels: IGroup[],\n  shapes: IShape[] | IGroup[],\n  region: BBox\n) {\n  const boxes = labels.map((d, idx) => ({\n    ...getLabelBackgroundInfo(d, labelItems[idx], get(labelItems[idx], 'background.padding')),\n    visible: true,\n  }));\n  const memoKey = JSON.stringify(boxes);\n  const cb = (items: Item[]) => {\n    cache.set(memoKey, items);\n    each(items, ({ visible }, idx) => {\n      const labelShape = labels[idx];\n      if (visible) {\n        labelShape?.show();\n      } else {\n        labelShape?.hide();\n      }\n    });\n    return items;\n  };\n  if (cache.get(memoKey)) {\n    cb(cache.get(memoKey));\n  } else if (worker) {\n    // Do layout in worker.\n    try {\n      const params = JSON.stringify({ type: 'hide-overlap', items: boxes });\n      const res = await worker.post(params, () => cb(layout(boxes)));\n      cb(Array.isArray(res.data) ? res.data : []);\n    } catch (e) {\n      console.error(e);\n      cb(layout(boxes));\n    }\n  } else {\n    // Normal layout in main thread.\n    cb(layout(boxes));\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}