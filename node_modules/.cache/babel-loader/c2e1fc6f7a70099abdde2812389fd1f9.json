{"ast":null,"code":"import { each, isNil } from '@antv/util';\n// 求以a为次幂，结果为b的基数，如 x^^a = b;求x\n// 虽然数学上 b 不支持负数，但是这里需要支持 负数\nexport function calBase(a, b) {\n  var e = Math.E;\n  var value;\n  if (b >= 0) {\n    value = Math.pow(e, Math.log(b) / a); // 使用换底公式求底\n  } else {\n    value = Math.pow(e, Math.log(-b) / a) * -1; // 使用换底公式求底\n  }\n\n  return value;\n}\nexport function log(a, b) {\n  if (a === 1) {\n    return 1;\n  }\n  return Math.log(b) / Math.log(a);\n}\nexport function getLogPositiveMin(values, base, max) {\n  if (isNil(max)) {\n    max = Math.max.apply(null, values);\n  }\n  var positiveMin = max;\n  each(values, function (value) {\n    if (value > 0 && value < positiveMin) {\n      positiveMin = value;\n    }\n  });\n  if (positiveMin === max) {\n    positiveMin = max / base;\n  }\n  if (positiveMin > 1) {\n    positiveMin = 1;\n  }\n  return positiveMin;\n}\nfunction digitLength(num) {\n  // Get digit length of e\n  var eSplit = num.toString().split(/[eE]/);\n  var len = (eSplit[0].split('.')[1] || '').length - +(eSplit[1] || 0);\n  return len > 0 ? len : 0;\n}\n/**\n * 高精度加法，解决 0.1 + 0.2 !== 0.3 的经典问题\n *\n * @param num1 加数\n * @param num2 被加数\n * @return {number} 返回值\n */\nexport function precisionAdd(num1, num2) {\n  var num1Digits = digitLength(num1);\n  var num2Digits = digitLength(num2);\n  var baseNum = Math.pow(10, Math.max(num1Digits, num2Digits));\n  return (num1 * baseNum + num2 * baseNum) / baseNum;\n}","map":{"version":3,"sources":["../../src/util/math.ts"],"names":[],"mappings":"AAAA,SAAS,IAAI,EAAE,KAAK,QAAQ,YAAY;AAExC;AACA;AACA,OAAM,SAAU,OAAO,CAAC,CAAS,EAAE,CAAS,EAAA;EAC1C,IAAM,CAAC,GAAG,IAAI,CAAC,CAAC;EAChB,IAAI,KAAK;EACT,IAAI,CAAC,IAAI,CAAC,EAAE;IACV,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;GACvC,MAAM;IACL,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;EAC7C;;EACD,OAAO,KAAK;AACd;AAEA,OAAM,SAAU,GAAG,CAAC,CAAS,EAAE,CAAS,EAAA;EACtC,IAAI,CAAC,KAAK,CAAC,EAAE;IACX,OAAO,CAAC;EACT;EACD,OAAO,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;AAClC;AAEA,OAAM,SAAU,iBAAiB,CAAC,MAAM,EAAE,IAAI,EAAE,GAAY,EAAA;EAC1D,IAAI,KAAK,CAAC,GAAG,CAAC,EAAE;IACd,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,EAAE,MAAM,CAAC;EACnC;EACD,IAAI,WAAW,GAAG,GAAG;EACrB,IAAI,CAAC,MAAM,EAAE,UAAC,KAAK,EAAA;IACjB,IAAI,KAAK,GAAG,CAAC,IAAI,KAAK,GAAG,WAAW,EAAE;MACpC,WAAW,GAAG,KAAK;IACpB;EACH,CAAC,CAAC;EACF,IAAI,WAAW,KAAK,GAAG,EAAE;IACvB,WAAW,GAAG,GAAG,GAAG,IAAI;EACzB;EACD,IAAI,WAAW,GAAG,CAAC,EAAE;IACnB,WAAW,GAAG,CAAC;EAChB;EACD,OAAO,WAAW;AACpB;AAEA,SAAS,WAAW,CAAC,GAAW,EAAA;EAC9B;EACA,IAAM,MAAM,GAAG,GAAG,CAAC,QAAQ,EAAE,CAAC,KAAK,CAAC,MAAM,CAAC;EAC3C,IAAM,GAAG,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,EAAE,MAAM,GAAG,EAAE,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;EACtE,OAAO,GAAG,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC;AAC1B;AAEA;;;;;;AAMG;AACH,OAAM,SAAU,YAAY,CAAC,IAAY,EAAE,IAAY,EAAA;EACrD,IAAM,UAAU,GAAG,WAAW,CAAC,IAAI,CAAC;EACpC,IAAM,UAAU,GAAG,WAAW,CAAC,IAAI,CAAC;EACpC,IAAM,OAAO,GAAG,IAAA,CAAA,GAAA,CAAA,EAAE,EAAI,IAAI,CAAC,GAAG,CAAC,UAAU,EAAE,UAAU,CAAC,CAAA;EACtD,OAAO,CAAC,IAAI,GAAG,OAAO,GAAG,IAAI,GAAG,OAAO,IAAI,OAAO;AACpD","sourceRoot":"","sourcesContent":["import { each, isNil } from '@antv/util';\n// 求以a为次幂，结果为b的基数，如 x^^a = b;求x\n// 虽然数学上 b 不支持负数，但是这里需要支持 负数\nexport function calBase(a, b) {\n    var e = Math.E;\n    var value;\n    if (b >= 0) {\n        value = Math.pow(e, Math.log(b) / a); // 使用换底公式求底\n    }\n    else {\n        value = Math.pow(e, Math.log(-b) / a) * -1; // 使用换底公式求底\n    }\n    return value;\n}\nexport function log(a, b) {\n    if (a === 1) {\n        return 1;\n    }\n    return Math.log(b) / Math.log(a);\n}\nexport function getLogPositiveMin(values, base, max) {\n    if (isNil(max)) {\n        max = Math.max.apply(null, values);\n    }\n    var positiveMin = max;\n    each(values, function (value) {\n        if (value > 0 && value < positiveMin) {\n            positiveMin = value;\n        }\n    });\n    if (positiveMin === max) {\n        positiveMin = max / base;\n    }\n    if (positiveMin > 1) {\n        positiveMin = 1;\n    }\n    return positiveMin;\n}\nfunction digitLength(num) {\n    // Get digit length of e\n    var eSplit = num.toString().split(/[eE]/);\n    var len = (eSplit[0].split('.')[1] || '').length - +(eSplit[1] || 0);\n    return len > 0 ? len : 0;\n}\n/**\n * 高精度加法，解决 0.1 + 0.2 !== 0.3 的经典问题\n *\n * @param num1 加数\n * @param num2 被加数\n * @return {number} 返回值\n */\nexport function precisionAdd(num1, num2) {\n    var num1Digits = digitLength(num1);\n    var num2Digits = digitLength(num2);\n    var baseNum = Math.pow(10, Math.max(num1Digits, num2Digits));\n    return (num1 * baseNum + num2 * baseNum) / baseNum;\n}\n//# sourceMappingURL=math.js.map"]},"metadata":{},"sourceType":"module"}