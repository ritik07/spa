{"ast":null,"code":"export default function d3Linear(cfg) {\n  var min = cfg.min,\n    max = cfg.max,\n    nice = cfg.nice,\n    tickCount = cfg.tickCount;\n  var linear = new D3Linear();\n  linear.domain([min, max]);\n  if (nice) {\n    linear.nice(tickCount);\n  }\n  return linear.ticks(tickCount);\n}\nvar DEFAULT_COUNT = 5;\nvar e10 = Math.sqrt(50);\nvar e5 = Math.sqrt(10);\nvar e2 = Math.sqrt(2);\n// https://github.com/d3/d3-scale\nvar D3Linear = /** @class */function () {\n  function D3Linear() {\n    this._domain = [0, 1];\n  }\n  D3Linear.prototype.domain = function (domain) {\n    if (domain) {\n      this._domain = Array.from(domain, Number);\n      return this;\n    }\n    return this._domain.slice();\n  };\n  D3Linear.prototype.nice = function (count) {\n    var _a, _b;\n    if (count === void 0) {\n      count = DEFAULT_COUNT;\n    }\n    var d = this._domain.slice();\n    var i0 = 0;\n    var i1 = this._domain.length - 1;\n    var start = this._domain[i0];\n    var stop = this._domain[i1];\n    var step;\n    if (stop < start) {\n      _a = [stop, start], start = _a[0], stop = _a[1];\n      _b = [i1, i0], i0 = _b[0], i1 = _b[1];\n    }\n    step = tickIncrement(start, stop, count);\n    if (step > 0) {\n      start = Math.floor(start / step) * step;\n      stop = Math.ceil(stop / step) * step;\n      step = tickIncrement(start, stop, count);\n    } else if (step < 0) {\n      start = Math.ceil(start * step) / step;\n      stop = Math.floor(stop * step) / step;\n      step = tickIncrement(start, stop, count);\n    }\n    if (step > 0) {\n      d[i0] = Math.floor(start / step) * step;\n      d[i1] = Math.ceil(stop / step) * step;\n      this.domain(d);\n    } else if (step < 0) {\n      d[i0] = Math.ceil(start * step) / step;\n      d[i1] = Math.floor(stop * step) / step;\n      this.domain(d);\n    }\n    return this;\n  };\n  D3Linear.prototype.ticks = function (count) {\n    if (count === void 0) {\n      count = DEFAULT_COUNT;\n    }\n    return d3ArrayTicks(this._domain[0], this._domain[this._domain.length - 1], count || DEFAULT_COUNT);\n  };\n  return D3Linear;\n}();\nexport { D3Linear };\nfunction d3ArrayTicks(start, stop, count) {\n  var reverse;\n  var i = -1;\n  var n;\n  var ticks;\n  var step;\n  stop = +stop, start = +start, count = +count;\n  if (start === stop && count > 0) {\n    return [start];\n  }\n  // tslint:disable-next-line\n  if (reverse = stop < start) {\n    n = start, start = stop, stop = n;\n  }\n  // tslint:disable-next-line\n  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) {\n    return [];\n  }\n  if (step > 0) {\n    start = Math.ceil(start / step);\n    stop = Math.floor(stop / step);\n    ticks = new Array(n = Math.ceil(stop - start + 1));\n    while (++i < n) {\n      ticks[i] = (start + i) * step;\n    }\n  } else {\n    start = Math.floor(start * step);\n    stop = Math.ceil(stop * step);\n    ticks = new Array(n = Math.ceil(start - stop + 1));\n    while (++i < n) {\n      ticks[i] = (start - i) / step;\n    }\n  }\n  if (reverse) {\n    ticks.reverse();\n  }\n  return ticks;\n}\nfunction tickIncrement(start, stop, count) {\n  var step = (stop - start) / Math.max(0, count);\n  var power = Math.floor(Math.log(step) / Math.LN10);\n  var error = step / Math.pow(10, power);\n  return power >= 0 ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);\n}","map":{"version":3,"sources":["../../src/util/d3-linear.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["export default function d3Linear(cfg) {\n    var min = cfg.min, max = cfg.max, nice = cfg.nice, tickCount = cfg.tickCount;\n    var linear = new D3Linear();\n    linear.domain([min, max]);\n    if (nice) {\n        linear.nice(tickCount);\n    }\n    return linear.ticks(tickCount);\n}\nvar DEFAULT_COUNT = 5;\nvar e10 = Math.sqrt(50);\nvar e5 = Math.sqrt(10);\nvar e2 = Math.sqrt(2);\n// https://github.com/d3/d3-scale\nvar D3Linear = /** @class */ (function () {\n    function D3Linear() {\n        this._domain = [0, 1];\n    }\n    D3Linear.prototype.domain = function (domain) {\n        if (domain) {\n            this._domain = Array.from(domain, Number);\n            return this;\n        }\n        return this._domain.slice();\n    };\n    D3Linear.prototype.nice = function (count) {\n        var _a, _b;\n        if (count === void 0) { count = DEFAULT_COUNT; }\n        var d = this._domain.slice();\n        var i0 = 0;\n        var i1 = this._domain.length - 1;\n        var start = this._domain[i0];\n        var stop = this._domain[i1];\n        var step;\n        if (stop < start) {\n            _a = [stop, start], start = _a[0], stop = _a[1];\n            _b = [i1, i0], i0 = _b[0], i1 = _b[1];\n        }\n        step = tickIncrement(start, stop, count);\n        if (step > 0) {\n            start = Math.floor(start / step) * step;\n            stop = Math.ceil(stop / step) * step;\n            step = tickIncrement(start, stop, count);\n        }\n        else if (step < 0) {\n            start = Math.ceil(start * step) / step;\n            stop = Math.floor(stop * step) / step;\n            step = tickIncrement(start, stop, count);\n        }\n        if (step > 0) {\n            d[i0] = Math.floor(start / step) * step;\n            d[i1] = Math.ceil(stop / step) * step;\n            this.domain(d);\n        }\n        else if (step < 0) {\n            d[i0] = Math.ceil(start * step) / step;\n            d[i1] = Math.floor(stop * step) / step;\n            this.domain(d);\n        }\n        return this;\n    };\n    D3Linear.prototype.ticks = function (count) {\n        if (count === void 0) { count = DEFAULT_COUNT; }\n        return d3ArrayTicks(this._domain[0], this._domain[this._domain.length - 1], count || DEFAULT_COUNT);\n    };\n    return D3Linear;\n}());\nexport { D3Linear };\nfunction d3ArrayTicks(start, stop, count) {\n    var reverse;\n    var i = -1;\n    var n;\n    var ticks;\n    var step;\n    (stop = +stop), (start = +start), (count = +count);\n    if (start === stop && count > 0) {\n        return [start];\n    }\n    // tslint:disable-next-line\n    if ((reverse = stop < start)) {\n        (n = start), (start = stop), (stop = n);\n    }\n    // tslint:disable-next-line\n    if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) {\n        return [];\n    }\n    if (step > 0) {\n        start = Math.ceil(start / step);\n        stop = Math.floor(stop / step);\n        ticks = new Array((n = Math.ceil(stop - start + 1)));\n        while (++i < n) {\n            ticks[i] = (start + i) * step;\n        }\n    }\n    else {\n        start = Math.floor(start * step);\n        stop = Math.ceil(stop * step);\n        ticks = new Array((n = Math.ceil(start - stop + 1)));\n        while (++i < n) {\n            ticks[i] = (start - i) / step;\n        }\n    }\n    if (reverse) {\n        ticks.reverse();\n    }\n    return ticks;\n}\nfunction tickIncrement(start, stop, count) {\n    var step = (stop - start) / Math.max(0, count);\n    var power = Math.floor(Math.log(step) / Math.LN10);\n    var error = step / Math.pow(10, power);\n    return power >= 0\n        ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)\n        : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);\n}\n//# sourceMappingURL=d3-linear.js.map"]},"metadata":{},"sourceType":"module"}