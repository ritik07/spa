{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { each } from '@antv/util';\nimport GridBase from './base';\nfunction distance(x1, y1, x2, y2) {\n  var dx = x2 - x1;\n  var dy = y2 - y1;\n  return Math.sqrt(dx * dx + dy * dy);\n}\nvar Circle = /** @class */function (_super) {\n  __extends(Circle, _super);\n  function Circle() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  Circle.prototype.getDefaultCfg = function () {\n    var cfg = _super.prototype.getDefaultCfg.call(this);\n    return __assign(__assign({}, cfg), {\n      type: 'circle',\n      /**\n       * 中心点\n       * @type {object}\n       */\n      center: null,\n      /**\n       * 栅格线是否封闭\n       * @type {true}\n       */\n      closed: true\n    });\n  };\n  Circle.prototype.getGridPath = function (points, reversed) {\n    var lineType = this.getLineType();\n    var closed = this.get('closed');\n    var path = [];\n    if (points.length) {\n      // 防止出错\n      if (lineType === 'circle') {\n        var center = this.get('center');\n        var firstPoint = points[0];\n        var radius_1 = distance(center.x, center.y, firstPoint.x, firstPoint.y);\n        var sweepFlag_1 = reversed ? 0 : 1; // 顺时针还是逆时针\n        if (closed) {\n          // 封闭时，绘制整个圆\n          path.push(['M', center.x, center.y - radius_1]);\n          path.push(['A', radius_1, radius_1, 0, 0, sweepFlag_1, center.x, center.y + radius_1]);\n          path.push(['A', radius_1, radius_1, 0, 0, sweepFlag_1, center.x, center.y - radius_1]);\n          path.push(['Z']);\n        } else {\n          each(points, function (point, index) {\n            if (index === 0) {\n              path.push(['M', point.x, point.y]);\n            } else {\n              path.push(['A', radius_1, radius_1, 0, 0, sweepFlag_1, point.x, point.y]);\n            }\n          });\n        }\n      } else {\n        each(points, function (point, index) {\n          if (index === 0) {\n            path.push(['M', point.x, point.y]);\n          } else {\n            path.push(['L', point.x, point.y]);\n          }\n        });\n        if (closed) {\n          path.push(['Z']);\n        }\n      }\n    }\n    return path;\n  };\n  return Circle;\n}(GridBase);\nexport default Circle;","map":{"version":3,"sources":["../../src/grid/circle.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __assign, __extends } from \"tslib\";\nimport { each } from '@antv/util';\nimport GridBase from './base';\nfunction distance(x1, y1, x2, y2) {\n    var dx = x2 - x1;\n    var dy = y2 - y1;\n    return Math.sqrt(dx * dx + dy * dy);\n}\nvar Circle = /** @class */ (function (_super) {\n    __extends(Circle, _super);\n    function Circle() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Circle.prototype.getDefaultCfg = function () {\n        var cfg = _super.prototype.getDefaultCfg.call(this);\n        return __assign(__assign({}, cfg), { type: 'circle', \n            /**\n             * 中心点\n             * @type {object}\n             */\n            center: null, \n            /**\n             * 栅格线是否封闭\n             * @type {true}\n             */\n            closed: true });\n    };\n    Circle.prototype.getGridPath = function (points, reversed) {\n        var lineType = this.getLineType();\n        var closed = this.get('closed');\n        var path = [];\n        if (points.length) {\n            // 防止出错\n            if (lineType === 'circle') {\n                var center = this.get('center');\n                var firstPoint = points[0];\n                var radius_1 = distance(center.x, center.y, firstPoint.x, firstPoint.y);\n                var sweepFlag_1 = reversed ? 0 : 1; // 顺时针还是逆时针\n                if (closed) {\n                    // 封闭时，绘制整个圆\n                    path.push(['M', center.x, center.y - radius_1]);\n                    path.push(['A', radius_1, radius_1, 0, 0, sweepFlag_1, center.x, center.y + radius_1]);\n                    path.push(['A', radius_1, radius_1, 0, 0, sweepFlag_1, center.x, center.y - radius_1]);\n                    path.push(['Z']);\n                }\n                else {\n                    each(points, function (point, index) {\n                        if (index === 0) {\n                            path.push(['M', point.x, point.y]);\n                        }\n                        else {\n                            path.push(['A', radius_1, radius_1, 0, 0, sweepFlag_1, point.x, point.y]);\n                        }\n                    });\n                }\n            }\n            else {\n                each(points, function (point, index) {\n                    if (index === 0) {\n                        path.push(['M', point.x, point.y]);\n                    }\n                    else {\n                        path.push(['L', point.x, point.y]);\n                    }\n                });\n                if (closed) {\n                    path.push(['Z']);\n                }\n            }\n        }\n        return path;\n    };\n    return Circle;\n}(GridBase));\nexport default Circle;\n//# sourceMappingURL=circle.js.map"]},"metadata":{},"sourceType":"module"}