{"ast":null,"code":"/**\n * @fileoverview 矩形\n * @author dxq613@gmail.com\n */\nimport { __assign, __extends } from \"tslib\";\nimport ShapeBase from './base';\nimport { parseRadius } from '../util/parse';\nimport { inBox } from '../util/util';\nimport inRect from '../util/in-stroke/rect';\nimport inRectWithRadius from '../util/in-stroke/rect-radius';\nimport isPointInPath from '../util/in-path/point-in-path';\nvar Rect = /** @class */function (_super) {\n  __extends(Rect, _super);\n  function Rect() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  Rect.prototype.getDefaultAttrs = function () {\n    var attrs = _super.prototype.getDefaultAttrs.call(this);\n    return __assign(__assign({}, attrs), {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0,\n      radius: 0\n    });\n  };\n  Rect.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {\n    var attrs = this.attr();\n    var minX = attrs.x;\n    var minY = attrs.y;\n    var width = attrs.width;\n    var height = attrs.height;\n    var radius = attrs.radius;\n    // 无圆角时的策略\n    if (!radius) {\n      var halfWidth = lineWidth / 2;\n      // 同时填充和带有边框\n      if (isFill && isStroke) {\n        return inBox(minX - halfWidth, minY - halfWidth, width + halfWidth, height + halfWidth, x, y);\n      }\n      // 仅填充\n      if (isFill) {\n        return inBox(minX, minY, width, height, x, y);\n      }\n      if (isStroke) {\n        return inRect(minX, minY, width, height, lineWidth, x, y);\n      }\n    } else {\n      var isHit = false;\n      if (isStroke) {\n        isHit = inRectWithRadius(minX, minY, width, height, radius, lineWidth, x, y);\n      }\n      // 仅填充时带有圆角的矩形直接通过图形拾取\n      // 以后可以改成纯数学的近似拾取，将圆弧切割成多边形\n      if (!isHit && isFill) {\n        isHit = isPointInPath(this, x, y);\n      }\n      return isHit;\n    }\n  };\n  Rect.prototype.createPath = function (context) {\n    var attrs = this.attr();\n    var x = attrs.x;\n    var y = attrs.y;\n    var width = attrs.width;\n    var height = attrs.height;\n    var radius = attrs.radius;\n    context.beginPath();\n    if (radius === 0) {\n      // 改成原生的rect方法\n      context.rect(x, y, width, height);\n    } else {\n      var _a = parseRadius(radius),\n        r1 = _a[0],\n        r2 = _a[1],\n        r3 = _a[2],\n        r4 = _a[3];\n      context.moveTo(x + r1, y);\n      context.lineTo(x + width - r2, y);\n      r2 !== 0 && context.arc(x + width - r2, y + r2, r2, -Math.PI / 2, 0);\n      context.lineTo(x + width, y + height - r3);\n      r3 !== 0 && context.arc(x + width - r3, y + height - r3, r3, 0, Math.PI / 2);\n      context.lineTo(x + r4, y + height);\n      r4 !== 0 && context.arc(x + r4, y + height - r4, r4, Math.PI / 2, Math.PI);\n      context.lineTo(x, y + r1);\n      r1 !== 0 && context.arc(x + r1, y + r1, r1, Math.PI, Math.PI * 1.5);\n      context.closePath();\n    }\n  };\n  return Rect;\n}(ShapeBase);\nexport default Rect;","map":{"version":3,"sources":["../../src/shape/rect.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @fileoverview 矩形\n * @author dxq613@gmail.com\n */\nimport { __assign, __extends } from \"tslib\";\nimport ShapeBase from './base';\nimport { parseRadius } from '../util/parse';\nimport { inBox } from '../util/util';\nimport inRect from '../util/in-stroke/rect';\nimport inRectWithRadius from '../util/in-stroke/rect-radius';\nimport isPointInPath from '../util/in-path/point-in-path';\nvar Rect = /** @class */ (function (_super) {\n    __extends(Rect, _super);\n    function Rect() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rect.prototype.getDefaultAttrs = function () {\n        var attrs = _super.prototype.getDefaultAttrs.call(this);\n        return __assign(__assign({}, attrs), { x: 0, y: 0, width: 0, height: 0, radius: 0 });\n    };\n    Rect.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {\n        var attrs = this.attr();\n        var minX = attrs.x;\n        var minY = attrs.y;\n        var width = attrs.width;\n        var height = attrs.height;\n        var radius = attrs.radius;\n        // 无圆角时的策略\n        if (!radius) {\n            var halfWidth = lineWidth / 2;\n            // 同时填充和带有边框\n            if (isFill && isStroke) {\n                return inBox(minX - halfWidth, minY - halfWidth, width + halfWidth, height + halfWidth, x, y);\n            }\n            // 仅填充\n            if (isFill) {\n                return inBox(minX, minY, width, height, x, y);\n            }\n            if (isStroke) {\n                return inRect(minX, minY, width, height, lineWidth, x, y);\n            }\n        }\n        else {\n            var isHit = false;\n            if (isStroke) {\n                isHit = inRectWithRadius(minX, minY, width, height, radius, lineWidth, x, y);\n            }\n            // 仅填充时带有圆角的矩形直接通过图形拾取\n            // 以后可以改成纯数学的近似拾取，将圆弧切割成多边形\n            if (!isHit && isFill) {\n                isHit = isPointInPath(this, x, y);\n            }\n            return isHit;\n        }\n    };\n    Rect.prototype.createPath = function (context) {\n        var attrs = this.attr();\n        var x = attrs.x;\n        var y = attrs.y;\n        var width = attrs.width;\n        var height = attrs.height;\n        var radius = attrs.radius;\n        context.beginPath();\n        if (radius === 0) {\n            // 改成原生的rect方法\n            context.rect(x, y, width, height);\n        }\n        else {\n            var _a = parseRadius(radius), r1 = _a[0], r2 = _a[1], r3 = _a[2], r4 = _a[3];\n            context.moveTo(x + r1, y);\n            context.lineTo(x + width - r2, y);\n            r2 !== 0 && context.arc(x + width - r2, y + r2, r2, -Math.PI / 2, 0);\n            context.lineTo(x + width, y + height - r3);\n            r3 !== 0 && context.arc(x + width - r3, y + height - r3, r3, 0, Math.PI / 2);\n            context.lineTo(x + r4, y + height);\n            r4 !== 0 && context.arc(x + r4, y + height - r4, r4, Math.PI / 2, Math.PI);\n            context.lineTo(x, y + r1);\n            r1 !== 0 && context.arc(x + r1, y + r1, r1, Math.PI, Math.PI * 1.5);\n            context.closePath();\n        }\n    };\n    return Rect;\n}(ShapeBase));\nexport default Rect;\n//# sourceMappingURL=rect.js.map"]},"metadata":{},"sourceType":"module"}