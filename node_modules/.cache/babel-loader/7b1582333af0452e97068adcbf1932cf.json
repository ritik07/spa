{"ast":null,"code":"import { __extends, __read } from \"tslib\";\nimport { deepMix, each, find, get, head, isBoolean, last } from '@antv/util';\nimport { COMPONENT_MAX_VIEW_PERCENTAGE, COMPONENT_TYPE, DIRECTION, LAYER } from '../../constant';\nimport { CategoryLegend, ContinuousLegend } from '../../dependents';\nimport { DEFAULT_ANIMATE_CFG } from '../../animate';\nimport { BBox } from '../../util/bbox';\nimport { directionToPosition } from '../../util/direction';\nimport { omit } from '../../util/helper';\nimport { getCustomLegendItems, getLegendItems, getLegendLayout, getLegendThemeCfg } from '../../util/legend';\nimport { getName } from '../../util/scale';\nimport { Controller } from './base';\n/**\n * 从配置中获取单个字段的 legend 配置\n * @param legends\n * @param field\n * @returns the option of one legend field\n */\nfunction getLegendOption(legends, field) {\n  if (isBoolean(legends)) {\n    return legends === false ? false : {};\n  }\n  return get(legends, [field], legends);\n}\nfunction getDirection(legendOption) {\n  return get(legendOption, 'position', DIRECTION.BOTTOM);\n}\n/**\n * @ignore\n * legend Controller\n */\nvar Legend = /** @class */function (_super) {\n  __extends(Legend, _super);\n  function Legend(view) {\n    var _this = _super.call(this, view) || this;\n    _this.container = _this.view.getLayer(LAYER.FORE).addGroup();\n    return _this;\n  }\n  Object.defineProperty(Legend.prototype, \"name\", {\n    get: function () {\n      return 'legend';\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Legend.prototype.init = function () {};\n  /**\n   * render the legend component by legend options\n   */\n  Legend.prototype.render = function () {\n    // 和 update 逻辑保持一致\n    this.update();\n  };\n  /**\n   * layout legend\n   * 计算出 legend 的 direction 位置 x, y\n   */\n  Legend.prototype.layout = function () {\n    var _this = this;\n    this.layoutBBox = this.view.viewBBox;\n    each(this.components, function (co) {\n      var component = co.component,\n        direction = co.direction;\n      var layout = getLegendLayout(direction);\n      var maxWidthRatio = component.get('maxWidthRatio');\n      var maxHeightRatio = component.get('maxHeightRatio');\n      var maxSize = _this.getCategoryLegendSizeCfg(layout, maxWidthRatio, maxHeightRatio);\n      var maxWidth = component.get('maxWidth');\n      var maxHeight = component.get('maxHeight');\n      // 先更新 maxSize，更新 layoutBBox，以便计算正确的 x y\n      component.update({\n        maxWidth: Math.min(maxSize.maxWidth, maxWidth || 0),\n        maxHeight: Math.min(maxSize.maxHeight, maxHeight || 0)\n      });\n      var padding = component.get('padding');\n      var bboxObject = component.getLayoutBBox(); // 这里只需要他的 width、height 信息做位置调整\n      var bbox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height).expand(padding);\n      var _a = __read(directionToPosition(_this.view.viewBBox, bbox, direction), 2),\n        x1 = _a[0],\n        y1 = _a[1];\n      var _b = __read(directionToPosition(_this.layoutBBox, bbox, direction), 2),\n        x2 = _b[0],\n        y2 = _b[1];\n      var x = 0;\n      var y = 0;\n      // 因为 legend x y 要和 coordinateBBox 对齐，所以要做一个简单的判断\n      if (direction.startsWith('top') || direction.startsWith('bottom')) {\n        x = x1;\n        y = y2;\n      } else {\n        x = x2;\n        y = y1;\n      }\n      // 更新位置\n      component.setLocation({\n        x: x + padding[3],\n        y: y + padding[0]\n      });\n      _this.layoutBBox = _this.layoutBBox.cut(bbox, direction);\n    });\n  };\n  /**\n   * legend 的更新逻辑\n   */\n  Legend.prototype.update = function () {\n    var _this = this;\n    this.option = this.view.getOptions().legends;\n    // 已经处理过的 legend\n    var updated = {};\n    var eachLegend = function (geometry, attr, scale) {\n      var id = _this.getId(scale.field);\n      var existCo = _this.getComponentById(id);\n      // 存在则 update\n      if (existCo) {\n        var cfg = void 0;\n        var legendOption = getLegendOption(_this.option, scale.field);\n        // if the legend option is not false, means legend should be created.\n        if (legendOption !== false) {\n          if (get(legendOption, 'custom')) {\n            cfg = _this.getCategoryCfg(geometry, attr, scale, legendOption, true);\n          } else {\n            if (scale.isLinear) {\n              // linear field, create continuous legend\n              cfg = _this.getContinuousCfg(geometry, attr, scale, legendOption);\n            } else if (scale.isCategory) {\n              // category field, create category legend\n              cfg = _this.getCategoryCfg(geometry, attr, scale, legendOption);\n            }\n          }\n        }\n        // 如果 cfg 为空，则不在 updated 标记，那么会在后面逻辑中删除\n        if (cfg) {\n          // omit 掉一些属性，比如 container 等\n          omit(cfg, ['container']);\n          existCo.direction = getDirection(legendOption);\n          existCo.component.update(cfg);\n          // 标记为新的\n          updated[id] = true;\n        }\n      } else {\n        // 不存在则 create\n        var legend = _this.createFieldLegend(geometry, attr, scale);\n        if (legend) {\n          legend.component.init();\n          _this.components.push(legend);\n          // 标记为新的\n          updated[id] = true;\n        }\n      }\n    };\n    // 全局自定义图例\n    if (get(this.option, 'custom')) {\n      var id = 'global-custom';\n      var existCo = this.getComponentById(id);\n      if (existCo) {\n        var customCfg = this.getCategoryCfg(undefined, undefined, undefined, this.option, true);\n        omit(customCfg, ['container']);\n        existCo.component.update(customCfg);\n        updated[id] = true;\n      } else {\n        var component = this.createCustomLegend(undefined, undefined, undefined, this.option);\n        if (component) {\n          component.init();\n          var layer = LAYER.FORE;\n          var direction = getDirection(this.option);\n          this.components.push({\n            id: id,\n            component: component,\n            layer: layer,\n            direction: direction,\n            type: COMPONENT_TYPE.LEGEND,\n            extra: undefined\n          });\n          // 标记为更新\n          updated[id] = true;\n        }\n      }\n    } else {\n      // 遍历处理每一个创建逻辑\n      this.loopLegends(eachLegend);\n    }\n    // 处理完成之后，销毁删除的\n    // 不在处理中的\n    var components = [];\n    each(this.getComponents(), function (co) {\n      if (updated[co.id]) {\n        components.push(co);\n      } else {\n        co.component.destroy();\n      }\n    });\n    // 更新当前已有的 components\n    this.components = components;\n  };\n  Legend.prototype.clear = function () {\n    _super.prototype.clear.call(this);\n    this.container.clear();\n  };\n  Legend.prototype.destroy = function () {\n    _super.prototype.destroy.call(this);\n    this.container.remove(true);\n  };\n  /**\n   * 递归获取所有的 Geometry\n   */\n  Legend.prototype.getGeometries = function (view) {\n    var _this = this;\n    var geometries = view.geometries;\n    each(view.views, function (v) {\n      geometries = geometries.concat(_this.getGeometries(v));\n    });\n    return geometries;\n  };\n  /**\n   * 遍历 Geometry，处理 legend 逻辑\n   * @param doEach 每个 loop 中的处理方法\n   */\n  Legend.prototype.loopLegends = function (doEach) {\n    var isRootView = this.view.getRootView() === this.view;\n    // 非根 view，不处理 legend\n    if (!isRootView) {\n      return;\n    }\n    // 递归 view 中所有的 Geometry，进行创建 legend\n    var geometries = this.getGeometries(this.view);\n    var looped = {}; // 防止一个字段创建两个 legend\n    each(geometries, function (geometry) {\n      var attributes = geometry.getGroupAttributes();\n      each(attributes, function (attr) {\n        var scale = attr.getScale(attr.type);\n        // 如果在视觉通道上映射常量值，如 size(2) shape('circle') 不创建 legend\n        if (!scale || scale.type === 'identity' || looped[scale.field]) {\n          return;\n        }\n        doEach(geometry, attr, scale);\n        looped[scale.field] = true;\n      });\n    });\n  };\n  /**\n   * 创建一个 legend\n   * @param geometry\n   * @param attr\n   * @param scale\n   */\n  Legend.prototype.createFieldLegend = function (geometry, attr, scale) {\n    var component;\n    var legendOption = getLegendOption(this.option, scale.field);\n    var layer = LAYER.FORE;\n    var direction = getDirection(legendOption);\n    // if the legend option is not false, means legend should be created.\n    if (legendOption !== false) {\n      if (get(legendOption, 'custom')) {\n        component = this.createCustomLegend(geometry, attr, scale, legendOption);\n      } else {\n        if (scale.isLinear) {\n          // linear field, create continuous legend\n          component = this.createContinuousLegend(geometry, attr, scale, legendOption);\n        } else if (scale.isCategory) {\n          // category field, create category legend\n          component = this.createCategoryLegend(geometry, attr, scale, legendOption);\n        }\n      }\n    }\n    if (component) {\n      component.set('field', scale.field);\n      return {\n        id: this.getId(scale.field),\n        component: component,\n        layer: layer,\n        direction: direction,\n        type: COMPONENT_TYPE.LEGEND,\n        extra: {\n          scale: scale\n        }\n      };\n    }\n  };\n  /**\n   * 自定义图例使用 category 图例去渲染\n   * @param geometry\n   * @param attr\n   * @param scale\n   * @param legendOption\n   */\n  Legend.prototype.createCustomLegend = function (geometry, attr, scale, legendOption) {\n    // 直接使用 分类图例渲染\n    var cfg = this.getCategoryCfg(geometry, attr, scale, legendOption, true);\n    return new CategoryLegend(cfg);\n  };\n  /**\n   * 创建连续图例\n   * @param geometry\n   * @param attr\n   * @param scale\n   * @param legendOption\n   */\n  Legend.prototype.createContinuousLegend = function (geometry, attr, scale, legendOption) {\n    var cfg = this.getContinuousCfg(geometry, attr, scale, omit(legendOption, ['value']));\n    return new ContinuousLegend(cfg);\n  };\n  /**\n   * 创建分类图例\n   * @param geometry\n   * @param attr\n   * @param scale\n   * @param legendOption\n   */\n  Legend.prototype.createCategoryLegend = function (geometry, attr, scale, legendOption) {\n    var cfg = this.getCategoryCfg(geometry, attr, scale, legendOption);\n    return new CategoryLegend(cfg);\n  };\n  /**\n   * 获得连续图例的配置\n   * @param geometry\n   * @param attr\n   * @param scale\n   * @param legendOption\n   */\n  Legend.prototype.getContinuousCfg = function (geometry, attr, scale, legendOption) {\n    var ticks = scale.getTicks();\n    var containMin = find(ticks, function (tick) {\n      return tick.value === 0;\n    });\n    var containMax = find(ticks, function (tick) {\n      return tick.value === 1;\n    });\n    var items = ticks.map(function (tick) {\n      var value = tick.value,\n        tickValue = tick.tickValue;\n      var attrValue = attr.mapping(scale.invert(value)).join('');\n      return {\n        value: tickValue,\n        attrValue: attrValue,\n        color: attrValue,\n        scaleValue: value\n      };\n    });\n    if (!containMin) {\n      items.push({\n        value: scale.min,\n        attrValue: attr.mapping(scale.invert(0)).join(''),\n        color: attr.mapping(scale.invert(0)).join(''),\n        scaleValue: 0\n      });\n    }\n    if (!containMax) {\n      items.push({\n        value: scale.max,\n        attrValue: attr.mapping(scale.invert(1)).join(''),\n        color: attr.mapping(scale.invert(1)).join(''),\n        scaleValue: 1\n      });\n    }\n    // 排序\n    items.sort(function (a, b) {\n      return a.value - b.value;\n    });\n    // 跟 attr 相关的配置\n    // size color 区别的配置\n    var attrLegendCfg = {\n      min: head(items).value,\n      max: last(items).value,\n      colors: [],\n      rail: {\n        type: attr.type\n      },\n      track: {}\n    };\n    if (attr.type === 'size') {\n      attrLegendCfg.track = {\n        style: {\n          // size 的选中前景色，对于 color，则直接使用 color 标识\n          // @ts-ignore\n          fill: attr.type === 'size' ? this.view.getTheme().defaultColor : undefined\n        }\n      };\n    }\n    if (attr.type === 'color') {\n      attrLegendCfg.colors = items.map(function (item) {\n        return item.attrValue;\n      });\n    }\n    var container = this.container;\n    // if position is not set, use top as default\n    var direction = getDirection(legendOption);\n    var layout = getLegendLayout(direction);\n    var title = get(legendOption, 'title');\n    if (title) {\n      title = deepMix({\n        text: getName(scale)\n      }, title);\n    }\n    // 基础配置，从当前数据中读到的配置\n    attrLegendCfg.container = container;\n    attrLegendCfg.layout = layout;\n    attrLegendCfg.title = title;\n    attrLegendCfg.animateOption = DEFAULT_ANIMATE_CFG;\n    // @ts-ignore\n    return this.mergeLegendCfg(attrLegendCfg, legendOption, 'continuous');\n  };\n  /**\n   * 获取分类图例的配置项\n   * @param geometry\n   * @param attr\n   * @param scale\n   * @param custom\n   * @param legendOption\n   */\n  Legend.prototype.getCategoryCfg = function (geometry, attr, scale, legendOption, custom) {\n    var container = this.container;\n    // if position is not set, use top as default\n    var direction = get(legendOption, 'position', DIRECTION.BOTTOM);\n    var legendTheme = getLegendThemeCfg(this.view.getTheme(), direction);\n    // the default marker style\n    var themeMarker = get(legendTheme, ['marker']);\n    var userMarker = get(legendOption, 'marker');\n    var layout = getLegendLayout(direction);\n    var themePageNavigator = get(legendTheme, ['pageNavigator']);\n    var userPageNavigator = get(legendOption, 'pageNavigator');\n    var items = custom ? getCustomLegendItems(themeMarker, userMarker, legendOption.items) : getLegendItems(this.view, geometry, attr, themeMarker, userMarker);\n    var title = get(legendOption, 'title');\n    if (title) {\n      title = deepMix({\n        text: scale ? getName(scale) : ''\n      }, title);\n    }\n    var maxWidthRatio = get(legendOption, 'maxWidthRatio');\n    var maxHeightRatio = get(legendOption, 'maxHeightRatio');\n    var baseCfg = this.getCategoryLegendSizeCfg(layout, maxWidthRatio, maxHeightRatio);\n    baseCfg.container = container;\n    baseCfg.layout = layout;\n    baseCfg.items = items;\n    baseCfg.title = title;\n    baseCfg.animateOption = DEFAULT_ANIMATE_CFG;\n    baseCfg.pageNavigator = deepMix({}, themePageNavigator, userPageNavigator);\n    var categoryCfg = this.mergeLegendCfg(baseCfg, legendOption, direction);\n    if (categoryCfg.reversed) {\n      // 图例项需要逆序\n      categoryCfg.items.reverse();\n    }\n    var maxItemWidth = get(categoryCfg, 'maxItemWidth');\n    if (maxItemWidth && maxItemWidth <= 1) {\n      // 转换成像素值\n      categoryCfg.maxItemWidth = this.view.viewBBox.width * maxItemWidth;\n    }\n    return categoryCfg;\n  };\n  /**\n   * get legend config, use option > suggestion > theme\n   * @param baseCfg\n   * @param legendOption\n   * @param direction\n   */\n  Legend.prototype.mergeLegendCfg = function (baseCfg, legendOption, direction) {\n    var position = direction.split('-')[0];\n    var themeObject = getLegendThemeCfg(this.view.getTheme(), position);\n    return deepMix({}, themeObject, baseCfg, legendOption);\n  };\n  /**\n   * 生成 id\n   * @param key\n   */\n  Legend.prototype.getId = function (key) {\n    return \"\".concat(this.name, \"-\").concat(key);\n  };\n  /**\n   * 根据 id 来获取组件\n   * @param id\n   */\n  Legend.prototype.getComponentById = function (id) {\n    return find(this.components, function (co) {\n      return co.id === id;\n    });\n  };\n  Legend.prototype.getCategoryLegendSizeCfg = function (layout, maxWidthRatio, maxHeightRatio) {\n    if (maxWidthRatio === void 0) {\n      maxWidthRatio = COMPONENT_MAX_VIEW_PERCENTAGE;\n    }\n    if (maxHeightRatio === void 0) {\n      maxHeightRatio = COMPONENT_MAX_VIEW_PERCENTAGE;\n    }\n    var _a = this.view.viewBBox,\n      vw = _a.width,\n      vh = _a.height;\n    // 目前 legend 的布局是以 viewBBox 为参照\n    // const { width: cw, height: ch } = this.view.coordinateBBox;\n    return layout === 'vertical' ? {\n      maxWidth: vw * maxWidthRatio,\n      maxHeight: vh\n    } : {\n      maxWidth: vw,\n      maxHeight: vh * maxHeightRatio\n    };\n  };\n  return Legend;\n}(Controller);\nexport default Legend;","map":{"version":3,"sources":["../../../src/chart/controller/legend.ts"],"names":[],"mappings":"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","sourcesContent":["import { deepMix, each, find, get, head, isBoolean, last } from '@antv/util';\nimport { COMPONENT_MAX_VIEW_PERCENTAGE, COMPONENT_TYPE, DIRECTION, LAYER } from '../../constant';\nimport { Attribute, CategoryLegend, ContinuousLegend, GroupComponent, IGroup, Scale, Tick } from '../../dependents';\nimport { ComponentOption, LegendCfg, LegendOption, LooseObject, AllLegendsOptions, Padding } from '../../interface';\nimport { DEFAULT_ANIMATE_CFG } from '../../animate';\nimport Geometry from '../../geometry/base';\nimport { BBox } from '../../util/bbox';\nimport { directionToPosition } from '../../util/direction';\nimport { omit } from '../../util/helper';\nimport { getCustomLegendItems, getLegendItems, getLegendLayout, getLegendThemeCfg } from '../../util/legend';\nimport { getName } from '../../util/scale';\nimport View from '../view';\nimport { Controller } from './base';\n\ntype DoEach = (geometry: Geometry, attr: Attribute, scale: Scale) => void;\n\n/**\n * 从配置中获取单个字段的 legend 配置\n * @param legends\n * @param field\n * @returns the option of one legend field\n */\nfunction getLegendOption(legends: AllLegendsOptions, field: string) {\n  if (isBoolean(legends)) {\n    return legends === false ? false : {};\n  }\n\n  return get(legends, [field], legends);\n}\n\nfunction getDirection(legendOption: any): DIRECTION {\n  return get(legendOption, 'position', DIRECTION.BOTTOM);\n}\n\n/**\n * @ignore\n * legend Controller\n */\nexport default class Legend extends Controller<AllLegendsOptions> {\n  /** the draw group of axis */\n  private container: IGroup;\n  /** 用于多个 legend 布局的 bbox */\n  private layoutBBox: BBox;\n\n  constructor(view: View) {\n    super(view);\n\n    this.container = this.view.getLayer(LAYER.FORE).addGroup();\n  }\n\n  public get name(): string {\n    return 'legend';\n  }\n\n  public init() {}\n\n  /**\n   * render the legend component by legend options\n   */\n  public render() {\n    // 和 update 逻辑保持一致\n    this.update();\n  }\n\n  /**\n   * layout legend\n   * 计算出 legend 的 direction 位置 x, y\n   */\n  public layout() {\n    this.layoutBBox = this.view.viewBBox;\n\n    each(this.components, (co: ComponentOption) => {\n      const { component, direction } = co;\n      const layout = getLegendLayout(direction);\n      const maxWidthRatio = component.get('maxWidthRatio');\n      const maxHeightRatio = component.get('maxHeightRatio');\n\n      const maxSize = this.getCategoryLegendSizeCfg(layout, maxWidthRatio, maxHeightRatio);\n\n      const maxWidth = component.get('maxWidth');\n      const maxHeight = component.get('maxHeight');\n\n      // 先更新 maxSize，更新 layoutBBox，以便计算正确的 x y\n      component.update({\n        maxWidth: Math.min(maxSize.maxWidth, maxWidth || 0),\n        maxHeight: Math.min(maxSize.maxHeight, maxHeight || 0),\n      });\n\n      const padding = component.get('padding') as Padding;\n\n      const bboxObject = component.getLayoutBBox(); // 这里只需要他的 width、height 信息做位置调整\n      const bbox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height).expand(padding);\n\n      const [x1, y1] = directionToPosition(this.view.viewBBox, bbox, direction);\n      const [x2, y2] = directionToPosition(this.layoutBBox, bbox, direction);\n\n      let x = 0;\n      let y = 0;\n\n      // 因为 legend x y 要和 coordinateBBox 对齐，所以要做一个简单的判断\n      if (direction.startsWith('top') || direction.startsWith('bottom')) {\n        x = x1;\n        y = y2;\n      } else {\n        x = x2;\n        y = y1;\n      }\n\n      // 更新位置\n      component.setLocation({ x: x + padding[3], y: y + padding[0] });\n\n      this.layoutBBox = this.layoutBBox.cut(bbox, direction);\n    });\n  }\n\n  /**\n   * legend 的更新逻辑\n   */\n  public update() {\n    this.option = this.view.getOptions().legends;\n\n    // 已经处理过的 legend\n    const updated: Record<string, true> = {};\n\n    const eachLegend = (geometry: Geometry, attr: Attribute, scale: Scale) => {\n      const id = this.getId(scale.field);\n\n      const existCo = this.getComponentById(id);\n\n      // 存在则 update\n      if (existCo) {\n        let cfg;\n        const legendOption = getLegendOption(this.option, scale.field);\n\n        // if the legend option is not false, means legend should be created.\n        if (legendOption !== false) {\n          if (get(legendOption, 'custom')) {\n            cfg = this.getCategoryCfg(geometry, attr, scale, legendOption, true);\n          } else {\n            if (scale.isLinear) {\n              // linear field, create continuous legend\n              cfg = this.getContinuousCfg(geometry, attr, scale, legendOption);\n            } else if (scale.isCategory) {\n              // category field, create category legend\n              cfg = this.getCategoryCfg(geometry, attr, scale, legendOption);\n            }\n          }\n        }\n\n        // 如果 cfg 为空，则不在 updated 标记，那么会在后面逻辑中删除\n        if (cfg) {\n          // omit 掉一些属性，比如 container 等\n          omit(cfg, ['container']);\n\n          existCo.direction = getDirection(legendOption);\n\n          existCo.component.update(cfg);\n\n          // 标记为新的\n          updated[id] = true;\n        }\n      } else {\n        // 不存在则 create\n        const legend = this.createFieldLegend(geometry, attr, scale);\n\n        if (legend) {\n          (legend.component as GroupComponent).init();\n          this.components.push(legend);\n\n          // 标记为新的\n          updated[id] = true;\n        }\n      }\n    };\n\n    // 全局自定义图例\n    if (get(this.option, 'custom')) {\n      const id = 'global-custom';\n      const existCo = this.getComponentById(id);\n      if (existCo) {\n        const customCfg = this.getCategoryCfg(undefined, undefined, undefined, this.option, true);\n        omit(customCfg, ['container']);\n        existCo.component.update(customCfg);\n\n        updated[id] = true;\n      } else {\n        const component = this.createCustomLegend(undefined, undefined, undefined, this.option as LegendCfg);\n        if (component) {\n          component.init();\n\n          const layer = LAYER.FORE;\n          const direction = getDirection(this.option);\n\n          this.components.push({\n            id,\n            component,\n            layer,\n            direction,\n            type: COMPONENT_TYPE.LEGEND,\n            extra: undefined,\n          });\n\n          // 标记为更新\n          updated[id] = true;\n        }\n      }\n    } else {\n      // 遍历处理每一个创建逻辑\n      this.loopLegends(eachLegend);\n    }\n\n    // 处理完成之后，销毁删除的\n    // 不在处理中的\n    const components = [];\n    each(this.getComponents(), (co: ComponentOption) => {\n      if (updated[co.id]) {\n        components.push(co);\n      } else {\n        co.component.destroy();\n      }\n    });\n\n    // 更新当前已有的 components\n    this.components = components;\n  }\n\n  public clear() {\n    super.clear();\n    this.container.clear();\n  }\n\n  public destroy() {\n    super.destroy();\n\n    this.container.remove(true);\n  }\n\n  /**\n   * 递归获取所有的 Geometry\n   */\n  private getGeometries(view: View): Geometry[] {\n    let geometries = view.geometries;\n\n    each(view.views, (v: View) => {\n      geometries = geometries.concat(this.getGeometries(v));\n    });\n\n    return geometries;\n  }\n\n  /**\n   * 遍历 Geometry，处理 legend 逻辑\n   * @param doEach 每个 loop 中的处理方法\n   */\n  private loopLegends(doEach: DoEach) {\n    const isRootView = this.view.getRootView() === this.view;\n    // 非根 view，不处理 legend\n    if (!isRootView) {\n      return;\n    }\n\n    // 递归 view 中所有的 Geometry，进行创建 legend\n    const geometries = this.getGeometries(this.view);\n\n    const looped: Record<string, true> = {}; // 防止一个字段创建两个 legend\n\n    each(geometries, (geometry: Geometry) => {\n      const attributes = geometry.getGroupAttributes();\n\n      each(attributes, (attr: Attribute) => {\n        const scale = attr.getScale(attr.type);\n        // 如果在视觉通道上映射常量值，如 size(2) shape('circle') 不创建 legend\n        if (!scale || scale.type === 'identity' || looped[scale.field]) {\n          return;\n        }\n\n        doEach(geometry, attr, scale);\n\n        looped[scale.field] = true;\n      });\n    });\n  }\n\n  /**\n   * 创建一个 legend\n   * @param geometry\n   * @param attr\n   * @param scale\n   */\n  private createFieldLegend(geometry: Geometry, attr: Attribute, scale: Scale): ComponentOption {\n    let component;\n\n    const legendOption = getLegendOption(this.option, scale.field);\n    const layer = LAYER.FORE;\n    const direction = getDirection(legendOption);\n\n    // if the legend option is not false, means legend should be created.\n    if (legendOption !== false) {\n      if (get(legendOption, 'custom')) {\n        component = this.createCustomLegend(geometry, attr, scale, legendOption);\n      } else {\n        if (scale.isLinear) {\n          // linear field, create continuous legend\n          component = this.createContinuousLegend(geometry, attr, scale, legendOption);\n        } else if (scale.isCategory) {\n          // category field, create category legend\n          component = this.createCategoryLegend(geometry, attr, scale, legendOption);\n        }\n      }\n    }\n\n    if (component) {\n      component.set('field', scale.field);\n\n      return {\n        id: this.getId(scale.field),\n        component,\n        layer,\n        direction,\n        type: COMPONENT_TYPE.LEGEND,\n        extra: { scale },\n      };\n    }\n  }\n\n  /**\n   * 自定义图例使用 category 图例去渲染\n   * @param geometry\n   * @param attr\n   * @param scale\n   * @param legendOption\n   */\n  private createCustomLegend(geometry: Geometry, attr: Attribute, scale: Scale, legendOption: LegendCfg) {\n    // 直接使用 分类图例渲染\n    const cfg = this.getCategoryCfg(geometry, attr, scale, legendOption, true);\n    return new CategoryLegend(cfg);\n  }\n\n  /**\n   * 创建连续图例\n   * @param geometry\n   * @param attr\n   * @param scale\n   * @param legendOption\n   */\n  private createContinuousLegend(geometry: Geometry, attr: Attribute, scale: Scale, legendOption: any) {\n    const cfg = this.getContinuousCfg(geometry, attr, scale, omit(legendOption, ['value']));\n    return new ContinuousLegend(cfg);\n  }\n\n  /**\n   * 创建分类图例\n   * @param geometry\n   * @param attr\n   * @param scale\n   * @param legendOption\n   */\n  private createCategoryLegend(geometry: Geometry, attr: Attribute, scale: Scale, legendOption: any) {\n    const cfg = this.getCategoryCfg(geometry, attr, scale, legendOption);\n    return new CategoryLegend(cfg);\n  }\n\n  /**\n   * 获得连续图例的配置\n   * @param geometry\n   * @param attr\n   * @param scale\n   * @param legendOption\n   */\n  private getContinuousCfg(geometry: Geometry, attr: Attribute, scale: Scale, legendOption: any) {\n    const ticks = scale.getTicks();\n\n    const containMin = find(ticks, (tick: Tick) => tick.value === 0);\n    const containMax = find(ticks, (tick: Tick) => tick.value === 1);\n    const items = ticks.map((tick: Tick) => {\n      const { value, tickValue } = tick;\n      const attrValue = attr.mapping(scale.invert(value)).join('');\n\n      return {\n        value: tickValue,\n        attrValue,\n        color: attrValue,\n        scaleValue: value,\n      };\n    });\n\n    if (!containMin) {\n      items.push({\n        value: scale.min,\n        attrValue: attr.mapping(scale.invert(0)).join(''),\n        color: attr.mapping(scale.invert(0)).join(''),\n        scaleValue: 0,\n      });\n    }\n    if (!containMax) {\n      items.push({\n        value: scale.max,\n        attrValue: attr.mapping(scale.invert(1)).join(''),\n        color: attr.mapping(scale.invert(1)).join(''),\n        scaleValue: 1,\n      });\n    }\n\n    // 排序\n    items.sort((a: any, b: any) => a.value - b.value);\n\n    // 跟 attr 相关的配置\n    // size color 区别的配置\n    const attrLegendCfg: LooseObject = {\n      min: head(items).value,\n      max: last(items).value,\n      colors: [],\n      rail: {\n        type: attr.type,\n      },\n      track: {},\n    };\n\n    if (attr.type === 'size') {\n      attrLegendCfg.track = {\n        style: {\n          // size 的选中前景色，对于 color，则直接使用 color 标识\n          // @ts-ignore\n          fill: attr.type === 'size' ? this.view.getTheme().defaultColor : undefined,\n        },\n      };\n    }\n\n    if (attr.type === 'color') {\n      attrLegendCfg.colors = items.map((item) => item.attrValue);\n    }\n\n    const container = this.container;\n    // if position is not set, use top as default\n    const direction = getDirection(legendOption);\n\n    const layout = getLegendLayout(direction);\n\n    let title = get(legendOption, 'title');\n    if (title) {\n      title = deepMix(\n        {\n          text: getName(scale),\n        },\n        title\n      );\n    }\n\n    // 基础配置，从当前数据中读到的配置\n    attrLegendCfg.container = container;\n    attrLegendCfg.layout = layout;\n    attrLegendCfg.title = title;\n    attrLegendCfg.animateOption = DEFAULT_ANIMATE_CFG;\n    // @ts-ignore\n    return this.mergeLegendCfg(attrLegendCfg, legendOption, 'continuous');\n  }\n\n  /**\n   * 获取分类图例的配置项\n   * @param geometry\n   * @param attr\n   * @param scale\n   * @param custom\n   * @param legendOption\n   */\n  private getCategoryCfg(geometry: Geometry, attr: Attribute, scale: Scale, legendOption: any, custom?: boolean) {\n    const container = this.container;\n    // if position is not set, use top as default\n    const direction = get(legendOption, 'position', DIRECTION.BOTTOM);\n\n    const legendTheme = getLegendThemeCfg(this.view.getTheme(), direction);\n\n    // the default marker style\n    const themeMarker = get(legendTheme, ['marker']);\n    const userMarker = get(legendOption, 'marker');\n    const layout = getLegendLayout(direction);\n    const themePageNavigator = get(legendTheme, ['pageNavigator']);\n    const userPageNavigator = get(legendOption, 'pageNavigator');\n\n    const items = custom\n      ? getCustomLegendItems(themeMarker, userMarker, legendOption.items)\n      : getLegendItems(this.view, geometry, attr, themeMarker, userMarker);\n\n    let title = get(legendOption, 'title');\n    if (title) {\n      title = deepMix(\n        {\n          text: scale ? getName(scale) : '',\n        },\n        title\n      );\n    }\n    const maxWidthRatio = get(legendOption, 'maxWidthRatio');\n    const maxHeightRatio = get(legendOption, 'maxHeightRatio');\n\n    const baseCfg: LooseObject = this.getCategoryLegendSizeCfg(layout, maxWidthRatio, maxHeightRatio);\n    baseCfg.container = container;\n    baseCfg.layout = layout;\n    baseCfg.items = items;\n    baseCfg.title = title;\n    baseCfg.animateOption = DEFAULT_ANIMATE_CFG;\n    baseCfg.pageNavigator = deepMix({}, themePageNavigator, userPageNavigator);\n\n    const categoryCfg = this.mergeLegendCfg(baseCfg, legendOption, direction);\n    if (categoryCfg.reversed) {\n      // 图例项需要逆序\n      categoryCfg.items.reverse();\n    }\n\n    const maxItemWidth = get(categoryCfg, 'maxItemWidth');\n    if (maxItemWidth && maxItemWidth <= 1) {\n      // 转换成像素值\n      categoryCfg.maxItemWidth = this.view.viewBBox.width * maxItemWidth;\n    }\n\n    return categoryCfg;\n  }\n\n  /**\n   * get legend config, use option > suggestion > theme\n   * @param baseCfg\n   * @param legendOption\n   * @param direction\n   */\n  private mergeLegendCfg(baseCfg: object, legendOption: LegendOption, direction: DIRECTION) {\n    const position = direction.split('-')[0];\n    const themeObject = getLegendThemeCfg(this.view.getTheme(), position);\n\n    return deepMix({}, themeObject, baseCfg, legendOption);\n  }\n\n  /**\n   * 生成 id\n   * @param key\n   */\n  private getId(key: string): string {\n    return `${this.name}-${key}`;\n  }\n\n  /**\n   * 根据 id 来获取组件\n   * @param id\n   */\n  private getComponentById(id: string): ComponentOption {\n    return find(this.components, (co) => co.id === id);\n  }\n\n  private getCategoryLegendSizeCfg(\n    layout: 'horizontal' | 'vertical',\n    maxWidthRatio = COMPONENT_MAX_VIEW_PERCENTAGE,\n    maxHeightRatio = COMPONENT_MAX_VIEW_PERCENTAGE\n  ) {\n    const { width: vw, height: vh } = this.view.viewBBox;\n    // 目前 legend 的布局是以 viewBBox 为参照\n    // const { width: cw, height: ch } = this.view.coordinateBBox;\n    return layout === 'vertical'\n      ? {\n          maxWidth: vw * maxWidthRatio,\n          maxHeight: vh,\n        }\n      : {\n          maxWidth: vw,\n          maxHeight: vh * maxHeightRatio,\n        };\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}