{"ast":null,"code":"import { __values } from \"tslib\";\nimport { isArray, isString } from '@antv/util';\n/**\n * @ignore\n * Determines whether between is\n * @param value\n * @param start\n * @param end\n * @returns true if between\n */\nexport function isBetween(value, start, end) {\n  var min = Math.min(start, end);\n  var max = Math.max(start, end);\n  return value >= min && value <= max;\n}\n/**\n * @ignore\n * pads the current string/array with a given value (repeated, if needed) so that the resulting reaches a given length.\n * The padding is applied from the end of the current value.\n *\n * @param source\n * @param targetLength\n * @param padValue\n * @returns\n */\nexport function padEnd(source, targetLength, padValue) {\n  if (isString(source)) {\n    return source.padEnd(targetLength, padValue);\n  } else if (isArray(source)) {\n    var sourceLength = source.length;\n    if (sourceLength < targetLength) {\n      var diff = targetLength - sourceLength;\n      for (var i = 0; i < diff; i++) {\n        source.push(padValue);\n      }\n    }\n  }\n  return source;\n}\n/**\n * @ignore\n * omit keys of an object.\n * @param obj\n * @param keys\n */\nexport function omit(obj, keys) {\n  if (typeof obj === 'object') {\n    keys.forEach(function (key) {\n      delete obj[key];\n    });\n  }\n  return obj;\n}\n/**\n * @ignore\n * @param sourceArray\n * @param targetArray\n * @param map\n */\nexport function uniq(sourceArray, targetArray, map) {\n  var e_1, _a;\n  if (targetArray === void 0) {\n    targetArray = [];\n  }\n  if (map === void 0) {\n    map = new Map();\n  }\n  try {\n    for (var sourceArray_1 = __values(sourceArray), sourceArray_1_1 = sourceArray_1.next(); !sourceArray_1_1.done; sourceArray_1_1 = sourceArray_1.next()) {\n      var source = sourceArray_1_1.value;\n      if (!map.has(source)) {\n        targetArray.push(source);\n        map.set(source, true);\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (sourceArray_1_1 && !sourceArray_1_1.done && (_a = sourceArray_1.return)) _a.call(sourceArray_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n  return targetArray;\n}","map":{"version":3,"sources":["../../src/util/helper.ts"],"names":[],"mappings":";AAAA,SAAS,OAAO,EAAE,QAAQ,QAAQ,YAAY;AAE9C;;;;;;;AAOG;AACH,OAAM,SAAU,SAAS,CAAC,KAAa,EAAE,KAAa,EAAE,GAAW,EAAA;EACjE,IAAM,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,GAAG,CAAC;EAChC,IAAM,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,GAAG,CAAC;EAEhC,OAAO,KAAK,IAAI,GAAG,IAAI,KAAK,IAAI,GAAG;AACrC;AAEA;;;;;;;;;AASG;AACH,OAAM,SAAU,MAAM,CAAC,MAAsB,EAAE,YAAoB,EAAE,QAAa,EAAA;EAChF,IAAI,QAAQ,CAAC,MAAM,CAAC,EAAE;IACpB,OAAO,MAAM,CAAC,MAAM,CAAC,YAAY,EAAE,QAAQ,CAAC;GAC7C,MAAM,IAAI,OAAO,CAAC,MAAM,CAAC,EAAE;IAC1B,IAAM,YAAY,GAAG,MAAM,CAAC,MAAM;IAClC,IAAI,YAAY,GAAG,YAAY,EAAE;MAC/B,IAAM,IAAI,GAAG,YAAY,GAAG,YAAY;MACxC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,EAAE,CAAC,EAAE,EAAE;QAC7B,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC;MACtB;IACF;EACF;EAED,OAAO,MAAM;AACf;AAEA;;;;;AAKG;AACH,OAAM,SAAU,IAAI,CAAU,GAAM,EAAE,IAAc,EAAA;EAClD,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE;IAC3B,IAAI,CAAC,OAAO,CAAC,UAAC,GAAW,EAAA;MACvB,OAAO,GAAG,CAAC,GAAG,CAAC;IACjB,CAAC,CAAC;EACH;EAED,OAAO,GAAG;AACZ;AAEA;;;;;AAKG;AACH,OAAM,SAAU,IAAI,CAAC,WAAkB,EAAE,WAAuB,EAAE,GAAkC,EAAA;;EAA3D,IAAA,WAAA,KAAA,KAAA,CAAA,EAAA;IAAA,WAAA,GAAA,EAAuB;EAAA;EAAE,IAAA,GAAA,KAAA,KAAA,CAAA,EAAA;IAAA,GAAA,GAAA,IAA6B,GAAG,EAAE;EAAA;;IAClG,KAAqB,IAAA,aAAA,GAAA,QAAA,CAAA,WAAW,CAAA,EAAA,eAAA,GAAA,aAAA,CAAA,IAAA,EAAA,EAAA,CAAA,eAAA,CAAA,IAAA,EAAA,eAAA,GAAA,aAAA,CAAA,IAAA,EAAA,EAAE;MAA7B,IAAM,MAAM,GAAA,eAAA,CAAA,KAAA;MACf,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE;QACpB,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC;QACxB,GAAG,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,CAAC;MACtB;IACF;;;;;;;;;;;;EACD,OAAO,WAAW;AACpB","sourcesContent":["import { isArray, isString } from '@antv/util';\n\n/**\n * @ignore\n * Determines whether between is\n * @param value\n * @param start\n * @param end\n * @returns true if between\n */\nexport function isBetween(value: number, start: number, end: number): boolean {\n  const min = Math.min(start, end);\n  const max = Math.max(start, end);\n\n  return value >= min && value <= max;\n}\n\n/**\n * @ignore\n * pads the current string/array with a given value (repeated, if needed) so that the resulting reaches a given length.\n * The padding is applied from the end of the current value.\n *\n * @param source\n * @param targetLength\n * @param padValue\n * @returns\n */\nexport function padEnd(source: string | any[], targetLength: number, padValue: any) {\n  if (isString(source)) {\n    return source.padEnd(targetLength, padValue);\n  } else if (isArray(source)) {\n    const sourceLength = source.length;\n    if (sourceLength < targetLength) {\n      const diff = targetLength - sourceLength;\n      for (let i = 0; i < diff; i++) {\n        source.push(padValue);\n      }\n    }\n  }\n\n  return source;\n}\n\n/**\n * @ignore\n * omit keys of an object.\n * @param obj\n * @param keys\n */\nexport function omit<T = any>(obj: T, keys: string[]): T {\n  if (typeof obj === 'object') {\n    keys.forEach((key: string) => {\n      delete obj[key];\n    });\n  }\n\n  return obj;\n}\n\n/**\n * @ignore\n * @param sourceArray\n * @param targetArray\n * @param map\n */\nexport function uniq(sourceArray: any[], targetArray: any[] = [], map: Map<any, boolean> = new Map()) {\n  for (const source of sourceArray) {\n    if (!map.has(source)) {\n      targetArray.push(source);\n      map.set(source, true);\n    }\n  }\n  return targetArray;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}