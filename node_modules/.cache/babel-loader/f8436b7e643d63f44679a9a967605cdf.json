{"ast":null,"code":"import { __assign, __read, __spreadArray, __values } from \"tslib\";\nimport { contains, filter, find, isArray, isEmpty, isFunction, isNil, isNumberEqual, isObject, memoize, get, values } from '@antv/util';\nimport { FIELD_ORIGIN, GROUP_ATTRS } from '../constant';\nimport { getName, inferScaleType } from './scale';\nfunction snapEqual(v1, v2, scale) {\n  var value1 = scale.translate(v1);\n  var value2 = scale.translate(v2);\n  return isNumberEqual(value1, value2);\n}\nfunction getXValueByPoint(point, geometry) {\n  var coordinate = geometry.coordinate;\n  var xScale = geometry.getXScale();\n  var range = xScale.range;\n  var rangeMax = range[range.length - 1];\n  var rangeMin = range[0];\n  var invertPoint = coordinate.invert(point);\n  var xValue = invertPoint.x;\n  if (coordinate.isPolar && xValue > (1 + rangeMax) / 2) {\n    xValue = rangeMin; // 极坐标下，scale 的 range 被做过特殊处理\n  }\n\n  return xScale.translate(xScale.invert(xValue));\n}\nfunction filterYValue(data, point, geometry) {\n  var coordinate = geometry.coordinate;\n  var yScale = geometry.getYScale();\n  var yField = yScale.field;\n  var invertPoint = coordinate.invert(point);\n  var yValue = yScale.invert(invertPoint.y);\n  var result = find(data, function (obj) {\n    var originData = obj[FIELD_ORIGIN];\n    return originData[yField][0] <= yValue && originData[yField][1] >= yValue;\n  });\n  return result || data[data.length - 1];\n}\nvar getXDistance = memoize(function (scale) {\n  if (scale.isCategory) {\n    return 1;\n  }\n  var scaleValues = scale.values; // values 是无序的\n  var length = scaleValues.length;\n  var min = scale.translate(scaleValues[0]);\n  var max = min;\n  for (var index = 0; index < length; index++) {\n    var value = scaleValues[index];\n    // 时间类型需要 translate\n    var numericValue = scale.translate(value);\n    if (numericValue < min) {\n      min = numericValue;\n    }\n    if (numericValue > max) {\n      max = numericValue;\n    }\n  }\n  return (max - min) / (length - 1);\n});\n/**\n * 获得 tooltip 的 title\n * @param originData\n * @param geometry\n * @param title\n */\nfunction getTooltipTitle(originData, geometry, title) {\n  var positionAttr = geometry.getAttribute('position');\n  var fields = positionAttr.getFields();\n  var scales = geometry.scales;\n  var titleField = isFunction(title) || !title ? fields[0] : title;\n  var titleScale = scales[titleField];\n  // 如果创建了该字段对应的 scale，则通过 scale.getText() 方式取值，因为用户可能对数据进行了格式化\n  // 如果没有对应的 scale，则从原始数据中取值，如果原始数据中仍不存在，则直接放回 title 值\n  var tooltipTitle = titleScale ? titleScale.getText(originData[titleField]) : originData[titleField] || titleField;\n  return isFunction(title) ? title(tooltipTitle, originData) : tooltipTitle;\n}\nfunction getAttributesForLegend(geometry) {\n  var attributes = values(geometry.attributes);\n  return filter(attributes, function (attribute) {\n    return contains(GROUP_ATTRS, attribute.type);\n  });\n}\nfunction getTooltipValueScale(geometry) {\n  var e_1, _a;\n  var attributes = getAttributesForLegend(geometry);\n  var scale;\n  try {\n    for (var attributes_1 = __values(attributes), attributes_1_1 = attributes_1.next(); !attributes_1_1.done; attributes_1_1 = attributes_1.next()) {\n      var attribute = attributes_1_1.value;\n      var tmpScale = attribute.getScale(attribute.type);\n      if (tmpScale && tmpScale.isLinear) {\n        var tmpScaleDef = get(geometry.scaleDefs, tmpScale.field);\n        var inferedScaleType = inferScaleType(tmpScale, tmpScaleDef, attribute.type, geometry.type);\n        if (inferedScaleType !== 'cat') {\n          // 如果指定字段是非 position 的，同时是连续的\n          scale = tmpScale;\n          break;\n        }\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (attributes_1_1 && !attributes_1_1.done && (_a = attributes_1.return)) _a.call(attributes_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n  var xScale = geometry.getXScale();\n  var yScale = geometry.getYScale();\n  return scale || yScale || xScale;\n}\nfunction getTooltipValue(originData, valueScale) {\n  var field = valueScale.field;\n  var value = originData[field];\n  if (isArray(value)) {\n    var texts = value.map(function (eachValue) {\n      return valueScale.getText(eachValue);\n    });\n    return texts.join('-');\n  }\n  return valueScale.getText(value);\n}\n// 根据原始数据获取 tooltip item 中 name 值\nfunction getTooltipName(originData, geometry) {\n  var nameScale;\n  var groupScales = geometry.getGroupScales();\n  if (groupScales.length) {\n    // 如果存在分组类型，取第一个分组类型\n    nameScale = groupScales[0];\n  }\n  if (nameScale) {\n    var field = nameScale.field;\n    return nameScale.getText(originData[field]);\n  }\n  var valueScale = getTooltipValueScale(geometry);\n  return getName(valueScale);\n}\n/**\n * @ignore\n * Finds data from geometry by point\n * @param point canvas point\n * @param data an item of geometry.dataArray\n * @param geometry\n * @returns\n */\nexport function findDataByPoint(point, data, geometry) {\n  if (data.length === 0) {\n    return null;\n  }\n  var geometryType = geometry.type;\n  var xScale = geometry.getXScale();\n  var yScale = geometry.getYScale();\n  var xField = xScale.field;\n  var yField = yScale.field;\n  var rst = null;\n  // 热力图采用最小逼近策略查找 point 击中的数据\n  if (geometryType === 'heatmap' || geometryType === 'point') {\n    // 将 point 画布坐标转换为原始数据值\n    var coordinate = geometry.coordinate;\n    var invertPoint = coordinate.invert(point); // 转换成归一化的数据\n    var x = xScale.invert(invertPoint.x); // 转换为原始值\n    var y = yScale.invert(invertPoint.y); // 转换为原始值\n    var min = Infinity;\n    for (var index = 0; index < data.length; index++) {\n      var obj = data[index];\n      var originData = obj[FIELD_ORIGIN];\n      var range = Math.pow(originData[xField] - x, 2) + Math.pow(originData[yField] - y, 2);\n      if (range < min) {\n        min = range;\n        rst = obj;\n      }\n    }\n    return rst;\n  }\n  // 其他 Geometry 类型按照 x 字段数据进行查找\n  var first = data[0];\n  var last = data[data.length - 1];\n  var xValue = getXValueByPoint(point, geometry);\n  var firstXValue = first[FIELD_ORIGIN][xField];\n  var firstYValue = first[FIELD_ORIGIN][yField];\n  var lastXValue = last[FIELD_ORIGIN][xField];\n  var isYArray = yScale.isLinear && isArray(firstYValue); // 考虑 x 维度相同，y 是数组区间的情况\n  // 如果 x 的值是数组\n  if (isArray(firstXValue)) {\n    for (var index = 0; index < data.length; index++) {\n      var record = data[index];\n      var originData = record[FIELD_ORIGIN];\n      // xValue 在 originData[xField] 的数值区间内\n      if (xScale.translate(originData[xField][0]) <= xValue && xScale.translate(originData[xField][1]) >= xValue) {\n        if (isYArray) {\n          // 层叠直方图场景，x 和 y 都是数组区间\n          if (!isArray(rst)) {\n            rst = [];\n          }\n          rst.push(record);\n        } else {\n          rst = record;\n          break;\n        }\n      }\n    }\n    if (isArray(rst)) {\n      rst = filterYValue(rst, point, geometry);\n    }\n  } else {\n    var next = void 0;\n    if (!xScale.isLinear && xScale.type !== 'timeCat') {\n      // x 轴对应的数据为非线性以及非时间类型的数据采用遍历查找\n      for (var index = 0; index < data.length; index++) {\n        var record = data[index];\n        var originData = record[FIELD_ORIGIN];\n        if (snapEqual(originData[xField], xValue, xScale)) {\n          if (isYArray) {\n            if (!isArray(rst)) {\n              rst = [];\n            }\n            rst.push(record);\n          } else {\n            rst = record;\n            break;\n          }\n        } else if (xScale.translate(originData[xField]) <= xValue) {\n          last = record;\n          next = data[index + 1];\n        }\n      }\n      if (isArray(rst)) {\n        rst = filterYValue(rst, point, geometry);\n      }\n    } else {\n      // x 轴对应的数据为线性以及时间类型，进行二分查找，性能更好\n      if ((xValue > xScale.translate(lastXValue) || xValue < xScale.translate(firstXValue)) && (xValue > xScale.max || xValue < xScale.min)) {\n        // 不在数据范围内\n        return null;\n      }\n      var firstIdx = 0;\n      var lastIdx = data.length - 1;\n      var middleIdx = void 0;\n      while (firstIdx <= lastIdx) {\n        middleIdx = Math.floor((firstIdx + lastIdx) / 2);\n        var item = data[middleIdx][FIELD_ORIGIN][xField];\n        if (snapEqual(item, xValue, xScale)) {\n          return data[middleIdx];\n        }\n        if (xScale.translate(item) <= xScale.translate(xValue)) {\n          firstIdx = middleIdx + 1;\n          last = data[middleIdx];\n          next = data[middleIdx + 1];\n        } else {\n          if (lastIdx === 0) {\n            last = data[0];\n          }\n          lastIdx = middleIdx - 1;\n        }\n      }\n    }\n    if (last && next) {\n      // 计算最逼近的\n      if (Math.abs(xScale.translate(last[FIELD_ORIGIN][xField]) - xValue) > Math.abs(xScale.translate(next[FIELD_ORIGIN][xField]) - xValue)) {\n        last = next;\n      }\n    }\n  }\n  var distance = getXDistance(geometry.getXScale()); // 每个分类间的平均间距\n  if (!rst && Math.abs(xScale.translate(last[FIELD_ORIGIN][xField]) - xValue) <= distance / 2) {\n    rst = last;\n  }\n  return rst;\n}\n/**\n * @ignore\n * Gets tooltip items\n * @param data\n * @param geometry\n * @param [title]\n * @returns\n */\nexport function getTooltipItems(data, geometry, title, showNil) {\n  var e_2, _a;\n  if (title === void 0) {\n    title = '';\n  }\n  if (showNil === void 0) {\n    showNil = false;\n  }\n  var originData = data[FIELD_ORIGIN];\n  var tooltipTitle = getTooltipTitle(originData, geometry, title);\n  var tooltipOption = geometry.tooltipOption;\n  var defaultColor = geometry.theme.defaultColor;\n  var items = [];\n  var name;\n  var value;\n  function addItem(itemName, itemValue) {\n    if (showNil || !isNil(itemValue) && itemValue !== '') {\n      // 值为 null的时候，忽视\n      var item = {\n        title: tooltipTitle,\n        data: originData,\n        mappingData: data,\n        name: itemName,\n        value: itemValue,\n        color: data.color || defaultColor,\n        marker: true\n      };\n      items.push(item);\n    }\n  }\n  if (isObject(tooltipOption)) {\n    var fields = tooltipOption.fields,\n      callback = tooltipOption.callback;\n    if (callback) {\n      // 用户定义了回调函数\n      var callbackParams = fields.map(function (field) {\n        return data[FIELD_ORIGIN][field];\n      });\n      var cfg = callback.apply(void 0, __spreadArray([], __read(callbackParams), false));\n      var itemCfg = __assign({\n        data: data[FIELD_ORIGIN],\n        mappingData: data,\n        title: tooltipTitle,\n        color: data.color || defaultColor,\n        marker: true\n      }, cfg);\n      items.push(itemCfg);\n    } else {\n      var scales = geometry.scales;\n      try {\n        for (var fields_1 = __values(fields), fields_1_1 = fields_1.next(); !fields_1_1.done; fields_1_1 = fields_1.next()) {\n          var field = fields_1_1.value;\n          if (!isNil(originData[field])) {\n            // 字段数据为null, undefined 时不显示\n            var scale = scales[field];\n            name = getName(scale);\n            value = scale.getText(originData[field]);\n            addItem(name, value);\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (fields_1_1 && !fields_1_1.done && (_a = fields_1.return)) _a.call(fields_1);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    }\n  } else {\n    var valueScale = getTooltipValueScale(geometry);\n    // 字段数据为null ,undefined时不显示\n    value = getTooltipValue(originData, valueScale);\n    name = getTooltipName(originData, geometry);\n    addItem(name, value);\n  }\n  return items;\n}\nfunction getTooltipItemsByFindData(geometry, point, title, tooltipCfg) {\n  var e_3, _a;\n  var showNil = tooltipCfg.showNil;\n  var result = [];\n  var dataArray = geometry.dataArray;\n  if (!isEmpty(dataArray)) {\n    geometry.sort(dataArray); // 先进行排序，便于 tooltip 查找\n    try {\n      for (var dataArray_1 = __values(dataArray), dataArray_1_1 = dataArray_1.next(); !dataArray_1_1.done; dataArray_1_1 = dataArray_1.next()) {\n        var data = dataArray_1_1.value;\n        var record = findDataByPoint(point, data, geometry);\n        if (record) {\n          var elementId = geometry.getElementId(record);\n          var element = geometry.elementsMap[elementId];\n          if (geometry.type === 'heatmap' || element.visible) {\n            // Heatmap 没有 Element\n            // 如果图形元素隐藏了，怎不再 tooltip 上展示相关数据\n            var items = getTooltipItems(record, geometry, title, showNil);\n            if (items.length) {\n              result.push(items);\n            }\n          }\n        }\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (dataArray_1_1 && !dataArray_1_1.done && (_a = dataArray_1.return)) _a.call(dataArray_1);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n  }\n  return result;\n}\nfunction getTooltipItemsByHitShape(geometry, point, title, tooltipCfg) {\n  var showNil = tooltipCfg.showNil;\n  var result = [];\n  var container = geometry.container;\n  var shape = container.getShape(point.x, point.y);\n  if (shape && shape.get('visible') && shape.get('origin')) {\n    var mappingData = shape.get('origin').mappingData;\n    var items = getTooltipItems(mappingData, geometry, title, showNil);\n    if (items.length) {\n      result.push(items);\n    }\n  }\n  return result;\n}\n/**\n * 不进行递归查找\n */\nexport function findItemsFromView(view, point, tooltipCfg) {\n  var e_4, _a;\n  var result = [];\n  // 先从 view 本身查找\n  var geometries = view.geometries;\n  var shared = tooltipCfg.shared,\n    title = tooltipCfg.title,\n    reversed = tooltipCfg.reversed;\n  try {\n    for (var geometries_1 = __values(geometries), geometries_1_1 = geometries_1.next(); !geometries_1_1.done; geometries_1_1 = geometries_1.next()) {\n      var geometry = geometries_1_1.value;\n      if (geometry.visible && geometry.tooltipOption !== false) {\n        // geometry 可见同时未关闭 tooltip\n        var geometryType = geometry.type;\n        var tooltipItems = void 0;\n        if (['point', 'edge', 'polygon'].includes(geometryType)) {\n          // 始终通过图形拾取\n          tooltipItems = getTooltipItemsByHitShape(geometry, point, title, tooltipCfg);\n        } else if (['area', 'line', 'path', 'heatmap'].includes(geometryType)) {\n          // 如果是 'area', 'line', 'path'，始终通过数据查找方法查找 tooltip\n          tooltipItems = getTooltipItemsByFindData(geometry, point, title, tooltipCfg);\n        } else {\n          if (shared !== false) {\n            tooltipItems = getTooltipItemsByFindData(geometry, point, title, tooltipCfg);\n          } else {\n            tooltipItems = getTooltipItemsByHitShape(geometry, point, title, tooltipCfg);\n          }\n        }\n        if (tooltipItems.length) {\n          if (reversed) {\n            tooltipItems.reverse();\n          }\n          // geometry 有可能会有多个 item，因为用户可以设置 geometry.tooltip('x*y*z')\n          result.push(tooltipItems);\n        }\n      }\n    }\n  } catch (e_4_1) {\n    e_4 = {\n      error: e_4_1\n    };\n  } finally {\n    try {\n      if (geometries_1_1 && !geometries_1_1.done && (_a = geometries_1.return)) _a.call(geometries_1);\n    } finally {\n      if (e_4) throw e_4.error;\n    }\n  }\n  return result;\n}\nexport function findItemsFromViewRecurisive(view, point, tooltipCfg) {\n  var e_5, _a;\n  var result = findItemsFromView(view, point, tooltipCfg);\n  try {\n    // 递归查找，并合并结果\n    for (var _b = __values(view.views), _c = _b.next(); !_c.done; _c = _b.next()) {\n      var childView = _c.value;\n      result = result.concat(findItemsFromView(childView, point, tooltipCfg));\n    }\n  } catch (e_5_1) {\n    e_5 = {\n      error: e_5_1\n    };\n  } finally {\n    try {\n      if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n    } finally {\n      if (e_5) throw e_5.error;\n    }\n  }\n  return result;\n}","map":{"version":3,"sources":["../../src/util/tooltip.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  contains,\n  filter,\n  find,\n  isArray,\n  isEmpty,\n  isFunction,\n  isNil,\n  isNumberEqual,\n  isObject,\n  memoize,\n  get,\n  values,\n} from '@antv/util';\nimport { View } from '../chart';\nimport { FIELD_ORIGIN, GROUP_ATTRS } from '../constant';\nimport { Attribute, Scale } from '../dependents';\nimport Geometry from '../geometry/base';\nimport { Data, Datum, MappingDatum, Point, TooltipCfg, TooltipTitle } from '../interface';\nimport { getName, inferScaleType } from './scale';\n\nfunction snapEqual(v1: any, v2: any, scale: Scale) {\n  const value1 = scale.translate(v1);\n  const value2 = scale.translate(v2);\n\n  return isNumberEqual(value1, value2);\n}\n\nfunction getXValueByPoint(point: Point, geometry: Geometry): number {\n  const coordinate = geometry.coordinate;\n  const xScale = geometry.getXScale();\n  const range = xScale.range;\n  const rangeMax = range[range.length - 1];\n  const rangeMin = range[0];\n\n  const invertPoint = coordinate.invert(point);\n\n  let xValue = invertPoint.x;\n  if (coordinate.isPolar && xValue > (1 + rangeMax) / 2) {\n    xValue = rangeMin; // 极坐标下，scale 的 range 被做过特殊处理\n  }\n  return xScale.translate(xScale.invert(xValue));\n}\n\nfunction filterYValue(data: Data, point: Point, geometry: Geometry) {\n  const coordinate = geometry.coordinate;\n  const yScale = geometry.getYScale();\n  const yField = yScale.field;\n  const invertPoint = coordinate.invert(point);\n  const yValue = yScale.invert(invertPoint.y);\n\n  const result = find(data, (obj: Datum) => {\n    const originData = obj[FIELD_ORIGIN];\n    return originData[yField][0] <= yValue && originData[yField][1] >= yValue;\n  });\n  return result || data[data.length - 1];\n}\n\nconst getXDistance = memoize((scale: Scale) => {\n  if (scale.isCategory) {\n    return 1;\n  }\n  const scaleValues = scale.values; // values 是无序的\n  const length = scaleValues.length;\n  let min = scale.translate(scaleValues[0]);\n  let max = min;\n\n  for (let index = 0; index < length; index++) {\n    const value = scaleValues[index];\n    // 时间类型需要 translate\n    const numericValue = scale.translate(value);\n    if (numericValue < min) {\n      min = numericValue;\n    }\n    if (numericValue > max) {\n      max = numericValue;\n    }\n  }\n  return (max - min) / (length - 1);\n});\n\n/**\n * 获得 tooltip 的 title\n * @param originData\n * @param geometry\n * @param title\n */\nfunction getTooltipTitle(originData: Datum, geometry: Geometry, title: TooltipTitle): string {\n  const positionAttr = geometry.getAttribute('position');\n  const fields = positionAttr.getFields();\n  const scales = geometry.scales;\n\n  const titleField = isFunction(title) || !title ? fields[0] : title;\n  const titleScale = scales[titleField];\n\n  // 如果创建了该字段对应的 scale，则通过 scale.getText() 方式取值，因为用户可能对数据进行了格式化\n  // 如果没有对应的 scale，则从原始数据中取值，如果原始数据中仍不存在，则直接放回 title 值\n  const tooltipTitle = titleScale ? titleScale.getText(originData[titleField]) : originData[titleField] || titleField;\n\n  return isFunction(title) ? title(tooltipTitle, originData) : tooltipTitle;\n}\n\nfunction getAttributesForLegend(geometry: Geometry) {\n  const attributes = values(geometry.attributes);\n  return filter(attributes, (attribute: Attribute) => contains(GROUP_ATTRS, attribute.type));\n}\n\nfunction getTooltipValueScale(geometry: Geometry) {\n  const attributes = getAttributesForLegend(geometry);\n  let scale;\n  for (const attribute of attributes) {\n    const tmpScale = attribute.getScale(attribute.type);\n    if (tmpScale && tmpScale.isLinear) {\n      const tmpScaleDef = get(geometry.scaleDefs, tmpScale.field);\n      const inferedScaleType = inferScaleType(tmpScale, tmpScaleDef, attribute.type, geometry.type);\n      if (inferedScaleType !== 'cat') {\n        // 如果指定字段是非 position 的，同时是连续的\n        scale = tmpScale;\n        break;\n      }\n    }\n  }\n\n  const xScale = geometry.getXScale();\n  const yScale = geometry.getYScale();\n\n  return scale || yScale || xScale;\n}\n\nfunction getTooltipValue(originData: Datum, valueScale: Scale) {\n  const field = valueScale.field;\n  const value = originData[field];\n\n  if (isArray(value)) {\n    const texts = value.map((eachValue) => {\n      return valueScale.getText(eachValue);\n    });\n    return texts.join('-');\n  }\n  return valueScale.getText(value);\n}\n\n// 根据原始数据获取 tooltip item 中 name 值\nfunction getTooltipName(originData: Datum, geometry: Geometry) {\n  let nameScale: Scale;\n  const groupScales = geometry.getGroupScales();\n  if (groupScales.length) {\n    // 如果存在分组类型，取第一个分组类型\n    nameScale = groupScales[0];\n  }\n  if (nameScale) {\n    const field = nameScale.field;\n    return nameScale.getText(originData[field]);\n  }\n\n  const valueScale = getTooltipValueScale(geometry);\n  return getName(valueScale);\n}\n\n/**\n * @ignore\n * Finds data from geometry by point\n * @param point canvas point\n * @param data an item of geometry.dataArray\n * @param geometry\n * @returns\n */\nexport function findDataByPoint(point: Point, data: MappingDatum[], geometry: Geometry) {\n  if (data.length === 0) {\n    return null;\n  }\n\n  const geometryType = geometry.type;\n  const xScale = geometry.getXScale();\n  const yScale = geometry.getYScale();\n\n  const xField = xScale.field;\n  const yField = yScale.field;\n\n  let rst = null;\n\n  // 热力图采用最小逼近策略查找 point 击中的数据\n  if (geometryType === 'heatmap' || geometryType === 'point') {\n    // 将 point 画布坐标转换为原始数据值\n    const coordinate = geometry.coordinate;\n    const invertPoint = coordinate.invert(point); // 转换成归一化的数据\n    const x = xScale.invert(invertPoint.x); // 转换为原始值\n    const y = yScale.invert(invertPoint.y); // 转换为原始值\n\n    let min = Infinity;\n    for (let index = 0; index < data.length; index++) {\n      const obj = data[index];\n      const originData = obj[FIELD_ORIGIN];\n      const range = (originData[xField] - x) ** 2 + (originData[yField] - y) ** 2;\n      if (range < min) {\n        min = range;\n        rst = obj;\n      }\n    }\n\n    return rst;\n  }\n\n  // 其他 Geometry 类型按照 x 字段数据进行查找\n  const first = data[0];\n  let last = data[data.length - 1];\n  const xValue = getXValueByPoint(point, geometry);\n  const firstXValue = first[FIELD_ORIGIN][xField];\n  const firstYValue = first[FIELD_ORIGIN][yField];\n  const lastXValue = last[FIELD_ORIGIN][xField];\n  const isYArray = yScale.isLinear && isArray(firstYValue); // 考虑 x 维度相同，y 是数组区间的情况\n\n  // 如果 x 的值是数组\n  if (isArray(firstXValue)) {\n    for (let index = 0; index < data.length; index++) {\n      const record = data[index];\n      const originData = record[FIELD_ORIGIN];\n      // xValue 在 originData[xField] 的数值区间内\n      if (xScale.translate(originData[xField][0]) <= xValue && xScale.translate(originData[xField][1]) >= xValue) {\n        if (isYArray) {\n          // 层叠直方图场景，x 和 y 都是数组区间\n          if (!isArray(rst)) {\n            rst = [];\n          }\n          rst.push(record);\n        } else {\n          rst = record;\n          break;\n        }\n      }\n    }\n    if (isArray(rst)) {\n      rst = filterYValue(rst, point, geometry);\n    }\n  } else {\n    let next;\n    if (!xScale.isLinear && xScale.type !== 'timeCat') {\n      // x 轴对应的数据为非线性以及非时间类型的数据采用遍历查找\n      for (let index = 0; index < data.length; index++) {\n        const record = data[index];\n        const originData = record[FIELD_ORIGIN];\n        if (snapEqual(originData[xField], xValue, xScale)) {\n          if (isYArray) {\n            if (!isArray(rst)) {\n              rst = [];\n            }\n            rst.push(record);\n          } else {\n            rst = record;\n            break;\n          }\n        } else if (xScale.translate(originData[xField]) <= xValue) {\n          last = record;\n          next = data[index + 1];\n        }\n      }\n\n      if (isArray(rst)) {\n        rst = filterYValue(rst, point, geometry);\n      }\n    } else {\n      // x 轴对应的数据为线性以及时间类型，进行二分查找，性能更好\n      if (\n        (xValue > xScale.translate(lastXValue) || xValue < xScale.translate(firstXValue)) &&\n        (xValue > xScale.max || xValue < xScale.min)\n      ) {\n        // 不在数据范围内\n        return null;\n      }\n\n      let firstIdx = 0;\n      let lastIdx = data.length - 1;\n      let middleIdx;\n      while (firstIdx <= lastIdx) {\n        middleIdx = Math.floor((firstIdx + lastIdx) / 2);\n        const item = data[middleIdx][FIELD_ORIGIN][xField];\n        if (snapEqual(item, xValue, xScale)) {\n          return data[middleIdx];\n        }\n\n        if (xScale.translate(item) <= xScale.translate(xValue)) {\n          firstIdx = middleIdx + 1;\n          last = data[middleIdx];\n          next = data[middleIdx + 1];\n        } else {\n          if (lastIdx === 0) {\n            last = data[0];\n          }\n          lastIdx = middleIdx - 1;\n        }\n      }\n    }\n\n    if (last && next) {\n      // 计算最逼近的\n      if (\n        Math.abs(xScale.translate(last[FIELD_ORIGIN][xField]) - xValue) >\n        Math.abs(xScale.translate(next[FIELD_ORIGIN][xField]) - xValue)\n      ) {\n        last = next;\n      }\n    }\n  }\n\n  const distance = getXDistance(geometry.getXScale()); // 每个分类间的平均间距\n  if (!rst && Math.abs(xScale.translate(last[FIELD_ORIGIN][xField]) - xValue) <= distance / 2) {\n    rst = last;\n  }\n\n  return rst;\n}\n\n/**\n * @ignore\n * Gets tooltip items\n * @param data\n * @param geometry\n * @param [title]\n * @returns\n */\nexport function getTooltipItems(\n  data: MappingDatum,\n  geometry: Geometry,\n  title: TooltipTitle = '',\n  showNil: boolean = false\n) {\n  const originData = data[FIELD_ORIGIN];\n  const tooltipTitle = getTooltipTitle(originData, geometry, title);\n  const tooltipOption = geometry.tooltipOption;\n  const { defaultColor } = geometry.theme;\n  const items = [];\n  let name;\n  let value;\n\n  function addItem(itemName, itemValue) {\n    if (showNil || (!isNil(itemValue) && itemValue !== '')) {\n      // 值为 null的时候，忽视\n      const item = {\n        title: tooltipTitle,\n        data: originData, // 原始数据\n        mappingData: data, // 映射后的数据\n        name: itemName,\n        value: itemValue,\n        color: data.color || defaultColor,\n        marker: true,\n      };\n\n      items.push(item);\n    }\n  }\n\n  if (isObject(tooltipOption)) {\n    const { fields, callback } = tooltipOption;\n    if (callback) {\n      // 用户定义了回调函数\n      const callbackParams = fields.map((field: string) => {\n        return data[FIELD_ORIGIN][field];\n      });\n      const cfg = callback(...callbackParams);\n      const itemCfg = {\n        data: data[FIELD_ORIGIN], // 原始数据\n        mappingData: data, // 映射后的数据\n        title: tooltipTitle,\n        color: data.color || defaultColor,\n        marker: true, // 默认展示 marker\n        ...cfg,\n      };\n\n      items.push(itemCfg);\n    } else {\n      const scales = geometry.scales;\n      for (const field of fields) {\n        if (!isNil(originData[field])) {\n          // 字段数据为null, undefined 时不显示\n          const scale = scales[field];\n          name = getName(scale);\n          value = scale.getText(originData[field]);\n          addItem(name, value);\n        }\n      }\n    }\n  } else {\n    const valueScale = getTooltipValueScale(geometry);\n    // 字段数据为null ,undefined时不显示\n    value = getTooltipValue(originData, valueScale);\n    name = getTooltipName(originData, geometry);\n    addItem(name, value);\n  }\n  return items;\n}\n\nfunction getTooltipItemsByFindData(geometry: Geometry, point, title, tooltipCfg: TooltipCfg) {\n  const { showNil } = tooltipCfg;\n  const result = [];\n  const dataArray = geometry.dataArray;\n  if (!isEmpty(dataArray)) {\n    geometry.sort(dataArray); // 先进行排序，便于 tooltip 查找\n    for (const data of dataArray) {\n      const record = findDataByPoint(point, data, geometry);\n      if (record) {\n        const elementId = geometry.getElementId(record);\n        const element = geometry.elementsMap[elementId];\n        if (geometry.type === 'heatmap' || element.visible) {\n          // Heatmap 没有 Element\n          // 如果图形元素隐藏了，怎不再 tooltip 上展示相关数据\n          const items = getTooltipItems(record, geometry, title, showNil);\n          if (items.length) {\n            result.push(items);\n          }\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction getTooltipItemsByHitShape(geometry, point, title, tooltipCfg: TooltipCfg) {\n  const { showNil } = tooltipCfg;\n  const result = [];\n  const container = geometry.container;\n  const shape = container.getShape(point.x, point.y);\n  if (shape && shape.get('visible') && shape.get('origin')) {\n    const mappingData = shape.get('origin').mappingData;\n    const items = getTooltipItems(mappingData, geometry, title, showNil);\n    if (items.length) {\n      result.push(items);\n    }\n  }\n\n  return result;\n}\n\n/**\n * 不进行递归查找\n */\nexport function findItemsFromView(view: View, point: Point, tooltipCfg: TooltipCfg) {\n  const result = [];\n  // 先从 view 本身查找\n  const geometries = view.geometries;\n  const { shared, title, reversed } = tooltipCfg;\n  for (const geometry of geometries) {\n    if (geometry.visible && geometry.tooltipOption !== false) {\n      // geometry 可见同时未关闭 tooltip\n      const geometryType = geometry.type;\n      let tooltipItems;\n      if (['point', 'edge', 'polygon'].includes(geometryType)) {\n        // 始终通过图形拾取\n        tooltipItems = getTooltipItemsByHitShape(geometry, point, title, tooltipCfg);\n      } else if (['area', 'line', 'path', 'heatmap'].includes(geometryType)) {\n        // 如果是 'area', 'line', 'path'，始终通过数据查找方法查找 tooltip\n        tooltipItems = getTooltipItemsByFindData(geometry, point, title, tooltipCfg);\n      } else {\n        if (shared !== false) {\n          tooltipItems = getTooltipItemsByFindData(geometry, point, title, tooltipCfg);\n        } else {\n          tooltipItems = getTooltipItemsByHitShape(geometry, point, title, tooltipCfg);\n        }\n      }\n      if (tooltipItems.length) {\n        if (reversed) {\n          tooltipItems.reverse();\n        }\n        // geometry 有可能会有多个 item，因为用户可以设置 geometry.tooltip('x*y*z')\n        result.push(tooltipItems);\n      }\n    }\n  }\n\n  return result;\n}\n\nexport function findItemsFromViewRecurisive(view: View, point: Point, tooltipCfg: TooltipCfg) {\n  let result = findItemsFromView(view, point, tooltipCfg);\n\n  // 递归查找，并合并结果\n  for (const childView of view.views) {\n    result = result.concat(findItemsFromView(childView, point, tooltipCfg));\n  }\n\n  return result;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}