{"ast":null,"code":"import parsePathString from './parse-path-string';\nvar REGEX_MD = /[a-z]/;\nfunction toSymmetry(p, c) {\n  return [c[0] + (c[0] - p[0]), c[1] + (c[1] - p[1])];\n}\nexport default function pathToAbsolute(pathString) {\n  var pathArray = parsePathString(pathString);\n  if (!pathArray || !pathArray.length) {\n    return [['M', 0, 0]];\n  }\n  var needProcess = false; // 如果存在小写的命令或者 V,H,T,S 则需要处理\n  for (var i = 0; i < pathArray.length; i++) {\n    var cmd = pathArray[i][0];\n    // 如果存在相对位置的命令，则中断返回\n    if (REGEX_MD.test(cmd) || ['V', 'H', 'T', 'S'].indexOf(cmd) >= 0) {\n      needProcess = true;\n      break;\n    }\n  }\n  // 如果不存在相对命令，则直接返回\n  // 如果在业务上都写绝对路径，这种方式最快，仅做了一次检测\n  if (!needProcess) {\n    return pathArray;\n  }\n  var res = [];\n  var x = 0;\n  var y = 0;\n  var mx = 0;\n  var my = 0;\n  var start = 0;\n  var pa0;\n  var dots;\n  var first = pathArray[0];\n  if (first[0] === 'M' || first[0] === 'm') {\n    x = +first[1];\n    y = +first[2];\n    mx = x;\n    my = y;\n    start++;\n    res[0] = ['M', x, y];\n  }\n  for (var i = start, ii = pathArray.length; i < ii; i++) {\n    var pa = pathArray[i];\n    var preParams = res[i - 1]; // 取前一个已经处理后的节点，否则会出现问题\n    var r = [];\n    var cmd = pa[0];\n    var upCmd = cmd.toUpperCase();\n    if (cmd !== upCmd) {\n      r[0] = upCmd;\n      switch (upCmd) {\n        case 'A':\n          r[1] = pa[1];\n          r[2] = pa[2];\n          r[3] = pa[3];\n          r[4] = pa[4];\n          r[5] = pa[5];\n          r[6] = +pa[6] + x;\n          r[7] = +pa[7] + y;\n          break;\n        case 'V':\n          r[1] = +pa[1] + y;\n          break;\n        case 'H':\n          r[1] = +pa[1] + x;\n          break;\n        case 'M':\n          mx = +pa[1] + x;\n          my = +pa[2] + y;\n          r[1] = mx;\n          r[2] = my;\n          break;\n        // for lint\n        default:\n          for (var j = 1, jj = pa.length; j < jj; j++) {\n            r[j] = +pa[j] + (j % 2 ? x : y);\n          }\n      }\n    } else {\n      // 如果本来已经大写，则不处理\n      r = pathArray[i];\n    }\n    // 需要在外面统一做，同时处理 V,H,S,T 等特殊指令\n    switch (upCmd) {\n      case 'Z':\n        x = +mx;\n        y = +my;\n        break;\n      case 'H':\n        x = r[1];\n        r = ['L', x, y];\n        break;\n      case 'V':\n        y = r[1];\n        r = ['L', x, y];\n        break;\n      case 'T':\n        x = r[1];\n        y = r[2];\n        // 以 x, y 为中心的，上一个控制点的对称点\n        // 需要假设上一个节点的命令为 Q\n        var symetricT = toSymmetry([preParams[1], preParams[2]], [preParams[3], preParams[4]]);\n        r = ['Q', symetricT[0], symetricT[1], x, y];\n        break;\n      case 'S':\n        x = r[r.length - 2];\n        y = r[r.length - 1];\n        // 以 x,y 为中心，取上一个控制点，\n        // 需要假设上一个线段为 C 或者 S\n        var length_1 = preParams.length;\n        var symetricS = toSymmetry([preParams[length_1 - 4], preParams[length_1 - 3]], [preParams[length_1 - 2], preParams[length_1 - 1]]);\n        r = ['C', symetricS[0], symetricS[1], r[1], r[2], x, y];\n        break;\n      case 'M':\n        mx = r[r.length - 2];\n        my = r[r.length - 1];\n        break;\n      // for lint\n      default:\n        x = r[r.length - 2];\n        y = r[r.length - 1];\n    }\n    res.push(r);\n  }\n  return res;\n}","map":{"version":3,"sources":["../src/path-2-absolute.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import parsePathString from './parse-path-string';\nvar REGEX_MD = /[a-z]/;\nfunction toSymmetry(p, c) {\n    return [\n        c[0] + (c[0] - p[0]),\n        c[1] + (c[1] - p[1]),\n    ];\n}\nexport default function pathToAbsolute(pathString) {\n    var pathArray = parsePathString(pathString);\n    if (!pathArray || !pathArray.length) {\n        return [\n            ['M', 0, 0],\n        ];\n    }\n    var needProcess = false; // 如果存在小写的命令或者 V,H,T,S 则需要处理\n    for (var i = 0; i < pathArray.length; i++) {\n        var cmd = pathArray[i][0];\n        // 如果存在相对位置的命令，则中断返回\n        if (REGEX_MD.test(cmd) || ['V', 'H', 'T', 'S'].indexOf(cmd) >= 0) {\n            needProcess = true;\n            break;\n        }\n    }\n    // 如果不存在相对命令，则直接返回\n    // 如果在业务上都写绝对路径，这种方式最快，仅做了一次检测\n    if (!needProcess) {\n        return pathArray;\n    }\n    var res = [];\n    var x = 0;\n    var y = 0;\n    var mx = 0;\n    var my = 0;\n    var start = 0;\n    var pa0;\n    var dots;\n    var first = pathArray[0];\n    if (first[0] === 'M' || first[0] === 'm') {\n        x = +first[1];\n        y = +first[2];\n        mx = x;\n        my = y;\n        start++;\n        res[0] = ['M', x, y];\n    }\n    for (var i = start, ii = pathArray.length; i < ii; i++) {\n        var pa = pathArray[i];\n        var preParams = res[i - 1]; // 取前一个已经处理后的节点，否则会出现问题\n        var r = [];\n        var cmd = pa[0];\n        var upCmd = cmd.toUpperCase();\n        if (cmd !== upCmd) {\n            r[0] = upCmd;\n            switch (upCmd) {\n                case 'A':\n                    r[1] = pa[1];\n                    r[2] = pa[2];\n                    r[3] = pa[3];\n                    r[4] = pa[4];\n                    r[5] = pa[5];\n                    r[6] = +pa[6] + x;\n                    r[7] = +pa[7] + y;\n                    break;\n                case 'V':\n                    r[1] = +pa[1] + y;\n                    break;\n                case 'H':\n                    r[1] = +pa[1] + x;\n                    break;\n                case 'M':\n                    mx = +pa[1] + x;\n                    my = +pa[2] + y;\n                    r[1] = mx;\n                    r[2] = my;\n                    break; // for lint\n                default:\n                    for (var j = 1, jj = pa.length; j < jj; j++) {\n                        r[j] = +pa[j] + ((j % 2) ? x : y);\n                    }\n            }\n        }\n        else { // 如果本来已经大写，则不处理\n            r = pathArray[i];\n        }\n        // 需要在外面统一做，同时处理 V,H,S,T 等特殊指令\n        switch (upCmd) {\n            case 'Z':\n                x = +mx;\n                y = +my;\n                break;\n            case 'H':\n                x = r[1];\n                r = ['L', x, y];\n                break;\n            case 'V':\n                y = r[1];\n                r = ['L', x, y];\n                break;\n            case 'T':\n                x = r[1];\n                y = r[2];\n                // 以 x, y 为中心的，上一个控制点的对称点\n                // 需要假设上一个节点的命令为 Q\n                var symetricT = toSymmetry([preParams[1], preParams[2]], [preParams[3], preParams[4]]);\n                r = ['Q', symetricT[0], symetricT[1], x, y];\n                break;\n            case 'S':\n                x = r[r.length - 2];\n                y = r[r.length - 1];\n                // 以 x,y 为中心，取上一个控制点，\n                // 需要假设上一个线段为 C 或者 S\n                var length_1 = preParams.length;\n                var symetricS = toSymmetry([preParams[length_1 - 4], preParams[length_1 - 3]], [preParams[length_1 - 2], preParams[length_1 - 1]]);\n                r = ['C', symetricS[0], symetricS[1], r[1], r[2], x, y];\n                break;\n            case 'M':\n                mx = r[r.length - 2];\n                my = r[r.length - 1];\n                break; // for lint\n            default:\n                x = r[r.length - 2];\n                y = r[r.length - 1];\n        }\n        res.push(r);\n    }\n    return res;\n}\n//# sourceMappingURL=path-2-absolute.js.map"]},"metadata":{},"sourceType":"module"}