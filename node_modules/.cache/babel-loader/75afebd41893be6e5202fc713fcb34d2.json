{"ast":null,"code":"/**\n * 碰撞检测算法\n */\nexport function antiCollision(items, labelHeight, plotRange) {\n  var labels = items.filter(function (item) {\n    return !item.invisible;\n  });\n  // sorted by y, mutable\n  labels.sort(function (a, b) {\n    return a.y - b.y;\n  });\n  // adjust y position of labels to avoid overlapping\n  var overlapping = true;\n  var startY = plotRange.minY;\n  var endY = plotRange.maxY;\n  var totalHeight = Math.abs(startY - endY);\n  var i;\n  var maxY = 0;\n  var minY = Number.MIN_VALUE;\n  var boxes = labels.map(function (label) {\n    if (label.y > maxY) {\n      maxY = label.y;\n    }\n    if (label.y < minY) {\n      minY = label.y;\n    }\n    return {\n      content: label.content,\n      size: labelHeight,\n      targets: [label.y - startY],\n      pos: null\n    };\n  });\n  minY -= startY;\n  if (maxY - startY > totalHeight) {\n    totalHeight = maxY - startY;\n  }\n  while (overlapping) {\n    /* eslint no-loop-func: 0 */\n    boxes.forEach(function (box) {\n      var target = (Math.min.apply(minY, box.targets) + Math.max.apply(minY, box.targets)) / 2;\n      box.pos = Math.min(Math.max(minY, target - box.size / 2), totalHeight - box.size);\n      box.pos = Math.max(0, box.pos);\n    });\n    // detect overlapping and join boxes\n    overlapping = false;\n    i = boxes.length;\n    while (i--) {\n      if (i > 0) {\n        var previousBox = boxes[i - 1];\n        var box = boxes[i];\n        if (previousBox.pos + previousBox.size > box.pos) {\n          // overlapping\n          previousBox.size += box.size;\n          previousBox.targets = previousBox.targets.concat(box.targets);\n          // overflow, shift up\n          if (previousBox.pos + previousBox.size > totalHeight) {\n            previousBox.pos = totalHeight - previousBox.size;\n          }\n          boxes.splice(i, 1); // removing box\n          overlapping = true;\n        }\n      }\n    }\n  }\n  i = 0;\n  // step 4: normalize y and adjust x\n  boxes.forEach(function (b) {\n    var posInCompositeBox = startY + labelHeight / 2; // middle of the label\n    b.targets.forEach(function () {\n      labels[i].y = b.pos + posInCompositeBox;\n      posInCompositeBox += labelHeight;\n      i++;\n    });\n  });\n}","map":{"version":3,"sources":["../../../../../src/geometry/label/layout/pie/util.ts"],"names":[],"mappings":"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","sourcesContent":["import { PolarLabelItem } from '../../interface';\n\n/**\n * 碰撞检测算法\n */\nexport function antiCollision(\n  items: PolarLabelItem[],\n  labelHeight: number,\n  plotRange: { minY: number; maxY: number; minX: number; maxX: number }\n) {\n  const labels = items.filter((item) => !item.invisible);\n\n  // sorted by y, mutable\n  labels.sort((a, b) => a.y - b.y);\n  // adjust y position of labels to avoid overlapping\n  let overlapping = true;\n  const startY = plotRange.minY;\n  const endY = plotRange.maxY;\n  let totalHeight = Math.abs(startY - endY);\n  let i;\n\n  let maxY = 0;\n  let minY = Number.MIN_VALUE;\n  const boxes = labels.map((label) => {\n    if (label.y > maxY) {\n      maxY = label.y;\n    }\n    if (label.y < minY) {\n      minY = label.y;\n    }\n    return {\n      content: label.content,\n      size: labelHeight,\n      targets: [label.y - startY],\n      pos: null,\n    };\n  });\n\n  minY -= startY;\n  if (maxY - startY > totalHeight) {\n    totalHeight = maxY - startY;\n  }\n\n  while (overlapping) {\n    /* eslint no-loop-func: 0 */\n    boxes.forEach((box) => {\n      const target = (Math.min.apply(minY, box.targets) + Math.max.apply(minY, box.targets)) / 2;\n      box.pos = Math.min(Math.max(minY, target - box.size / 2), totalHeight - box.size);\n      box.pos = Math.max(0, box.pos);\n    });\n\n    // detect overlapping and join boxes\n    overlapping = false;\n    i = boxes.length;\n    while (i--) {\n      if (i > 0) {\n        const previousBox = boxes[i - 1];\n        const box = boxes[i];\n        if (previousBox.pos + previousBox.size > box.pos) {\n          // overlapping\n          previousBox.size += box.size;\n          previousBox.targets = previousBox.targets.concat(box.targets);\n\n          // overflow, shift up\n          if (previousBox.pos + previousBox.size > totalHeight) {\n            previousBox.pos = totalHeight - previousBox.size;\n          }\n          boxes.splice(i, 1); // removing box\n          overlapping = true;\n        }\n      }\n    }\n  }\n\n  i = 0;\n  // step 4: normalize y and adjust x\n  boxes.forEach((b) => {\n    let posInCompositeBox = startY + labelHeight / 2; // middle of the label\n    b.targets.forEach(() => {\n      labels[i].y = b.pos + posInCompositeBox;\n      posInCompositeBox += labelHeight;\n      i++;\n    });\n  });\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}