{"ast":null,"code":"/**\n * @file utils of label\n */\nimport { isNil, isNumber, some } from '@antv/util';\nimport { rotate } from '../../../util/transform';\n/**\n * 查找 Label Group 中的文本 shape 对象\n * @param label\n */\nexport function findLabelTextShape(label) {\n  return label.find(function (el) {\n    return el.get('type') === 'text';\n  });\n}\n/**\n * 获取标签背景信息: box (无旋转) + rotation (旋转角度)\n */\nexport function getLabelBackgroundInfo(labelGroup, labelItem, padding) {\n  if (padding === void 0) {\n    padding = [0, 0, 0, 0];\n  }\n  var content = labelGroup && labelGroup.getChildren()[0];\n  if (content) {\n    var labelShape = content.clone();\n    // revert rotate\n    if (labelItem === null || labelItem === void 0 ? void 0 : labelItem.rotate) {\n      rotate(labelShape, -labelItem.rotate);\n    }\n    // use `getCanvasBBox`, because if Shape is been translated, `getBBox` is not the actual box position\n    var _a = labelShape.getCanvasBBox(),\n      x = _a.x,\n      y = _a.y,\n      width = _a.width,\n      height = _a.height;\n    labelShape.destroy();\n    var boxPadding = padding;\n    if (isNil(boxPadding)) {\n      boxPadding = [2, 2, 2, 2];\n    } else if (isNumber(boxPadding)) {\n      boxPadding = new Array(4).fill(boxPadding);\n    }\n    return {\n      x: x - boxPadding[3],\n      y: y - boxPadding[0],\n      width: width + boxPadding[1] + boxPadding[3],\n      height: height + boxPadding[0] + boxPadding[2],\n      rotation: (labelItem === null || labelItem === void 0 ? void 0 : labelItem.rotate) || 0\n    };\n  }\n  return {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0,\n    rotation: 0\n  };\n}\n/**\n * 计算两个矩形之间的堆叠区域面积\n */\nexport function getOverlapArea(a, b, margin) {\n  if (margin === void 0) {\n    margin = 0;\n  }\n  var xOverlap = Math.max(0, Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin));\n  var yOverlap = Math.max(0, Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin));\n  return xOverlap * yOverlap;\n}\n/** 检测是否和已布局的堆叠 */\nexport function checkShapeOverlap(cur, dones) {\n  var box = cur.getBBox();\n  return some(dones, function (done) {\n    var target = done.getBBox();\n    return getOverlapArea(box, target, 2) > 0;\n  });\n}","map":{"version":3,"sources":["../../../../src/geometry/label/util/index.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @file utils of label\n */\n\nimport { isNil, isNumber, some } from '@antv/util';\nimport { IElement, IGroup, BBox } from '../../../dependents';\nimport { rotate } from '../../../util/transform';\n\n/**\n * 查找 Label Group 中的文本 shape 对象\n * @param label\n */\nexport function findLabelTextShape(label: IGroup): IElement {\n  return label.find((el) => el.get('type') === 'text');\n}\n\n/**\n * 获取标签背景信息: box (无旋转) + rotation (旋转角度)\n */\nexport function getLabelBackgroundInfo(\n  labelGroup: IGroup,\n  labelItem: { rotate?: number;[key: string]: any },\n  padding: number | number[] = [0, 0, 0, 0]\n): { x: number; y: number; width: number; height: number; rotation: number } {\n  const content = labelGroup && labelGroup.getChildren()[0];\n  if (content) {\n    const labelShape = content.clone();\n\n    // revert rotate\n    if (labelItem?.rotate) {\n      rotate(labelShape as IGroup, -labelItem.rotate);\n    }\n\n    // use `getCanvasBBox`, because if Shape is been translated, `getBBox` is not the actual box position\n    const { x, y, width, height } = labelShape.getCanvasBBox();\n\n    labelShape.destroy();\n\n    let boxPadding = padding;\n    if (isNil(boxPadding)) {\n      boxPadding = [2, 2, 2, 2];\n    } else if (isNumber(boxPadding)) {\n      boxPadding = new Array(4).fill(boxPadding);\n    }\n\n    return {\n      x: x - boxPadding[3],\n      y: y - boxPadding[0],\n      width: width + boxPadding[1] + boxPadding[3],\n      height: height + boxPadding[0] + boxPadding[2],\n      rotation: labelItem?.rotate || 0,\n    };\n  }\n\n  return { x: 0, y: 0, width: 0, height: 0, rotation: 0 };\n}\n\n/**\n * 计算两个矩形之间的堆叠区域面积\n */\nexport function getOverlapArea(a: BBox, b: BBox, margin = 0) {\n  const xOverlap = Math.max(\n    0,\n    Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin)\n  );\n  const yOverlap = Math.max(\n    0,\n    Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin)\n  );\n\n  return xOverlap * yOverlap;\n}\n\n/** 检测是否和已布局的堆叠 */\nexport function checkShapeOverlap(cur: IElement, dones: IElement[]) {\n  const box = cur.getBBox();\n  return some(dones, (done) => {\n    const target = done.getBBox();\n    return getOverlapArea(box, target, 2) > 0;\n  });\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}