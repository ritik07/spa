{"ast":null,"code":"import { mod, toRadian } from '@antv/util';\n// 向量长度\nfunction vMag(v) {\n  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n}\n// u.v/|u||v|，计算夹角的余弦值\nfunction vRatio(u, v) {\n  // 当存在一个向量的长度为 0 时，夹角也为 0，即夹角的余弦值为 1\n  return vMag(u) * vMag(v) ? (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v)) : 1;\n}\n// 向量角度\nfunction vAngle(u, v) {\n  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));\n}\n/**\n * 判断两个点是否重合，点坐标的格式为 [x, y]\n * @param {Array} point1 第一个点\n * @param {Array} point2 第二个点\n */\nexport function isSamePoint(point1, point2) {\n  return point1[0] === point2[0] && point1[1] === point2[1];\n}\n// A 0:rx 1:ry 2:x-axis-rotation 3:large-arc-flag 4:sweep-flag 5: x 6: y\nexport default function getArcParams(startPoint, params) {\n  var rx = params[1];\n  var ry = params[2];\n  var xRotation = mod(toRadian(params[3]), Math.PI * 2);\n  var arcFlag = params[4];\n  var sweepFlag = params[5];\n  // 弧形起点坐标\n  var x1 = startPoint[0];\n  var y1 = startPoint[1];\n  // 弧形终点坐标\n  var x2 = params[6];\n  var y2 = params[7];\n  var xp = Math.cos(xRotation) * (x1 - x2) / 2.0 + Math.sin(xRotation) * (y1 - y2) / 2.0;\n  var yp = -1 * Math.sin(xRotation) * (x1 - x2) / 2.0 + Math.cos(xRotation) * (y1 - y2) / 2.0;\n  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);\n  if (lambda > 1) {\n    rx *= Math.sqrt(lambda);\n    ry *= Math.sqrt(lambda);\n  }\n  var diff = rx * rx * (yp * yp) + ry * ry * (xp * xp);\n  var f = diff ? Math.sqrt((rx * rx * (ry * ry) - diff) / diff) : 1;\n  if (arcFlag === sweepFlag) {\n    f *= -1;\n  }\n  if (isNaN(f)) {\n    f = 0;\n  }\n  // 旋转前的起点坐标，且当长半轴和短半轴的长度为 0 时，坐标按 (0, 0) 处理\n  var cxp = ry ? f * rx * yp / ry : 0;\n  var cyp = rx ? f * -ry * xp / rx : 0;\n  // 椭圆圆心坐标\n  var cx = (x1 + x2) / 2.0 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;\n  var cy = (y1 + y2) / 2.0 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;\n  // 起始点的单位向量\n  var u = [(xp - cxp) / rx, (yp - cyp) / ry];\n  // 终止点的单位向量\n  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];\n  // 计算起始点和圆心的连线，与 x 轴正方向的夹角\n  var theta = vAngle([1, 0], u);\n  // 计算圆弧起始点和终止点与椭圆圆心连线的夹角\n  var dTheta = vAngle(u, v);\n  if (vRatio(u, v) <= -1) {\n    dTheta = Math.PI;\n  }\n  if (vRatio(u, v) >= 1) {\n    dTheta = 0;\n  }\n  if (sweepFlag === 0 && dTheta > 0) {\n    dTheta = dTheta - 2 * Math.PI;\n  }\n  if (sweepFlag === 1 && dTheta < 0) {\n    dTheta = dTheta + 2 * Math.PI;\n  }\n  return {\n    cx: cx,\n    cy: cy,\n    // 弧形的起点和终点相同时，长轴和短轴的长度按 0 处理\n    rx: isSamePoint(startPoint, [x2, y2]) ? 0 : rx,\n    ry: isSamePoint(startPoint, [x2, y2]) ? 0 : ry,\n    startAngle: theta,\n    endAngle: theta + dTheta,\n    xRotation: xRotation,\n    arcFlag: arcFlag,\n    sweepFlag: sweepFlag\n  };\n}","map":{"version":3,"sources":["../src/get-arc-params.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { mod, toRadian } from '@antv/util';\n// 向量长度\nfunction vMag(v) {\n    return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n}\n// u.v/|u||v|，计算夹角的余弦值\nfunction vRatio(u, v) {\n    // 当存在一个向量的长度为 0 时，夹角也为 0，即夹角的余弦值为 1\n    return vMag(u) * vMag(v) ? (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v)) : 1;\n}\n// 向量角度\nfunction vAngle(u, v) {\n    return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));\n}\n/**\n * 判断两个点是否重合，点坐标的格式为 [x, y]\n * @param {Array} point1 第一个点\n * @param {Array} point2 第二个点\n */\nexport function isSamePoint(point1, point2) {\n    return point1[0] === point2[0] && point1[1] === point2[1];\n}\n// A 0:rx 1:ry 2:x-axis-rotation 3:large-arc-flag 4:sweep-flag 5: x 6: y\nexport default function getArcParams(startPoint, params) {\n    var rx = params[1];\n    var ry = params[2];\n    var xRotation = mod(toRadian(params[3]), Math.PI * 2);\n    var arcFlag = params[4];\n    var sweepFlag = params[5];\n    // 弧形起点坐标\n    var x1 = startPoint[0];\n    var y1 = startPoint[1];\n    // 弧形终点坐标\n    var x2 = params[6];\n    var y2 = params[7];\n    var xp = (Math.cos(xRotation) * (x1 - x2)) / 2.0 + (Math.sin(xRotation) * (y1 - y2)) / 2.0;\n    var yp = (-1 * Math.sin(xRotation) * (x1 - x2)) / 2.0 + (Math.cos(xRotation) * (y1 - y2)) / 2.0;\n    var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);\n    if (lambda > 1) {\n        rx *= Math.sqrt(lambda);\n        ry *= Math.sqrt(lambda);\n    }\n    var diff = rx * rx * (yp * yp) + ry * ry * (xp * xp);\n    var f = diff ? Math.sqrt((rx * rx * (ry * ry) - diff) / diff) : 1;\n    if (arcFlag === sweepFlag) {\n        f *= -1;\n    }\n    if (isNaN(f)) {\n        f = 0;\n    }\n    // 旋转前的起点坐标，且当长半轴和短半轴的长度为 0 时，坐标按 (0, 0) 处理\n    var cxp = ry ? (f * rx * yp) / ry : 0;\n    var cyp = rx ? (f * -ry * xp) / rx : 0;\n    // 椭圆圆心坐标\n    var cx = (x1 + x2) / 2.0 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;\n    var cy = (y1 + y2) / 2.0 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;\n    // 起始点的单位向量\n    var u = [(xp - cxp) / rx, (yp - cyp) / ry];\n    // 终止点的单位向量\n    var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];\n    // 计算起始点和圆心的连线，与 x 轴正方向的夹角\n    var theta = vAngle([1, 0], u);\n    // 计算圆弧起始点和终止点与椭圆圆心连线的夹角\n    var dTheta = vAngle(u, v);\n    if (vRatio(u, v) <= -1) {\n        dTheta = Math.PI;\n    }\n    if (vRatio(u, v) >= 1) {\n        dTheta = 0;\n    }\n    if (sweepFlag === 0 && dTheta > 0) {\n        dTheta = dTheta - 2 * Math.PI;\n    }\n    if (sweepFlag === 1 && dTheta < 0) {\n        dTheta = dTheta + 2 * Math.PI;\n    }\n    return {\n        cx: cx,\n        cy: cy,\n        // 弧形的起点和终点相同时，长轴和短轴的长度按 0 处理\n        rx: isSamePoint(startPoint, [x2, y2]) ? 0 : rx,\n        ry: isSamePoint(startPoint, [x2, y2]) ? 0 : ry,\n        startAngle: theta,\n        endAngle: theta + dTheta,\n        xRotation: xRotation,\n        arcFlag: arcFlag,\n        sweepFlag: sweepFlag,\n    };\n}\n//# sourceMappingURL=get-arc-params.js.map"]},"metadata":{},"sourceType":"module"}