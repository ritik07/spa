{"ast":null,"code":"import { isEqual, isNumber, isFunction } from '@antv/util';\nimport * as d3Timer from 'd3-timer';\nimport { interpolate, interpolateArray } from 'd3-interpolate'; // 目前整体动画只需要数值和数组的差值计算\nimport { getEasing } from './register';\nimport * as PathUtil from '../util/path';\nimport { isColorProp, isGradientColor } from '../util/color';\nvar IDENTITY_MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n/**\n * 使用 ratio 进行插值计算来更新属性\n * @param {IElement}  shape    元素\n * @param {Animation} animation 动画\n * @param {number}    ratio    比例\n * @return {boolean}  动画是否执行完成\n */\nfunction _update(shape, animation, ratio) {\n  var cProps = {}; // 此刻属性\n  var fromAttrs = animation.fromAttrs,\n    toAttrs = animation.toAttrs;\n  if (shape.destroyed) {\n    return;\n  }\n  var interf; //  差值函数\n  for (var k in toAttrs) {\n    if (!isEqual(fromAttrs[k], toAttrs[k])) {\n      if (k === 'path') {\n        var toPath = toAttrs[k];\n        var fromPath = fromAttrs[k];\n        if (toPath.length > fromPath.length) {\n          toPath = PathUtil.parsePathString(toAttrs[k]); // 终点状态\n          fromPath = PathUtil.parsePathString(fromAttrs[k]); // 起始状态\n          fromPath = PathUtil.fillPathByDiff(fromPath, toPath);\n          fromPath = PathUtil.formatPath(fromPath, toPath);\n          animation.fromAttrs.path = fromPath;\n          animation.toAttrs.path = toPath;\n        } else if (!animation.pathFormatted) {\n          toPath = PathUtil.parsePathString(toAttrs[k]);\n          fromPath = PathUtil.parsePathString(fromAttrs[k]);\n          fromPath = PathUtil.formatPath(fromPath, toPath);\n          animation.fromAttrs.path = fromPath;\n          animation.toAttrs.path = toPath;\n          animation.pathFormatted = true;\n        }\n        cProps[k] = [];\n        for (var i = 0; i < toPath.length; i++) {\n          var toPathPoint = toPath[i];\n          var fromPathPoint = fromPath[i];\n          var cPathPoint = [];\n          for (var j = 0; j < toPathPoint.length; j++) {\n            if (isNumber(toPathPoint[j]) && fromPathPoint && isNumber(fromPathPoint[j])) {\n              interf = interpolate(fromPathPoint[j], toPathPoint[j]);\n              cPathPoint.push(interf(ratio));\n            } else {\n              cPathPoint.push(toPathPoint[j]);\n            }\n          }\n          cProps[k].push(cPathPoint);\n        }\n      } else if (k === 'matrix') {\n        /*\n         对矩阵进行插值时，需要保证矩阵不为空，为空则使用单位矩阵\n         TODO: 二维和三维场景下单位矩阵不同，之后 WebGL 版需要做进一步处理\n         */\n        var matrixFn = interpolateArray(fromAttrs[k] || IDENTITY_MATRIX, toAttrs[k] || IDENTITY_MATRIX);\n        var currentMatrix = matrixFn(ratio);\n        cProps[k] = currentMatrix;\n      } else if (isColorProp(k) && isGradientColor(toAttrs[k])) {\n        cProps[k] = toAttrs[k];\n      } else if (!isFunction(toAttrs[k])) {\n        // 非函数类型的值才能做插值\n        interf = interpolate(fromAttrs[k], toAttrs[k]);\n        cProps[k] = interf(ratio);\n      }\n    }\n  }\n  shape.attr(cProps);\n}\n/**\n * 根据自定义帧动画函数 onFrame 来更新属性\n * @param {IElement}  shape    元素\n * @param {Animation} animation 动画\n * @param {number}    elapsed  动画执行时间(毫秒)\n * @return {boolean}  动画是否执行完成\n */\nfunction update(shape, animation, elapsed) {\n  var startTime = animation.startTime,\n    delay = animation.delay;\n  // 如果还没有开始执行或暂停，先不更新\n  if (elapsed < startTime + delay || animation._paused) {\n    return false;\n  }\n  var ratio;\n  var duration = animation.duration;\n  var easing = animation.easing;\n  var easeFn = getEasing(easing);\n  // 已执行时间\n  elapsed = elapsed - startTime - animation.delay;\n  if (animation.repeat) {\n    // 如果动画重复执行，则 elapsed > duration，计算 ratio 时需取模\n    ratio = elapsed % duration / duration;\n    ratio = easeFn(ratio);\n  } else {\n    ratio = elapsed / duration;\n    if (ratio < 1) {\n      // 动画未执行完\n      ratio = easeFn(ratio);\n    } else {\n      // 动画已执行完\n      if (animation.onFrame) {\n        shape.attr(animation.onFrame(1));\n      } else {\n        shape.attr(animation.toAttrs);\n      }\n      return true;\n    }\n  }\n  if (animation.onFrame) {\n    var attrs = animation.onFrame(ratio);\n    shape.attr(attrs);\n  } else {\n    _update(shape, animation, ratio);\n  }\n  return false;\n}\nvar Timeline = /** @class */function () {\n  /**\n   * 时间轴构造函数，依赖于画布\n   * @param {}\n   */\n  function Timeline(canvas) {\n    /**\n     * 执行动画的元素列表\n     * @type {IElement[]}\n     */\n    this.animators = [];\n    /**\n     * 当前时间\n     * @type {number}\n     */\n    this.current = 0;\n    /**\n     * 定时器\n     * @type {d3Timer.Timer}\n     */\n    this.timer = null;\n    this.canvas = canvas;\n  }\n  /**\n   * 初始化定时器\n   */\n  Timeline.prototype.initTimer = function () {\n    var _this = this;\n    var isFinished = false;\n    var shape;\n    var animations;\n    var animation;\n    this.timer = d3Timer.timer(function (elapsed) {\n      _this.current = elapsed;\n      if (_this.animators.length > 0) {\n        for (var i = _this.animators.length - 1; i >= 0; i--) {\n          shape = _this.animators[i];\n          if (shape.destroyed) {\n            // 如果已经被销毁，直接移出队列\n            _this.removeAnimator(i);\n            continue;\n          }\n          if (!shape.isAnimatePaused()) {\n            animations = shape.get('animations');\n            for (var j = animations.length - 1; j >= 0; j--) {\n              animation = animations[j];\n              isFinished = update(shape, animation, elapsed);\n              if (isFinished) {\n                animations.splice(j, 1);\n                isFinished = false;\n                if (animation.callback) {\n                  animation.callback();\n                }\n              }\n            }\n          }\n          if (animations.length === 0) {\n            _this.removeAnimator(i);\n          }\n        }\n        var autoDraw = _this.canvas.get('autoDraw');\n        // 非自动渲染模式下，手动调用 canvas.draw() 重新渲染\n        if (!autoDraw) {\n          _this.canvas.draw();\n        }\n      }\n    });\n  };\n  /**\n   * 增加动画元素\n   */\n  Timeline.prototype.addAnimator = function (shape) {\n    this.animators.push(shape);\n  };\n  /**\n   * 移除动画元素\n   */\n  Timeline.prototype.removeAnimator = function (index) {\n    this.animators.splice(index, 1);\n  };\n  /**\n   * 是否有动画在执行\n   */\n  Timeline.prototype.isAnimating = function () {\n    return !!this.animators.length;\n  };\n  /**\n   * 停止定时器\n   */\n  Timeline.prototype.stop = function () {\n    if (this.timer) {\n      this.timer.stop();\n    }\n  };\n  /**\n   * 停止时间轴上所有元素的动画，并置空动画元素列表\n   * @param {boolean} toEnd 是否到动画的最终状态，用来透传给动画元素的 stopAnimate 方法\n   */\n  Timeline.prototype.stopAllAnimations = function (toEnd) {\n    if (toEnd === void 0) {\n      toEnd = true;\n    }\n    this.animators.forEach(function (animator) {\n      animator.stopAnimate(toEnd);\n    });\n    this.animators = [];\n    this.canvas.draw();\n  };\n  /**\n   * 获取当前时间\n   */\n  Timeline.prototype.getTime = function () {\n    return this.current;\n  };\n  return Timeline;\n}();\nexport default Timeline;","map":{"version":3,"sources":["../../src/animate/timeline.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isEqual, isNumber, isFunction } from '@antv/util';\nimport * as d3Timer from 'd3-timer';\nimport { interpolate, interpolateArray } from 'd3-interpolate'; // 目前整体动画只需要数值和数组的差值计算\nimport { getEasing } from './register';\nimport * as PathUtil from '../util/path';\nimport { isColorProp, isGradientColor } from '../util/color';\nvar IDENTITY_MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n/**\n * 使用 ratio 进行插值计算来更新属性\n * @param {IElement}  shape    元素\n * @param {Animation} animation 动画\n * @param {number}    ratio    比例\n * @return {boolean}  动画是否执行完成\n */\nfunction _update(shape, animation, ratio) {\n    var cProps = {}; // 此刻属性\n    var fromAttrs = animation.fromAttrs, toAttrs = animation.toAttrs;\n    if (shape.destroyed) {\n        return;\n    }\n    var interf; //  差值函数\n    for (var k in toAttrs) {\n        if (!isEqual(fromAttrs[k], toAttrs[k])) {\n            if (k === 'path') {\n                var toPath = toAttrs[k];\n                var fromPath = fromAttrs[k];\n                if (toPath.length > fromPath.length) {\n                    toPath = PathUtil.parsePathString(toAttrs[k]); // 终点状态\n                    fromPath = PathUtil.parsePathString(fromAttrs[k]); // 起始状态\n                    fromPath = PathUtil.fillPathByDiff(fromPath, toPath);\n                    fromPath = PathUtil.formatPath(fromPath, toPath);\n                    animation.fromAttrs.path = fromPath;\n                    animation.toAttrs.path = toPath;\n                }\n                else if (!animation.pathFormatted) {\n                    toPath = PathUtil.parsePathString(toAttrs[k]);\n                    fromPath = PathUtil.parsePathString(fromAttrs[k]);\n                    fromPath = PathUtil.formatPath(fromPath, toPath);\n                    animation.fromAttrs.path = fromPath;\n                    animation.toAttrs.path = toPath;\n                    animation.pathFormatted = true;\n                }\n                cProps[k] = [];\n                for (var i = 0; i < toPath.length; i++) {\n                    var toPathPoint = toPath[i];\n                    var fromPathPoint = fromPath[i];\n                    var cPathPoint = [];\n                    for (var j = 0; j < toPathPoint.length; j++) {\n                        if (isNumber(toPathPoint[j]) && fromPathPoint && isNumber(fromPathPoint[j])) {\n                            interf = interpolate(fromPathPoint[j], toPathPoint[j]);\n                            cPathPoint.push(interf(ratio));\n                        }\n                        else {\n                            cPathPoint.push(toPathPoint[j]);\n                        }\n                    }\n                    cProps[k].push(cPathPoint);\n                }\n            }\n            else if (k === 'matrix') {\n                /*\n                 对矩阵进行插值时，需要保证矩阵不为空，为空则使用单位矩阵\n                 TODO: 二维和三维场景下单位矩阵不同，之后 WebGL 版需要做进一步处理\n                 */\n                var matrixFn = interpolateArray(fromAttrs[k] || IDENTITY_MATRIX, toAttrs[k] || IDENTITY_MATRIX);\n                var currentMatrix = matrixFn(ratio);\n                cProps[k] = currentMatrix;\n            }\n            else if (isColorProp(k) && isGradientColor(toAttrs[k])) {\n                cProps[k] = toAttrs[k];\n            }\n            else if (!isFunction(toAttrs[k])) {\n                // 非函数类型的值才能做插值\n                interf = interpolate(fromAttrs[k], toAttrs[k]);\n                cProps[k] = interf(ratio);\n            }\n        }\n    }\n    shape.attr(cProps);\n}\n/**\n * 根据自定义帧动画函数 onFrame 来更新属性\n * @param {IElement}  shape    元素\n * @param {Animation} animation 动画\n * @param {number}    elapsed  动画执行时间(毫秒)\n * @return {boolean}  动画是否执行完成\n */\nfunction update(shape, animation, elapsed) {\n    var startTime = animation.startTime, delay = animation.delay;\n    // 如果还没有开始执行或暂停，先不更新\n    if (elapsed < startTime + delay || animation._paused) {\n        return false;\n    }\n    var ratio;\n    var duration = animation.duration;\n    var easing = animation.easing;\n    var easeFn = getEasing(easing);\n    // 已执行时间\n    elapsed = elapsed - startTime - animation.delay;\n    if (animation.repeat) {\n        // 如果动画重复执行，则 elapsed > duration，计算 ratio 时需取模\n        ratio = (elapsed % duration) / duration;\n        ratio = easeFn(ratio);\n    }\n    else {\n        ratio = elapsed / duration;\n        if (ratio < 1) {\n            // 动画未执行完\n            ratio = easeFn(ratio);\n        }\n        else {\n            // 动画已执行完\n            if (animation.onFrame) {\n                shape.attr(animation.onFrame(1));\n            }\n            else {\n                shape.attr(animation.toAttrs);\n            }\n            return true;\n        }\n    }\n    if (animation.onFrame) {\n        var attrs = animation.onFrame(ratio);\n        shape.attr(attrs);\n    }\n    else {\n        _update(shape, animation, ratio);\n    }\n    return false;\n}\nvar Timeline = /** @class */ (function () {\n    /**\n     * 时间轴构造函数，依赖于画布\n     * @param {}\n     */\n    function Timeline(canvas) {\n        /**\n         * 执行动画的元素列表\n         * @type {IElement[]}\n         */\n        this.animators = [];\n        /**\n         * 当前时间\n         * @type {number}\n         */\n        this.current = 0;\n        /**\n         * 定时器\n         * @type {d3Timer.Timer}\n         */\n        this.timer = null;\n        this.canvas = canvas;\n    }\n    /**\n     * 初始化定时器\n     */\n    Timeline.prototype.initTimer = function () {\n        var _this = this;\n        var isFinished = false;\n        var shape;\n        var animations;\n        var animation;\n        this.timer = d3Timer.timer(function (elapsed) {\n            _this.current = elapsed;\n            if (_this.animators.length > 0) {\n                for (var i = _this.animators.length - 1; i >= 0; i--) {\n                    shape = _this.animators[i];\n                    if (shape.destroyed) {\n                        // 如果已经被销毁，直接移出队列\n                        _this.removeAnimator(i);\n                        continue;\n                    }\n                    if (!shape.isAnimatePaused()) {\n                        animations = shape.get('animations');\n                        for (var j = animations.length - 1; j >= 0; j--) {\n                            animation = animations[j];\n                            isFinished = update(shape, animation, elapsed);\n                            if (isFinished) {\n                                animations.splice(j, 1);\n                                isFinished = false;\n                                if (animation.callback) {\n                                    animation.callback();\n                                }\n                            }\n                        }\n                    }\n                    if (animations.length === 0) {\n                        _this.removeAnimator(i);\n                    }\n                }\n                var autoDraw = _this.canvas.get('autoDraw');\n                // 非自动渲染模式下，手动调用 canvas.draw() 重新渲染\n                if (!autoDraw) {\n                    _this.canvas.draw();\n                }\n            }\n        });\n    };\n    /**\n     * 增加动画元素\n     */\n    Timeline.prototype.addAnimator = function (shape) {\n        this.animators.push(shape);\n    };\n    /**\n     * 移除动画元素\n     */\n    Timeline.prototype.removeAnimator = function (index) {\n        this.animators.splice(index, 1);\n    };\n    /**\n     * 是否有动画在执行\n     */\n    Timeline.prototype.isAnimating = function () {\n        return !!this.animators.length;\n    };\n    /**\n     * 停止定时器\n     */\n    Timeline.prototype.stop = function () {\n        if (this.timer) {\n            this.timer.stop();\n        }\n    };\n    /**\n     * 停止时间轴上所有元素的动画，并置空动画元素列表\n     * @param {boolean} toEnd 是否到动画的最终状态，用来透传给动画元素的 stopAnimate 方法\n     */\n    Timeline.prototype.stopAllAnimations = function (toEnd) {\n        if (toEnd === void 0) { toEnd = true; }\n        this.animators.forEach(function (animator) {\n            animator.stopAnimate(toEnd);\n        });\n        this.animators = [];\n        this.canvas.draw();\n    };\n    /**\n     * 获取当前时间\n     */\n    Timeline.prototype.getTime = function () {\n        return this.current;\n    };\n    return Timeline;\n}());\nexport default Timeline;\n//# sourceMappingURL=timeline.js.map"]},"metadata":{},"sourceType":"module"}