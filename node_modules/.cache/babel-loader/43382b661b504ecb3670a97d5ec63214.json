{"ast":null,"code":"import { getMedian, getMean } from './stat';\n/**\n * parse the value position\n * @param val\n * @param scale\n */\nexport function getNormalizedValue(val, scale) {\n  if (!scale) {\n    return null;\n  }\n  var scaled;\n  switch (val) {\n    case 'start':\n      return 0;\n    case 'center':\n      return 0.5;\n    case 'end':\n      return 1;\n    case 'median':\n      {\n        scaled = scale.isCategory ? getMedian(scale.values.map(function (_, idx) {\n          return idx;\n        })) : getMedian(scale.values);\n        break;\n      }\n    case 'mean':\n      {\n        scaled = scale.isCategory ? (scale.values.length - 1) / 2 : getMean(scale.values);\n        break;\n      }\n    case 'min':\n      scaled = scale.isCategory ? 0 : scale[val];\n      break;\n    case 'max':\n      scaled = scale.isCategory ? scale.values.length - 1 : scale[val];\n      break;\n    default:\n      scaled = val;\n      break;\n  }\n  return scale.scale(scaled);\n}","map":{"version":3,"sources":["../../src/util/annotation.ts"],"names":[],"mappings":"AAAA,SAAS,SAAS,EAAE,OAAO,QAAQ,QAAQ;AAG3C;;;;AAIG;AACH,OAAM,SAAU,kBAAkB,CAAC,GAAoB,EAAE,KAAY,EAAA;EACnE,IAAI,CAAC,KAAK,EAAE;IACV,OAAO,IAAI;EACZ;EACD,IAAI,MAAc;EAElB,QAAQ,GAAG;IACT,KAAK,OAAO;MACV,OAAO,CAAC;IACV,KAAK,QAAQ;MACX,OAAO,GAAG;IACZ,KAAK,KAAK;MACR,OAAO,CAAC;IACV,KAAK,QAAQ;MAAE;QACb,MAAM,GAAG,KAAK,CAAC,UAAU,GAAG,SAAS,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,UAAC,CAAC,EAAE,GAAW,EAAA;UAAK,OAAA,GAAG;QAAH,CAAG,CAAC,CAAC,GAAG,SAAS,CAAC,KAAK,CAAC,MAAM,CAAC;QAC1G;MACD;IACD,KAAK,MAAM;MAAE;QACX,MAAM,GAAG,KAAK,CAAC,UAAU,GAAG,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,IAAI,CAAC,GAAG,OAAO,CAAC,KAAK,CAAC,MAAM,CAAC;QACjF;MACD;IACD,KAAK,KAAK;MACR,MAAM,GAAG,KAAK,CAAC,UAAU,GAAG,CAAC,GAAG,KAAK,CAAC,GAAG,CAAC;MAC1C;IACF,KAAK,KAAK;MACR,MAAM,GAAG,KAAK,CAAC,UAAU,GAAG,KAAK,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,GAAG,KAAK,CAAC,GAAG,CAAC;MAChE;IACF;MACE,MAAM,GAAG,GAAa;MACtB;EAAM;EAGV,OAAO,KAAK,CAAC,KAAK,CAAC,MAAM,CAAC;AAC5B","sourcesContent":["import { getMedian, getMean } from './stat';\nimport { Scale } from '../dependents';\n\n/**\n * parse the value position\n * @param val\n * @param scale\n */\nexport function getNormalizedValue(val: number | string, scale: Scale) {\n  if (!scale) {\n    return null;\n  }\n  let scaled: number;\n\n  switch (val) {\n    case 'start':\n      return 0;\n    case 'center':\n      return 0.5;\n    case 'end':\n      return 1;\n    case 'median': {\n      scaled = scale.isCategory ? getMedian(scale.values.map((_, idx: number) => idx)) : getMedian(scale.values);\n      break;\n    }\n    case 'mean': {\n      scaled = scale.isCategory ? (scale.values.length - 1) / 2 : getMean(scale.values);\n      break;\n    }\n    case 'min':\n      scaled = scale.isCategory ? 0 : scale[val];\n      break;\n    case 'max':\n      scaled = scale.isCategory ? scale.values.length - 1 : scale[val];\n      break;\n    default:\n      scaled = val as number;\n      break;\n  }\n\n  return scale.scale(scaled);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}