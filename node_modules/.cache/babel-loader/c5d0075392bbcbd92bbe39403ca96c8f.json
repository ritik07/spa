{"ast":null,"code":"import { __assign, __awaiter, __generator, __read, __spreadArray } from \"tslib\";\nimport { deepMix, each, get, isArray, isFunction, isNil, isNumber, isUndefined } from '@antv/util';\nimport { FIELD_ORIGIN } from '../../constant';\nimport { getDefaultAnimateCfg } from '../../animate';\nimport { getPolygonCentroid } from '../../util/graphics';\nimport Labels from '../../component/labels';\nfunction avg(arr) {\n  var sum = 0;\n  each(arr, function (value) {\n    sum += value;\n  });\n  return sum / arr.length;\n}\n/**\n * Geometry Label 基类，用于生成 Geometry 下所有 label 的配置项信息\n */\nvar GeometryLabel = /** @class */function () {\n  function GeometryLabel(geometry) {\n    this.geometry = geometry;\n  }\n  GeometryLabel.prototype.getLabelItems = function (mapppingArray) {\n    var _this = this;\n    var items = [];\n    var labelCfgs = this.getLabelCfgs(mapppingArray);\n    // 获取 label 相关的 x，y 的值，获取具体的 x, y，防止存在数组\n    each(mapppingArray, function (mappingData, index) {\n      var labelCfg = labelCfgs[index];\n      if (!labelCfg || isNil(mappingData.x) || isNil(mappingData.y)) {\n        items.push(null);\n        return;\n      }\n      var labelContent = !isArray(labelCfg.content) ? [labelCfg.content] : labelCfg.content;\n      labelCfg.content = labelContent;\n      var total = labelContent.length;\n      each(labelContent, function (content, subIndex) {\n        if (isNil(content) || content === '') {\n          items.push(null);\n          return;\n        }\n        var item = __assign(__assign({}, labelCfg), _this.getLabelPoint(labelCfg, mappingData, subIndex));\n        if (!item.textAlign) {\n          item.textAlign = _this.getLabelAlign(item, subIndex, total);\n        }\n        if (item.offset <= 0) {\n          item.labelLine = null;\n        }\n        items.push(item);\n      });\n    });\n    return items;\n  };\n  GeometryLabel.prototype.render = function (mappingArray, isUpdate) {\n    if (isUpdate === void 0) {\n      isUpdate = false;\n    }\n    return __awaiter(this, void 0, void 0, function () {\n      var labelItems, labelsRenderer, shapes;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            labelItems = this.getLabelItems(mappingArray);\n            labelsRenderer = this.getLabelsRenderer();\n            shapes = this.getGeometryShapes();\n            // 渲染文本\n            return [4 /*yield*/, labelsRenderer.render(labelItems, shapes, isUpdate)];\n          case 1:\n            // 渲染文本\n            _a.sent();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  GeometryLabel.prototype.clear = function () {\n    var labelsRenderer = this.labelsRenderer;\n    if (labelsRenderer) {\n      labelsRenderer.clear();\n    }\n  };\n  GeometryLabel.prototype.destroy = function () {\n    var labelsRenderer = this.labelsRenderer;\n    if (labelsRenderer) {\n      labelsRenderer.destroy();\n    }\n    this.labelsRenderer = null;\n  };\n  // geometry 更新之后，对应的 Coordinate 也会更新，为了获取到最新鲜的 Coordinate，故使用方法获取\n  GeometryLabel.prototype.getCoordinate = function () {\n    return this.geometry.coordinate;\n  };\n  /**\n   * 获取 label 的默认配置\n   */\n  GeometryLabel.prototype.getDefaultLabelCfg = function (offset, position) {\n    var geometry = this.geometry;\n    var type = geometry.type,\n      theme = geometry.theme;\n    if (type === 'polygon' || type === 'interval' && position === 'middle' || offset < 0 && !['line', 'point', 'path'].includes(type)) {\n      // polygon 或者 (interval 且 middle) 或者 offset 小于 0 时，文本展示在图形内部，将其颜色设置为 白色\n      return get(theme, 'innerLabels', {});\n    }\n    return get(theme, 'labels', {});\n  };\n  /**\n   * 获取当前 label 的最终配置\n   * @param labelCfg\n   */\n  GeometryLabel.prototype.getThemedLabelCfg = function (labelCfg) {\n    var geometry = this.geometry;\n    var defaultLabelCfg = this.getDefaultLabelCfg();\n    var type = geometry.type,\n      theme = geometry.theme;\n    var themedLabelCfg;\n    if (type === 'polygon' || labelCfg.offset < 0 && !['line', 'point', 'path'].includes(type)) {\n      // polygon 或者 offset 小于 0 时，文本展示在图形内部，将其颜色设置为 白色\n      themedLabelCfg = deepMix({}, defaultLabelCfg, theme.innerLabels, labelCfg);\n    } else {\n      themedLabelCfg = deepMix({}, defaultLabelCfg, theme.labels, labelCfg);\n    }\n    return themedLabelCfg;\n  };\n  /**\n   * 设置 label 位置\n   * @param labelPointCfg\n   * @param mappingData\n   * @param index\n   * @param position\n   */\n  GeometryLabel.prototype.setLabelPosition = function (labelPointCfg, mappingData, index, position) {};\n  /**\n   * @desc 获取 label offset\n   */\n  GeometryLabel.prototype.getLabelOffset = function (offset) {\n    var coordinate = this.getCoordinate();\n    var vector = this.getOffsetVector(offset);\n    return coordinate.isTransposed ? vector[0] : vector[1];\n  };\n  /**\n   * 获取每个 label 的偏移量 (矢量)\n   * @param labelCfg\n   * @param index\n   * @param total\n   * @return {Point} offsetPoint\n   */\n  GeometryLabel.prototype.getLabelOffsetPoint = function (labelCfg, index, total) {\n    var offset = labelCfg.offset;\n    var coordinate = this.getCoordinate();\n    var transposed = coordinate.isTransposed;\n    var dim = transposed ? 'x' : 'y';\n    var factor = transposed ? 1 : -1; // y 方向上越大，像素的坐标越小，所以transposed时将系数变成\n    var offsetPoint = {\n      x: 0,\n      y: 0\n    };\n    if (index > 0 || total === 1) {\n      // 判断是否小于0\n      offsetPoint[dim] = offset * factor;\n    } else {\n      offsetPoint[dim] = offset * factor * -1;\n    }\n    return offsetPoint;\n  };\n  /**\n   * 获取每个 label 的位置\n   * @param labelCfg\n   * @param mappingData\n   * @param index\n   * @returns label point\n   */\n  GeometryLabel.prototype.getLabelPoint = function (labelCfg, mappingData, index) {\n    var coordinate = this.getCoordinate();\n    var total = labelCfg.content.length;\n    function getDimValue(value, idx, isAvg) {\n      if (isAvg === void 0) {\n        isAvg = false;\n      }\n      var v = value;\n      if (isArray(v)) {\n        if (labelCfg.content.length === 1) {\n          if (isAvg) {\n            v = avg(v);\n          } else {\n            // 如果仅一个 label，多个 y, 取最后一个 y\n            if (v.length <= 2) {\n              v = v[value.length - 1];\n            } else {\n              v = avg(v);\n            }\n          }\n        } else {\n          v = v[idx];\n        }\n      }\n      return v;\n    }\n    var label = {\n      content: labelCfg.content[index],\n      x: 0,\n      y: 0,\n      start: {\n        x: 0,\n        y: 0\n      },\n      color: '#fff'\n    };\n    var shape = isArray(mappingData.shape) ? mappingData.shape[0] : mappingData.shape;\n    var isFunnel = shape === 'funnel' || shape === 'pyramid';\n    // 多边形场景，多用于地图\n    if (this.geometry.type === 'polygon') {\n      var centroid = getPolygonCentroid(mappingData.x, mappingData.y);\n      label.x = centroid[0];\n      label.y = centroid[1];\n    } else if (this.geometry.type === 'interval' && !isFunnel) {\n      // 对直方图的label X 方向的位置居中\n      label.x = getDimValue(mappingData.x, index, true);\n      label.y = getDimValue(mappingData.y, index);\n    } else {\n      label.x = getDimValue(mappingData.x, index);\n      label.y = getDimValue(mappingData.y, index);\n    }\n    // 处理漏斗图文本位置\n    if (isFunnel) {\n      var nextPoints = get(mappingData, 'nextPoints');\n      var points = get(mappingData, 'points');\n      if (nextPoints) {\n        // 非漏斗图底部\n        var point1 = coordinate.convert(points[1]);\n        var point2 = coordinate.convert(nextPoints[1]);\n        label.x = (point1.x + point2.x) / 2;\n        label.y = (point1.y + point2.y) / 2;\n      } else if (shape === 'pyramid') {\n        var point1 = coordinate.convert(points[1]);\n        var point2 = coordinate.convert(points[2]);\n        label.x = (point1.x + point2.x) / 2;\n        label.y = (point1.y + point2.y) / 2;\n      }\n    }\n    if (labelCfg.position) {\n      // 如果 label 支持 position 属性\n      this.setLabelPosition(label, mappingData, index, labelCfg.position);\n    }\n    var offsetPoint = this.getLabelOffsetPoint(labelCfg, index, total);\n    label.start = {\n      x: label.x,\n      y: label.y\n    };\n    label.x += offsetPoint.x;\n    label.y += offsetPoint.y;\n    label.color = mappingData.color;\n    return label;\n  };\n  /**\n   * 获取文本的对齐方式\n   * @param item\n   * @param index\n   * @param total\n   * @returns\n   */\n  GeometryLabel.prototype.getLabelAlign = function (item, index, total) {\n    var align = 'center';\n    var coordinate = this.getCoordinate();\n    if (coordinate.isTransposed) {\n      var offset = item.offset;\n      if (offset < 0) {\n        align = 'right';\n      } else if (offset === 0) {\n        align = 'center';\n      } else {\n        align = 'left';\n      }\n      if (total > 1 && index === 0) {\n        if (align === 'right') {\n          align = 'left';\n        } else if (align === 'left') {\n          align = 'right';\n        }\n      }\n    }\n    return align;\n  };\n  /**\n   * 获取每一个 label 的唯一 id\n   * @param mappingData label 对应的图形的绘制数据\n   */\n  GeometryLabel.prototype.getLabelId = function (mappingData) {\n    var geometry = this.geometry;\n    var type = geometry.type;\n    var xScale = geometry.getXScale();\n    var yScale = geometry.getYScale();\n    var origin = mappingData[FIELD_ORIGIN]; // 原始数据\n    var labelId = geometry.getElementId(mappingData);\n    if (type === 'line' || type === 'area') {\n      // 折线图以及区域图，一条线会对应一组数据，即多个 labels，为了区分这些 labels，需要在 line id 的前提下加上 x 字段值\n      labelId += \" \".concat(origin[xScale.field]);\n    } else if (type === 'path') {\n      // path 路径图，无序，有可能存在相同 x 不同 y 的情况，需要通过 x y 来确定唯一 id\n      labelId += \" \".concat(origin[xScale.field], \"-\").concat(origin[yScale.field]);\n    }\n    return labelId;\n  };\n  // 获取 labels 组件\n  GeometryLabel.prototype.getLabelsRenderer = function () {\n    var _a = this.geometry,\n      labelsContainer = _a.labelsContainer,\n      labelOption = _a.labelOption,\n      canvasRegion = _a.canvasRegion,\n      animateOption = _a.animateOption;\n    var coordinate = this.geometry.coordinate;\n    var labelsRenderer = this.labelsRenderer;\n    if (!labelsRenderer) {\n      labelsRenderer = new Labels({\n        container: labelsContainer,\n        layout: get(labelOption, ['cfg', 'layout'], {\n          type: this.defaultLayout\n        })\n      });\n      this.labelsRenderer = labelsRenderer;\n    }\n    labelsRenderer.region = canvasRegion;\n    // 设置动画配置，如果 geometry 的动画关闭了，那么 label 的动画也会关闭\n    labelsRenderer.animate = animateOption ? getDefaultAnimateCfg('label', coordinate) : false;\n    return labelsRenderer;\n  };\n  GeometryLabel.prototype.getLabelCfgs = function (mapppingArray) {\n    var _this = this;\n    var geometry = this.geometry;\n    var labelOption = geometry.labelOption,\n      scales = geometry.scales,\n      coordinate = geometry.coordinate;\n    var _a = labelOption,\n      fields = _a.fields,\n      callback = _a.callback,\n      cfg = _a.cfg;\n    var labelScales = fields.map(function (field) {\n      return scales[field];\n    });\n    var labelCfgs = [];\n    each(mapppingArray, function (mappingData, index) {\n      var origin = mappingData[FIELD_ORIGIN]; // 原始数据\n      var originText = _this.getLabelText(origin, labelScales);\n      var callbackCfg;\n      if (callback) {\n        // 当同时配置了 callback 和 cfg 时，以 callback 为准\n        var originValues = fields.map(function (field) {\n          return origin[field];\n        });\n        callbackCfg = callback.apply(void 0, __spreadArray([], __read(originValues), false));\n        if (isNil(callbackCfg)) {\n          labelCfgs.push(null);\n          return;\n        }\n      }\n      var labelCfg = __assign(__assign({\n        id: _this.getLabelId(mappingData),\n        elementId: _this.geometry.getElementId(mappingData),\n        data: origin,\n        // 存储原始数据\n        mappingData: mappingData,\n        // 存储映射后的数据,\n        coordinate: coordinate\n      }, cfg), callbackCfg);\n      if (isFunction(labelCfg.position)) {\n        labelCfg.position = labelCfg.position(origin, mappingData, index);\n      }\n      var offset = _this.getLabelOffset(labelCfg.offset || 0);\n      // defaultCfg 需要判断 innerLabels & labels\n      var defaultLabelCfg = _this.getDefaultLabelCfg(offset, labelCfg.position);\n      // labelCfg priority: defaultCfg < cfg < callbackCfg\n      labelCfg = deepMix({}, defaultLabelCfg, labelCfg);\n      // 获取最终的 offset\n      labelCfg.offset = _this.getLabelOffset(labelCfg.offset || 0);\n      var content = labelCfg.content;\n      if (isFunction(content)) {\n        labelCfg.content = content(origin, mappingData, index);\n      } else if (isUndefined(content)) {\n        // 用户未配置 content，则默认为映射的第一个字段的值\n        labelCfg.content = originText[0];\n      }\n      labelCfgs.push(labelCfg);\n    });\n    return labelCfgs;\n  };\n  GeometryLabel.prototype.getLabelText = function (origin, scales) {\n    var labelTexts = [];\n    each(scales, function (scale) {\n      var value = origin[scale.field];\n      if (isArray(value)) {\n        value = value.map(function (subVal) {\n          return scale.getText(subVal);\n        });\n      } else {\n        value = scale.getText(value);\n      }\n      if (isNil(value) || value === '') {\n        labelTexts.push(null);\n      } else {\n        labelTexts.push(value);\n      }\n    });\n    return labelTexts;\n  };\n  GeometryLabel.prototype.getOffsetVector = function (offset) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n    var coordinate = this.getCoordinate();\n    var actualOffset = 0;\n    if (isNumber(offset)) {\n      actualOffset = offset;\n    }\n    // 如果 x,y 翻转，则偏移 x，否则偏移 y\n    return coordinate.isTransposed ? coordinate.applyMatrix(actualOffset, 0) : coordinate.applyMatrix(0, actualOffset);\n  };\n  GeometryLabel.prototype.getGeometryShapes = function () {\n    var geometry = this.geometry;\n    var shapes = {};\n    each(geometry.elementsMap, function (element, id) {\n      shapes[id] = element.shape;\n    });\n    // 因为有可能 shape 还在进行动画，导致 shape.getBBox() 获取到的值不是最终态，所以需要从 offscreenGroup 获取\n    each(geometry.getOffscreenGroup().getChildren(), function (child) {\n      var id = geometry.getElementId(child.get('origin').mappingData);\n      shapes[id] = child;\n    });\n    return shapes;\n  };\n  return GeometryLabel;\n}();\nexport default GeometryLabel;","map":{"version":3,"sources":["../../../src/geometry/label/base.ts"],"names":[],"mappings":"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","sourcesContent":["import { deepMix, each, get, isArray, isFunction, isNil, isNumber, isString, isUndefined } from '@antv/util';\n\nimport { FIELD_ORIGIN } from '../../constant';\nimport { Scale } from '../../dependents';\nimport { Datum, LabelOption, MappingDatum, Point } from '../../interface';\nimport { LabelCfg, LabelItem, LabelPointCfg, TextAlign } from './interface';\n\nimport { getDefaultAnimateCfg } from '../../animate';\nimport { getPolygonCentroid } from '../../util/graphics';\n\nimport Labels from '../../component/labels';\nimport Geometry from '../base';\nimport Element from '../element';\n\nexport type GeometryLabelConstructor = new (cfg: any) => GeometryLabel;\n\nfunction avg(arr: number[]) {\n  let sum = 0;\n  each(arr, (value: number) => {\n    sum += value;\n  });\n  return sum / arr.length;\n}\n\n/**\n * Geometry Label 基类，用于生成 Geometry 下所有 label 的配置项信息\n */\nexport default class GeometryLabel {\n  /** geometry 实例 */\n  public readonly geometry: Geometry;\n  public labelsRenderer: Labels;\n  /** 默认的布局 */\n  public defaultLayout: string;\n\n  constructor(geometry: Geometry) {\n    this.geometry = geometry;\n  }\n\n  public getLabelItems(mapppingArray: MappingDatum[]): LabelItem[] {\n    const items = [];\n    const labelCfgs = this.getLabelCfgs(mapppingArray);\n    // 获取 label 相关的 x，y 的值，获取具体的 x, y，防止存在数组\n    each(mapppingArray, (mappingData: MappingDatum, index: number) => {\n      const labelCfg = labelCfgs[index];\n      if (!labelCfg || isNil(mappingData.x) || isNil(mappingData.y)) {\n        items.push(null);\n        return;\n      }\n\n      const labelContent = !isArray(labelCfg.content) ? [labelCfg.content] : labelCfg.content;\n      labelCfg.content = labelContent;\n      const total = labelContent.length;\n      each(labelContent, (content, subIndex) => {\n        if (isNil(content) || content === '') {\n          items.push(null);\n          return;\n        }\n\n        const item = {\n          ...labelCfg,\n          ...this.getLabelPoint(labelCfg, mappingData, subIndex),\n        };\n        if (!item.textAlign) {\n          item.textAlign = this.getLabelAlign(item, subIndex, total);\n        }\n\n        if (item.offset <= 0) {\n          item.labelLine = null;\n        }\n\n        items.push(item);\n      });\n    });\n    return items;\n  }\n\n  public async render(mappingArray: MappingDatum[], isUpdate: boolean = false) {\n    const labelItems = this.getLabelItems(mappingArray);\n    const labelsRenderer = this.getLabelsRenderer();\n    const shapes = this.getGeometryShapes();\n    // 渲染文本\n    await labelsRenderer.render(labelItems, shapes, isUpdate);\n  }\n\n  public clear() {\n    const labelsRenderer = this.labelsRenderer;\n    if (labelsRenderer) {\n      labelsRenderer.clear();\n    }\n  }\n\n  public destroy() {\n    const labelsRenderer = this.labelsRenderer;\n    if (labelsRenderer) {\n      labelsRenderer.destroy();\n    }\n    this.labelsRenderer = null;\n  }\n\n  // geometry 更新之后，对应的 Coordinate 也会更新，为了获取到最新鲜的 Coordinate，故使用方法获取\n  public getCoordinate() {\n    return this.geometry.coordinate;\n  }\n\n  /**\n   * 获取 label 的默认配置\n   */\n  protected getDefaultLabelCfg(offset?: number, position?: string) {\n    const geometry = this.geometry;\n    const { type, theme } = geometry;\n\n    if (\n      type === 'polygon' ||\n      (type === 'interval' && position === 'middle') ||\n      (offset < 0 && !['line', 'point', 'path'].includes(type))\n    ) {\n      // polygon 或者 (interval 且 middle) 或者 offset 小于 0 时，文本展示在图形内部，将其颜色设置为 白色\n      return get(theme, 'innerLabels', {});\n    }\n\n    return get(theme, 'labels', {});\n  }\n\n  /**\n   * 获取当前 label 的最终配置\n   * @param labelCfg\n   */\n  protected getThemedLabelCfg(labelCfg: LabelCfg) {\n    const geometry = this.geometry;\n    const defaultLabelCfg = this.getDefaultLabelCfg();\n    const { type, theme } = geometry;\n    let themedLabelCfg;\n\n    if (type === 'polygon' || (labelCfg.offset < 0 && !['line', 'point', 'path'].includes(type))) {\n      // polygon 或者 offset 小于 0 时，文本展示在图形内部，将其颜色设置为 白色\n      themedLabelCfg = deepMix({}, defaultLabelCfg, theme.innerLabels, labelCfg);\n    } else {\n      themedLabelCfg = deepMix({}, defaultLabelCfg, theme.labels, labelCfg);\n    }\n\n    return themedLabelCfg;\n  }\n\n  /**\n   * 设置 label 位置\n   * @param labelPointCfg\n   * @param mappingData\n   * @param index\n   * @param position\n   */\n  protected setLabelPosition(\n    labelPointCfg: LabelPointCfg,\n    mappingData: MappingDatum,\n    index: number,\n    position: string\n  ) {}\n\n  /**\n   * @desc 获取 label offset\n   */\n  protected getLabelOffset(offset: number | string): number {\n    const coordinate = this.getCoordinate();\n    const vector = this.getOffsetVector(offset);\n    return coordinate.isTransposed ? vector[0] : vector[1];\n  }\n\n  /**\n   * 获取每个 label 的偏移量 (矢量)\n   * @param labelCfg\n   * @param index\n   * @param total\n   * @return {Point} offsetPoint\n   */\n  protected getLabelOffsetPoint(labelCfg: LabelCfg, index: number, total: number): Point {\n    const offset = labelCfg.offset;\n    const coordinate = this.getCoordinate();\n    const transposed = coordinate.isTransposed;\n    const dim = transposed ? 'x' : 'y';\n    const factor = transposed ? 1 : -1; // y 方向上越大，像素的坐标越小，所以transposed时将系数变成\n    const offsetPoint = {\n      x: 0,\n      y: 0,\n    };\n    if (index > 0 || total === 1) {\n      // 判断是否小于0\n      offsetPoint[dim] = offset * factor;\n    } else {\n      offsetPoint[dim] = offset * factor * -1;\n    }\n    return offsetPoint;\n  }\n\n  /**\n   * 获取每个 label 的位置\n   * @param labelCfg\n   * @param mappingData\n   * @param index\n   * @returns label point\n   */\n  protected getLabelPoint(labelCfg: LabelCfg, mappingData: MappingDatum, index: number): LabelPointCfg {\n    const coordinate = this.getCoordinate();\n    const total = labelCfg.content.length;\n\n    function getDimValue(value: number | number[], idx: number, isAvg = false) {\n      let v = value;\n      if (isArray(v)) {\n        if (labelCfg.content.length === 1) {\n          if (isAvg) {\n            v = avg(v);\n          } else {\n            // 如果仅一个 label，多个 y, 取最后一个 y\n            if (v.length <= 2) {\n              v = v[(value as number[]).length - 1];\n            } else {\n              v = avg(v);\n            }\n          }\n        } else {\n          v = v[idx];\n        }\n      }\n      return v;\n    }\n\n    const label = {\n      content: labelCfg.content[index],\n      x: 0,\n      y: 0,\n      start: { x: 0, y: 0 },\n      color: '#fff',\n    };\n    const shape = isArray(mappingData.shape) ? mappingData.shape[0] : mappingData.shape;\n    const isFunnel = shape === 'funnel' || shape === 'pyramid';\n\n    // 多边形场景，多用于地图\n    if (this.geometry.type === 'polygon') {\n      const centroid = getPolygonCentroid(mappingData.x, mappingData.y);\n      label.x = centroid[0];\n      label.y = centroid[1];\n    } else if (this.geometry.type === 'interval' && !isFunnel) {\n      // 对直方图的label X 方向的位置居中\n      label.x = getDimValue(mappingData.x, index, true);\n      label.y = getDimValue(mappingData.y, index);\n    } else {\n      label.x = getDimValue(mappingData.x, index);\n      label.y = getDimValue(mappingData.y, index);\n    }\n\n    // 处理漏斗图文本位置\n    if (isFunnel) {\n      const nextPoints = get(mappingData, 'nextPoints');\n      const points = get(mappingData, 'points');\n      if (nextPoints) {\n        // 非漏斗图底部\n        const point1 = coordinate.convert(points[1] as Point);\n        const point2 = coordinate.convert(nextPoints[1] as Point);\n        label.x = (point1.x + point2.x) / 2;\n        label.y = (point1.y + point2.y) / 2;\n      } else if (shape === 'pyramid') {\n        const point1 = coordinate.convert(points[1] as Point);\n        const point2 = coordinate.convert(points[2] as Point);\n        label.x = (point1.x + point2.x) / 2;\n        label.y = (point1.y + point2.y) / 2;\n      }\n    }\n\n    if (labelCfg.position) {\n      // 如果 label 支持 position 属性\n      this.setLabelPosition(label, mappingData, index, labelCfg.position);\n    }\n    const offsetPoint = this.getLabelOffsetPoint(labelCfg, index, total);\n    label.start = { x: label.x, y: label.y };\n    label.x += offsetPoint.x;\n    label.y += offsetPoint.y;\n    label.color = mappingData.color;\n    return label;\n  }\n\n  /**\n   * 获取文本的对齐方式\n   * @param item\n   * @param index\n   * @param total\n   * @returns\n   */\n  protected getLabelAlign(item: LabelItem, index: number, total: number): TextAlign {\n    let align: TextAlign = 'center';\n    const coordinate = this.getCoordinate();\n    if (coordinate.isTransposed) {\n      const offset = item.offset;\n      if (offset < 0) {\n        align = 'right';\n      } else if (offset === 0) {\n        align = 'center';\n      } else {\n        align = 'left';\n      }\n      if (total > 1 && index === 0) {\n        if (align === 'right') {\n          align = 'left';\n        } else if (align === 'left') {\n          align = 'right';\n        }\n      }\n    }\n    return align;\n  }\n\n  /**\n   * 获取每一个 label 的唯一 id\n   * @param mappingData label 对应的图形的绘制数据\n   */\n  protected getLabelId(mappingData: MappingDatum) {\n    const geometry = this.geometry;\n    const type = geometry.type;\n    const xScale = geometry.getXScale();\n    const yScale = geometry.getYScale();\n    const origin = mappingData[FIELD_ORIGIN]; // 原始数据\n\n    let labelId = geometry.getElementId(mappingData);\n    if (type === 'line' || type === 'area') {\n      // 折线图以及区域图，一条线会对应一组数据，即多个 labels，为了区分这些 labels，需要在 line id 的前提下加上 x 字段值\n      labelId += ` ${origin[xScale.field]}`;\n    } else if (type === 'path') {\n      // path 路径图，无序，有可能存在相同 x 不同 y 的情况，需要通过 x y 来确定唯一 id\n      labelId += ` ${origin[xScale.field]}-${origin[yScale.field]}`;\n    }\n\n    return labelId;\n  }\n\n  // 获取 labels 组件\n  private getLabelsRenderer() {\n    const { labelsContainer, labelOption, canvasRegion, animateOption } = this.geometry;\n    const coordinate = this.geometry.coordinate;\n\n    let labelsRenderer = this.labelsRenderer;\n    if (!labelsRenderer) {\n      labelsRenderer = new Labels({\n        container: labelsContainer,\n        layout: get(labelOption, ['cfg', 'layout'], {\n          type: this.defaultLayout,\n        }),\n      });\n      this.labelsRenderer = labelsRenderer;\n    }\n    labelsRenderer.region = canvasRegion;\n    // 设置动画配置，如果 geometry 的动画关闭了，那么 label 的动画也会关闭\n    labelsRenderer.animate = animateOption ? getDefaultAnimateCfg('label', coordinate) : false;\n\n    return labelsRenderer;\n  }\n\n  private getLabelCfgs(mapppingArray: MappingDatum[]): LabelCfg[] {\n    const geometry = this.geometry;\n    const { labelOption, scales, coordinate } = geometry;\n    const { fields, callback, cfg } = labelOption as LabelOption;\n    const labelScales = fields.map((field: string) => {\n      return scales[field];\n    });\n\n    const labelCfgs: LabelCfg[] = [];\n    each(mapppingArray, (mappingData: MappingDatum, index: number) => {\n      const origin = mappingData[FIELD_ORIGIN]; // 原始数据\n      const originText = this.getLabelText(origin, labelScales);\n      let callbackCfg;\n      if (callback) {\n        // 当同时配置了 callback 和 cfg 时，以 callback 为准\n        const originValues = fields.map((field: string) => origin[field]);\n        callbackCfg = callback(...originValues);\n        if (isNil(callbackCfg)) {\n          labelCfgs.push(null);\n          return;\n        }\n      }\n\n      let labelCfg = {\n        id: this.getLabelId(mappingData), // 进行 ID 标记\n        elementId: this.geometry.getElementId(mappingData), // label 对应 Element 的 ID\n        data: origin, // 存储原始数据\n        mappingData, // 存储映射后的数据,\n        coordinate, // 坐标系\n        ...cfg,\n        ...callbackCfg,\n      };\n\n      if (isFunction(labelCfg.position)) {\n        labelCfg.position = labelCfg.position(origin, mappingData, index);\n      }\n\n      const offset = this.getLabelOffset(labelCfg.offset || 0);\n      // defaultCfg 需要判断 innerLabels & labels\n      const defaultLabelCfg = this.getDefaultLabelCfg(offset, labelCfg.position);\n      // labelCfg priority: defaultCfg < cfg < callbackCfg\n      labelCfg = deepMix({}, defaultLabelCfg, labelCfg);\n      // 获取最终的 offset\n      labelCfg.offset = this.getLabelOffset(labelCfg.offset || 0);\n\n      const content = labelCfg.content;\n      if (isFunction(content)) {\n        labelCfg.content = content(origin, mappingData, index);\n      } else if (isUndefined(content)) {\n        // 用户未配置 content，则默认为映射的第一个字段的值\n        labelCfg.content = originText[0];\n      }\n\n      labelCfgs.push(labelCfg);\n    });\n\n    return labelCfgs;\n  }\n\n  private getLabelText(origin: Datum, scales: Scale[]) {\n    const labelTexts = [];\n    each(scales, (scale: Scale) => {\n      let value = origin[scale.field];\n      if (isArray(value)) {\n        value = value.map((subVal) => {\n          return scale.getText(subVal);\n        });\n      } else {\n        value = scale.getText(value);\n      }\n\n      if (isNil(value) || value === '') {\n        labelTexts.push(null);\n      } else {\n        labelTexts.push(value);\n      }\n    });\n    return labelTexts;\n  }\n\n  private getOffsetVector(offset: number | string = 0) {\n    const coordinate = this.getCoordinate();\n    let actualOffset = 0;\n    if (isNumber(offset)) {\n      actualOffset = offset;\n    }\n    // 如果 x,y 翻转，则偏移 x，否则偏移 y\n    return coordinate.isTransposed ? coordinate.applyMatrix(actualOffset, 0) : coordinate.applyMatrix(0, actualOffset);\n  }\n\n  private getGeometryShapes() {\n    const geometry = this.geometry;\n    const shapes = {};\n    each(geometry.elementsMap, (element: Element, id: string) => {\n      shapes[id] = element.shape;\n    });\n    // 因为有可能 shape 还在进行动画，导致 shape.getBBox() 获取到的值不是最终态，所以需要从 offscreenGroup 获取\n    each(geometry.getOffscreenGroup().getChildren(), (child) => {\n      const id = geometry.getElementId(child.get('origin').mappingData);\n      shapes[id] = child;\n    });\n\n    return shapes;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}