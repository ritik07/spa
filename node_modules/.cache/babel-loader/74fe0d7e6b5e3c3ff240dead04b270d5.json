{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { AbstractCanvas } from '@antv/g-base';\nimport { SHAPE_TO_TAGS } from './constant';\nimport { drawChildren } from './util/draw';\nimport { setTransform, setClip } from './util/svg';\nimport { sortDom, createSVGElement } from './util/dom';\nimport * as Shape from './shape';\nimport Group from './group';\nimport Defs from './defs';\nvar Canvas = /** @class */function (_super) {\n  __extends(Canvas, _super);\n  function Canvas(cfg) {\n    return _super.call(this, __assign(__assign({}, cfg), {\n      autoDraw: true,\n      // 设置渲染引擎为 canvas，只读属性\n      renderer: 'svg'\n    })) || this;\n  }\n  Canvas.prototype.getShapeBase = function () {\n    return Shape;\n  };\n  Canvas.prototype.getGroupBase = function () {\n    return Group;\n  };\n  // 覆盖 Container 中通过遍历的方式获取 shape 对象的逻辑，直接走 SVG 的 dom 拾取即可\n  Canvas.prototype.getShape = function (x, y, ev) {\n    var target = ev.target || ev.srcElement;\n    if (!SHAPE_TO_TAGS[target.tagName]) {\n      var parent_1 = target.parentNode;\n      while (parent_1 && !SHAPE_TO_TAGS[parent_1.tagName]) {\n        parent_1 = parent_1.parentNode;\n      }\n      target = parent_1;\n    }\n    return this.find(function (child) {\n      return child.get('el') === target;\n    });\n  };\n  // 复写基类的方法生成标签\n  Canvas.prototype.createDom = function () {\n    var element = createSVGElement('svg');\n    var context = new Defs(element);\n    element.setAttribute('width', \"\" + this.get('width'));\n    element.setAttribute('height', \"\" + this.get('height'));\n    // 缓存 context 对象\n    this.set('context', context);\n    return element;\n  };\n  /**\n   * 一些方法调用会引起画布变化\n   * @param {ChangeType} changeType 改变的类型\n   */\n  Canvas.prototype.onCanvasChange = function (changeType) {\n    var context = this.get('context');\n    var el = this.get('el');\n    if (changeType === 'sort') {\n      var children_1 = this.get('children');\n      if (children_1 && children_1.length) {\n        sortDom(this, function (a, b) {\n          return children_1.indexOf(a) - children_1.indexOf(b) ? 1 : 0;\n        });\n      }\n    } else if (changeType === 'clear') {\n      // el maybe null for canvas\n      if (el) {\n        // 清空 SVG 元素\n        el.innerHTML = '';\n        var defsEl = context.el;\n        // 清空 defs 元素\n        defsEl.innerHTML = '';\n        // 将清空后的 defs 元素挂载到 el 下\n        el.appendChild(defsEl);\n      }\n    } else if (changeType === 'matrix') {\n      setTransform(this);\n    } else if (changeType === 'clip') {\n      setClip(this, context);\n    } else if (changeType === 'changeSize') {\n      el.setAttribute('width', \"\" + this.get('width'));\n      el.setAttribute('height', \"\" + this.get('height'));\n    }\n  };\n  // 复写基类的 draw 方法\n  Canvas.prototype.draw = function () {\n    var context = this.get('context');\n    var children = this.getChildren();\n    setClip(this, context);\n    if (children.length) {\n      drawChildren(context, children);\n    }\n  };\n  return Canvas;\n}(AbstractCanvas);\nexport default Canvas;","map":{"version":3,"sources":["../src/canvas.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __assign, __extends } from \"tslib\";\nimport { AbstractCanvas } from '@antv/g-base';\nimport { SHAPE_TO_TAGS } from './constant';\nimport { drawChildren } from './util/draw';\nimport { setTransform, setClip } from './util/svg';\nimport { sortDom, createSVGElement } from './util/dom';\nimport * as Shape from './shape';\nimport Group from './group';\nimport Defs from './defs';\nvar Canvas = /** @class */ (function (_super) {\n    __extends(Canvas, _super);\n    function Canvas(cfg) {\n        return _super.call(this, __assign(__assign({}, cfg), { autoDraw: true, \n            // 设置渲染引擎为 canvas，只读属性\n            renderer: 'svg' })) || this;\n    }\n    Canvas.prototype.getShapeBase = function () {\n        return Shape;\n    };\n    Canvas.prototype.getGroupBase = function () {\n        return Group;\n    };\n    // 覆盖 Container 中通过遍历的方式获取 shape 对象的逻辑，直接走 SVG 的 dom 拾取即可\n    Canvas.prototype.getShape = function (x, y, ev) {\n        var target = ev.target || ev.srcElement;\n        if (!SHAPE_TO_TAGS[target.tagName]) {\n            var parent_1 = target.parentNode;\n            while (parent_1 && !SHAPE_TO_TAGS[parent_1.tagName]) {\n                parent_1 = parent_1.parentNode;\n            }\n            target = parent_1;\n        }\n        return this.find(function (child) { return child.get('el') === target; });\n    };\n    // 复写基类的方法生成标签\n    Canvas.prototype.createDom = function () {\n        var element = createSVGElement('svg');\n        var context = new Defs(element);\n        element.setAttribute('width', \"\" + this.get('width'));\n        element.setAttribute('height', \"\" + this.get('height'));\n        // 缓存 context 对象\n        this.set('context', context);\n        return element;\n    };\n    /**\n     * 一些方法调用会引起画布变化\n     * @param {ChangeType} changeType 改变的类型\n     */\n    Canvas.prototype.onCanvasChange = function (changeType) {\n        var context = this.get('context');\n        var el = this.get('el');\n        if (changeType === 'sort') {\n            var children_1 = this.get('children');\n            if (children_1 && children_1.length) {\n                sortDom(this, function (a, b) {\n                    return children_1.indexOf(a) - children_1.indexOf(b) ? 1 : 0;\n                });\n            }\n        }\n        else if (changeType === 'clear') {\n            // el maybe null for canvas\n            if (el) {\n                // 清空 SVG 元素\n                el.innerHTML = '';\n                var defsEl = context.el;\n                // 清空 defs 元素\n                defsEl.innerHTML = '';\n                // 将清空后的 defs 元素挂载到 el 下\n                el.appendChild(defsEl);\n            }\n        }\n        else if (changeType === 'matrix') {\n            setTransform(this);\n        }\n        else if (changeType === 'clip') {\n            setClip(this, context);\n        }\n        else if (changeType === 'changeSize') {\n            el.setAttribute('width', \"\" + this.get('width'));\n            el.setAttribute('height', \"\" + this.get('height'));\n        }\n    };\n    // 复写基类的 draw 方法\n    Canvas.prototype.draw = function () {\n        var context = this.get('context');\n        var children = this.getChildren();\n        setClip(this, context);\n        if (children.length) {\n            drawChildren(context, children);\n        }\n    };\n    return Canvas;\n}(AbstractCanvas));\nexport default Canvas;\n//# sourceMappingURL=canvas.js.map"]},"metadata":{},"sourceType":"module"}