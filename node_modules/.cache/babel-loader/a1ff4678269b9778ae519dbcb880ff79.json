{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { each } from '@antv/util';\nimport { registerShape } from '../base';\nimport { getPathPoints } from '../util/get-path-points';\nimport { getStyle } from '../util/get-style';\nimport { getLineMarker } from './util';\nvar interpolateCallback = function (point, nextPoint, shapeType) {\n  var x = point.x;\n  var y = point.y;\n  var nextX = nextPoint.x;\n  var nextY = nextPoint.y;\n  var result;\n  switch (shapeType) {\n    case 'hv':\n      result = [{\n        x: nextX,\n        y: y\n      }];\n      break;\n    case 'vh':\n      result = [{\n        x: x,\n        y: nextY\n      }];\n      break;\n    case 'hvh':\n      var middleX = (nextX + x) / 2;\n      result = [{\n        x: middleX,\n        y: y\n      }, {\n        x: middleX,\n        y: nextY\n      }];\n      break;\n    case 'vhv':\n      var middleY = (y + nextY) / 2;\n      result = [{\n        x: x,\n        y: middleY\n      }, {\n        x: nextX,\n        y: middleY\n      }];\n      break;\n    default:\n      break;\n  }\n  return result;\n};\nfunction getInterpolatePoints(points, shapeType) {\n  var result = [];\n  each(points, function (point, index) {\n    var nextPoint = points[index + 1];\n    result.push(point);\n    if (nextPoint) {\n      var interpolatePoint = interpolateCallback(point, nextPoint, shapeType);\n      result = result.concat(interpolatePoint);\n    }\n  });\n  return result;\n}\n// 插值的图形path，不考虑null\nfunction getInterpolatePath(points) {\n  return points.map(function (point, index) {\n    return index === 0 ? ['M', point.x, point.y] : ['L', point.x, point.y];\n  });\n}\n// 插值的图形\nfunction getInterpolateShapeAttrs(cfg, shapeType) {\n  var points = getPathPoints(cfg.points, cfg.connectNulls, cfg.showSinglePoint); // 根据 connectNulls 值处理 points\n  var path = [];\n  each(points, function (eachLinePoints) {\n    var interpolatePoints = getInterpolatePoints(eachLinePoints, shapeType);\n    path = path.concat(getInterpolatePath(interpolatePoints));\n  });\n  return __assign(__assign({}, getStyle(cfg, true, false, 'lineWidth')), {\n    path: path\n  });\n}\n// step line\neach(['hv', 'vh', 'hvh', 'vhv'], function (shapeType) {\n  registerShape('line', shapeType, {\n    draw: function (cfg, container) {\n      var attrs = getInterpolateShapeAttrs(cfg, shapeType);\n      var shape = container.addShape({\n        type: 'path',\n        attrs: attrs,\n        name: 'line'\n      });\n      return shape;\n    },\n    getMarker: function (markerCfg) {\n      return getLineMarker(markerCfg, shapeType);\n    }\n  });\n});","map":{"version":3,"sources":["../../../../src/geometry/shape/line/step.ts"],"names":[],"mappings":";AAAA,SAAS,IAAI,QAAQ,YAAY;AAIjC,SAAS,aAAa,QAAQ,SAAS;AACvC,SAAS,aAAa,QAAQ,yBAAyB;AACvD,SAAS,QAAQ,QAAQ,mBAAmB;AAC5C,SAAS,aAAa,QAAQ,QAAQ;AAEtC,IAAM,mBAAmB,GAAG,UAAC,KAAY,EAAE,SAAgB,EAAE,SAAiB,EAAA;EAC5E,IAAM,CAAC,GAAG,KAAK,CAAC,CAAW;EAC3B,IAAM,CAAC,GAAG,KAAK,CAAC,CAAW;EAC3B,IAAM,KAAK,GAAG,SAAS,CAAC,CAAW;EACnC,IAAM,KAAK,GAAG,SAAS,CAAC,CAAW;EACnC,IAAI,MAAM;EAEV,QAAQ,SAAS;IACf,KAAK,IAAI;MACP,MAAM,GAAG,CAAC;QAAE,CAAC,EAAE,KAAK;QAAE,CAAC,EAAA;MAAA,CAAE,CAAC;MAC1B;IACF,KAAK,IAAI;MACP,MAAM,GAAG,CAAC;QAAE,CAAC,EAAA,CAAA;QAAE,CAAC,EAAE;MAAK,CAAE,CAAC;MAC1B;IACF,KAAK,KAAK;MACR,IAAM,OAAO,GAAG,CAAC,KAAK,GAAG,CAAC,IAAI,CAAC;MAC/B,MAAM,GAAG,CACP;QAAE,CAAC,EAAE,OAAO;QAAE,CAAC,EAAA;MAAA,CAAE,EACjB;QAAE,CAAC,EAAE,OAAO;QAAE,CAAC,EAAE;MAAK,CAAE,CACzB;MACD;IACF,KAAK,KAAK;MACR,IAAM,OAAO,GAAG,CAAC,CAAC,GAAG,KAAK,IAAI,CAAC;MAC/B,MAAM,GAAG,CACP;QAAE,CAAC,EAAA,CAAA;QAAE,CAAC,EAAE;MAAO,CAAE,EACjB;QAAE,CAAC,EAAE,KAAK;QAAE,CAAC,EAAE;MAAO,CAAE,CACzB;MACD;IACF;MACE;EAAM;EAGV,OAAO,MAAM;AACf,CAAC;AAED,SAAS,oBAAoB,CAAC,MAAe,EAAE,SAAiB,EAAA;EAC9D,IAAI,MAAM,GAAG,EAAE;EACf,IAAI,CAAC,MAAM,EAAE,UAAC,KAAY,EAAE,KAAK,EAAA;IAC/B,IAAM,SAAS,GAAG,MAAM,CAAC,KAAK,GAAG,CAAC,CAAC;IACnC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC;IAClB,IAAI,SAAS,EAAE;MACb,IAAM,gBAAgB,GAAG,mBAAmB,CAAC,KAAK,EAAE,SAAS,EAAE,SAAS,CAAC;MACzE,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,gBAAgB,CAAC;IACzC;EACH,CAAC,CAAC;EACF,OAAO,MAAM;AACf;AAEA;AACA,SAAS,kBAAkB,CAAC,MAAe,EAAA;EACzC,OAAO,MAAM,CAAC,GAAG,CAAC,UAAC,KAAK,EAAE,KAAK,EAAA;IAC7B,OAAO,KAAK,KAAK,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC;EACxE,CAAC,CAAC;AACJ;AAEA;AACA,SAAS,wBAAwB,CAAC,GAAc,EAAE,SAAiB,EAAA;EACjE,IAAM,MAAM,GAAG,aAAa,CAAC,GAAG,CAAC,MAAM,EAAE,GAAG,CAAC,YAAY,EAAE,GAAG,CAAC,eAAe,CAAC,CAAC,CAAC;EACjF,IAAI,IAAI,GAAG,EAAE;EACb,IAAI,CAAC,MAAM,EAAE,UAAC,cAAc,EAAA;IAC1B,IAAM,iBAAiB,GAAG,oBAAoB,CAAC,cAAc,EAAE,SAAS,CAAC;IACzE,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,kBAAkB,CAAC,iBAAiB,CAAC,CAAC;EAC3D,CAAC,CAAC;EAEF,OAAA,QAAA,CAAA,QAAA,CAAA,CAAA,CAAA,EACK,QAAQ,CAAC,GAAG,EAAE,IAAI,EAAE,KAAK,EAAE,WAAW,CAAC,CAAA,EAAA;IAC1C,IAAI,EAAA;EAAA,CAAA,CAAA;AAER;AAEA;AACA,IAAI,CAAC,CAAC,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,CAAC,EAAE,UAAC,SAAS,EAAA;EACzC,aAAa,CAAC,MAAM,EAAE,SAAS,EAAE;IAC/B,IAAI,EAAA,UAAC,GAAc,EAAE,SAAiB,EAAA;MACpC,IAAM,KAAK,GAAG,wBAAwB,CAAC,GAAG,EAAE,SAAS,CAAC;MACtD,IAAM,KAAK,GAAG,SAAS,CAAC,QAAQ,CAAC;QAC/B,IAAI,EAAE,MAAM;QACZ,KAAK,EAAA,KAAA;QACL,IAAI,EAAE;OACP,CAAC;MAEF,OAAO,KAAK;IACd,CAAC;IACD,SAAS,EAAA,UAAC,SAAyB,EAAA;MACjC,OAAO,aAAa,CAAC,SAAS,EAAE,SAAS,CAAC;IAC5C;GACD,CAAC;AACJ,CAAC,CAAC","sourcesContent":["import { each } from '@antv/util';\nimport { IGroup } from '../../../dependents';\nimport { Point, ShapeInfo, ShapeMarkerCfg } from '../../../interface';\n\nimport { registerShape } from '../base';\nimport { getPathPoints } from '../util/get-path-points';\nimport { getStyle } from '../util/get-style';\nimport { getLineMarker } from './util';\n\nconst interpolateCallback = (point: Point, nextPoint: Point, shapeType: string) => {\n  const x = point.x as number;\n  const y = point.y as number;\n  const nextX = nextPoint.x as number;\n  const nextY = nextPoint.y as number;\n  let result;\n\n  switch (shapeType) {\n    case 'hv':\n      result = [{ x: nextX, y }];\n      break;\n    case 'vh':\n      result = [{ x, y: nextY }];\n      break;\n    case 'hvh':\n      const middleX = (nextX + x) / 2;\n      result = [\n        { x: middleX, y },\n        { x: middleX, y: nextY },\n      ];\n      break;\n    case 'vhv':\n      const middleY = (y + nextY) / 2;\n      result = [\n        { x, y: middleY },\n        { x: nextX, y: middleY },\n      ];\n      break;\n    default:\n      break;\n  }\n\n  return result;\n};\n\nfunction getInterpolatePoints(points: Point[], shapeType: string) {\n  let result = [];\n  each(points, (point: Point, index) => {\n    const nextPoint = points[index + 1];\n    result.push(point);\n    if (nextPoint) {\n      const interpolatePoint = interpolateCallback(point, nextPoint, shapeType);\n      result = result.concat(interpolatePoint);\n    }\n  });\n  return result;\n}\n\n// 插值的图形path，不考虑null\nfunction getInterpolatePath(points: Point[]) {\n  return points.map((point, index) => {\n    return index === 0 ? ['M', point.x, point.y] : ['L', point.x, point.y];\n  });\n}\n\n// 插值的图形\nfunction getInterpolateShapeAttrs(cfg: ShapeInfo, shapeType: string) {\n  const points = getPathPoints(cfg.points, cfg.connectNulls, cfg.showSinglePoint); // 根据 connectNulls 值处理 points\n  let path = [];\n  each(points, (eachLinePoints) => {\n    const interpolatePoints = getInterpolatePoints(eachLinePoints, shapeType);\n    path = path.concat(getInterpolatePath(interpolatePoints));\n  });\n\n  return {\n    ...getStyle(cfg, true, false, 'lineWidth'),\n    path,\n  };\n}\n\n// step line\neach(['hv', 'vh', 'hvh', 'vhv'], (shapeType) => {\n  registerShape('line', shapeType, {\n    draw(cfg: ShapeInfo, container: IGroup) {\n      const attrs = getInterpolateShapeAttrs(cfg, shapeType);\n      const shape = container.addShape({\n        type: 'path',\n        attrs,\n        name: 'line',\n      });\n\n      return shape;\n    },\n    getMarker(markerCfg: ShapeMarkerCfg) {\n      return getLineMarker(markerCfg, shapeType);\n    },\n  });\n});\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}