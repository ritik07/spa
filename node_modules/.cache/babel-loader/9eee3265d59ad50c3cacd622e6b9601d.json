{"ast":null,"code":"import { each } from '@antv/util';\nvar MAX_TIMES = 100;\n/**\n * @ignore\n * Greedy 贪婪算法\n */\nvar Greedy = /** @class */function () {\n  function Greedy(cfg) {\n    if (cfg === void 0) {\n      cfg = {};\n    }\n    this.bitmap = {};\n    var _a = cfg.xGap,\n      xGap = _a === void 0 ? 1 : _a,\n      _b = cfg.yGap,\n      yGap = _b === void 0 ? 8 : _b;\n    this.xGap = xGap;\n    this.yGap = yGap;\n  }\n  Greedy.prototype.hasGap = function (bbox) {\n    var hasGap = true;\n    var bitmap = this.bitmap;\n    var minX = Math.round(bbox.minX);\n    var maxX = Math.round(bbox.maxX);\n    var minY = Math.round(bbox.minY);\n    var maxY = Math.round(bbox.maxY);\n    for (var i = minX; i <= maxX; i += 1) {\n      if (!bitmap[i]) {\n        bitmap[i] = {};\n        continue;\n      }\n      if (i === minX || i === maxX) {\n        for (var j = minY; j <= maxY; j++) {\n          if (bitmap[i][j]) {\n            hasGap = false;\n            break;\n          }\n        }\n      } else {\n        if (bitmap[i][minY] || bitmap[i][maxY]) {\n          hasGap = false;\n          break;\n        }\n      }\n    }\n    return hasGap;\n  };\n  Greedy.prototype.fillGap = function (bbox) {\n    var bitmap = this.bitmap;\n    var minX = Math.round(bbox.minX);\n    var maxX = Math.round(bbox.maxX);\n    var minY = Math.round(bbox.minY);\n    var maxY = Math.round(bbox.maxY);\n    // filling grid\n    for (var i = minX; i <= maxX; i += 1) {\n      if (!bitmap[i]) {\n        bitmap[i] = {};\n      }\n    }\n    for (var i = minX; i <= maxX; i += this.xGap) {\n      for (var j = minY; j <= maxY; j += this.yGap) {\n        bitmap[i][j] = true;\n      }\n      bitmap[i][maxY] = true;\n    }\n    // filling y edges\n    if (this.yGap !== 1) {\n      for (var i = minY; i <= maxY; i += 1) {\n        bitmap[minX][i] = true;\n        bitmap[maxX][i] = true;\n      }\n    }\n    // filling x edges\n    if (this.xGap !== 1) {\n      for (var i = minX; i <= maxX; i += 1) {\n        bitmap[i][minY] = true;\n        bitmap[i][maxY] = true;\n      }\n    }\n  };\n  Greedy.prototype.destroy = function () {\n    this.bitmap = {};\n  };\n  return Greedy;\n}();\nfunction spiralFill(label, greedy, maxTimes) {\n  if (maxTimes === void 0) {\n    maxTimes = MAX_TIMES;\n  }\n  var dt = -1;\n  var _a = label.attr(),\n    x = _a.x,\n    y = _a.y;\n  var bbox = label.getCanvasBBox();\n  var maxDelta = Math.sqrt(bbox.width * bbox.width + bbox.height * bbox.height);\n  var dxdy;\n  var t = -dt;\n  var dx = 0;\n  var dy = 0;\n  var f = function (param) {\n    var nt = param * 0.1;\n    return [nt * Math.cos(nt), nt * Math.sin(nt)];\n  };\n  if (greedy.hasGap(bbox)) {\n    greedy.fillGap(bbox);\n    return true;\n  }\n  var canFill = false;\n  var times = 0;\n  var accessedCache = {};\n  while (Math.min(Math.abs(dx), Math.abs(dy)) < maxDelta && times < maxTimes) {\n    dxdy = f(t += dt);\n    dx = ~~dxdy[0];\n    dy = ~~dxdy[1];\n    if (!dx && !dy || accessedCache[\"\".concat(dx, \"-\").concat(dy)]) {\n      continue;\n    }\n    label.attr({\n      x: x + dx,\n      y: y + dy\n    });\n    if (dx + dy < 0) {\n      label.attr('textAlign', 'right');\n    }\n    times++;\n    if (greedy.hasGap(label.getCanvasBBox())) {\n      greedy.fillGap(label.getCanvasBBox());\n      canFill = true;\n      accessedCache[\"\".concat(dx, \"-\").concat(dy)] = true;\n      break;\n    }\n  }\n  return canFill;\n}\n/*\n *  根据如下规则尝试放置label\n *                5\n *        ------------------\n *        |    1   |   0   |\n *    8   —————————4————————   7\n *        |    2   |   3   |\n *        ——————————————————\n *                 6\n */\nfunction adjustLabelPosition(label, x, y, index) {\n  var _a = label.getCanvasBBox(),\n    width = _a.width,\n    height = _a.height;\n  var attrs = {\n    x: x,\n    y: y,\n    textAlign: 'center'\n  };\n  switch (index) {\n    case 0:\n      attrs.y -= height + 1;\n      attrs.x += 1;\n      attrs.textAlign = 'left';\n      break;\n    case 1:\n      attrs.y -= height + 1;\n      attrs.x -= 1;\n      attrs.textAlign = 'right';\n      break;\n    case 2:\n      attrs.y += height + 1;\n      attrs.x -= 1;\n      attrs.textAlign = 'right';\n      break;\n    case 3:\n      attrs.y += height + 1;\n      attrs.x += 1;\n      attrs.textAlign = 'left';\n      break;\n    case 5:\n      attrs.y -= height * 2 + 2;\n      break;\n    case 6:\n      attrs.y += height * 2 + 2;\n      break;\n    case 7:\n      attrs.x += width + 1;\n      attrs.textAlign = 'left';\n      break;\n    case 8:\n      attrs.x -= width + 1;\n      attrs.textAlign = 'right';\n      break;\n    default:\n      break;\n  }\n  label.attr(attrs);\n  return label.getCanvasBBox();\n}\n/**\n * @ignore\n * label 防遮挡布局：在不改变 label 位置的情况下对相互重叠的 label 进行调整。\n * 不同于 'overlap' 类型的布局，该布局不会对 label 的位置进行偏移调整。\n * @param labels 参与布局调整的 label 数组集合\n */\nexport function fixedOverlap(items, labels, shapes, region) {\n  var greedy = new Greedy();\n  each(labels, function (label) {\n    var labelShape = label.find(function (shape) {\n      return shape.get('type') === 'text';\n    });\n    if (!spiralFill(labelShape, greedy)) {\n      label.remove(true);\n    }\n  });\n  greedy.destroy();\n}\n/**\n * @ignore\n * label 防遮挡布局：为了防止 label 之间相互覆盖同时保证尽可能多 的 label 展示，通过尝试将 label 向**四周偏移**来剔除放不下的 label\n * @param labels 参与布局调整的 label 数组集合\n */\nexport function overlap(items, labels, shapes, region) {\n  var greedy = new Greedy();\n  each(labels, function (label) {\n    var labelShape = label.find(function (shape) {\n      return shape.get('type') === 'text';\n    });\n    var _a = labelShape.attr(),\n      x = _a.x,\n      y = _a.y;\n    var canFill = false;\n    for (var i = 0; i <= 8; i++) {\n      var bbox = adjustLabelPosition(labelShape, x, y, i);\n      if (greedy.hasGap(bbox)) {\n        greedy.fillGap(bbox);\n        canFill = true;\n        break;\n      }\n    }\n    if (!canFill) {\n      label.remove(true);\n    }\n  });\n  greedy.destroy();\n}","map":{"version":3,"sources":["../../../../src/geometry/label/layout/overlap.ts"],"names":[],"mappings":"AAAA,SAAS,IAAI,QAAQ,YAAY;AAIjC,IAAM,SAAS,GAAG,GAAG;AAerB;;;AAGG;AACH,IAAA,MAAA,GAAA,aAAA,YAAA;EAOE,SAAA,MAAA,CAAY,GAAmB,EAAA;IAAnB,IAAA,GAAA,KAAA,KAAA,CAAA,EAAA;MAAA,GAAA,GAAA,CAAA,CAAmB;IAAA;IAFvB,IAAA,CAAA,MAAM,GAAW,CAAA,CAAE;IAGjB,IAAA,EAAA,GAAuB,GAAG,CAAA,IAAlB;MAAR,IAAI,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,CAAC,GAAA,EAAA;MAAE,EAAA,GAAa,GAAG,CAAA,IAAR;MAAR,IAAI,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,CAAC,GAAA,EAAA;IAC1B,IAAI,CAAC,IAAI,GAAG,IAAI;IAChB,IAAI,CAAC,IAAI,GAAG,IAAI;EAClB;EAEO,MAAA,CAAA,SAAA,CAAA,MAAM,GAAb,UAAc,IAAU,EAAA;IACtB,IAAI,MAAM,GAAG,IAAI;IACjB,IAAM,MAAM,GAAG,IAAI,CAAC,MAAM;IAC1B,IAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC;IAClC,IAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC;IAClC,IAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC;IAClC,IAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC;IAClC,KAAK,IAAI,CAAC,GAAG,IAAI,EAAE,CAAC,IAAI,IAAI,EAAE,CAAC,IAAI,CAAC,EAAE;MACpC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE;QACd,MAAM,CAAC,CAAC,CAAC,GAAG,CAAA,CAAE;QACd;MACD;MACD,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,IAAI,EAAE;QAC5B,KAAK,IAAI,CAAC,GAAG,IAAI,EAAE,CAAC,IAAI,IAAI,EAAE,CAAC,EAAE,EAAE;UACjC,IAAI,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE;YAChB,MAAM,GAAG,KAAK;YACd;UACD;QACF;OACF,MAAM;QACL,IAAI,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE;UACtC,MAAM,GAAG,KAAK;UACd;QACD;MACF;IACF;IACD,OAAO,MAAM;EACf,CAAC;EAEM,MAAA,CAAA,SAAA,CAAA,OAAO,GAAd,UAAe,IAAU,EAAA;IACvB,IAAM,MAAM,GAAG,IAAI,CAAC,MAAM;IAC1B,IAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC;IAClC,IAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC;IAClC,IAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC;IAClC,IAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC;IAClC;IACA,KAAK,IAAI,CAAC,GAAG,IAAI,EAAE,CAAC,IAAI,IAAI,EAAE,CAAC,IAAI,CAAC,EAAE;MACpC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE;QACd,MAAM,CAAC,CAAC,CAAC,GAAG,CAAA,CAAE;MACf;IACF;IACD,KAAK,IAAI,CAAC,GAAG,IAAI,EAAE,CAAC,IAAI,IAAI,EAAE,CAAC,IAAI,IAAI,CAAC,IAAI,EAAE;MAC5C,KAAK,IAAI,CAAC,GAAG,IAAI,EAAE,CAAC,IAAI,IAAI,EAAE,CAAC,IAAI,IAAI,CAAC,IAAI,EAAE;QAC5C,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI;MACpB;MACD,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,IAAI;IACvB;IAED;IACA,IAAI,IAAI,CAAC,IAAI,KAAK,CAAC,EAAE;MACnB,KAAK,IAAI,CAAC,GAAG,IAAI,EAAE,CAAC,IAAI,IAAI,EAAE,CAAC,IAAI,CAAC,EAAE;QACpC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI;QACtB,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI;MACvB;IACF;IAED;IACA,IAAI,IAAI,CAAC,IAAI,KAAK,CAAC,EAAE;MACnB,KAAK,IAAI,CAAC,GAAG,IAAI,EAAE,CAAC,IAAI,IAAI,EAAE,CAAC,IAAI,CAAC,EAAE;QACpC,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,IAAI;QACtB,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,IAAI;MACvB;IACF;EACH,CAAC;EAEM,MAAA,CAAA,SAAA,CAAA,OAAO,GAAd,YAAA;IACE,IAAI,CAAC,MAAM,GAAG,CAAA,CAAE;EAClB,CAAC;EACH,OAAA,MAAC;AAAD,CAAC,EAAA;AAED,SAAS,UAAU,CAAC,KAAa,EAAE,MAAc,EAAE,QAA4B,EAAA;EAA5B,IAAA,QAAA,KAAA,KAAA,CAAA,EAAA;IAAA,QAAA,GAAA,SAA4B;EAAA;EAC7E,IAAM,EAAE,GAAG,CAAC,CAAC;EACP,IAAA,EAAA,GAAW,KAAK,CAAC,IAAI,EAAE;IAArB,CAAC,GAAA,EAAA,CAAA,CAAA;IAAE,CAAC,GAAA,EAAA,CAAA,CAAiB;EAC7B,IAAM,IAAI,GAAG,KAAK,CAAC,aAAa,EAAE;EAClC,IAAM,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;EAC/E,IAAI,IAAI;EACR,IAAI,CAAC,GAAG,CAAC,EAAE;EACX,IAAI,EAAE,GAAG,CAAC;EACV,IAAI,EAAE,GAAG,CAAC;EACV,IAAM,CAAC,GAAG,UAAC,KAAa,EAAA;IACtB,IAAM,EAAE,GAAG,KAAK,GAAG,GAAG;IACtB,OAAO,CAAC,EAAE,GAAG,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE,GAAG,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;EAC/C,CAAC;EAED,IAAI,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE;IACvB,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC;IACpB,OAAO,IAAI;EACZ;EACD,IAAI,OAAO,GAAG,KAAK;EACnB,IAAI,KAAK,GAAG,CAAC;EACb,IAAM,aAAa,GAAG,CAAA,CAAE;EACxB,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,GAAG,QAAQ,IAAI,KAAK,GAAG,QAAQ,EAAE;IAC1E,IAAI,GAAG,CAAC,CAAE,CAAC,IAAI,EAAE,CAAE;IACnB,EAAE,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;IACd,EAAE,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;IACd,IAAK,CAAC,EAAE,IAAI,CAAC,EAAE,IAAK,aAAa,CAAC,EAAA,CAAA,MAAA,CAAG,EAAE,EAAA,GAAA,CAAA,CAAA,MAAA,CAAI,EAAE,CAAE,CAAC,EAAE;MAChD;IACD;IACD,KAAK,CAAC,IAAI,CAAC;MAAE,CAAC,EAAE,CAAC,GAAG,EAAE;MAAE,CAAC,EAAE,CAAC,GAAG;IAAE,CAAE,CAAC;IACpC,IAAI,EAAE,GAAG,EAAE,GAAG,CAAC,EAAE;MACf,KAAK,CAAC,IAAI,CAAC,WAAW,EAAE,OAAO,CAAC;IACjC;IACD,KAAK,EAAE;IACP,IAAI,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,aAAa,EAAE,CAAC,EAAE;MACxC,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,aAAa,EAAE,CAAC;MACrC,OAAO,GAAG,IAAI;MACd,aAAa,CAAC,EAAA,CAAA,MAAA,CAAG,EAAE,EAAA,GAAA,CAAA,CAAA,MAAA,CAAI,EAAE,CAAE,CAAC,GAAG,IAAI;MACnC;IACD;EACF;EACD,OAAO,OAAO;AAChB;AAEA;;;;;;;;;AASG;AACH,SAAS,mBAAmB,CAAC,KAAa,EAAE,CAAS,EAAE,CAAS,EAAE,KAAa,EAAA;EACvE,IAAA,EAAA,GAAoB,KAAK,CAAC,aAAa,EAAE;IAAvC,KAAK,GAAA,EAAA,CAAA,KAAA;IAAE,MAAM,GAAA,EAAA,CAAA,MAA0B;EAC/C,IAAM,KAAK,GAAG;IACZ,CAAC,EAAA,CAAA;IACD,CAAC,EAAA,CAAA;IACD,SAAS,EAAE;GACZ;EACD,QAAQ,KAAK;IACX,KAAK,CAAC;MACJ,KAAK,CAAC,CAAC,IAAI,MAAM,GAAG,CAAC;MACrB,KAAK,CAAC,CAAC,IAAI,CAAC;MACZ,KAAK,CAAC,SAAS,GAAG,MAAM;MACxB;IACF,KAAK,CAAC;MACJ,KAAK,CAAC,CAAC,IAAI,MAAM,GAAG,CAAC;MACrB,KAAK,CAAC,CAAC,IAAI,CAAC;MACZ,KAAK,CAAC,SAAS,GAAG,OAAO;MACzB;IACF,KAAK,CAAC;MACJ,KAAK,CAAC,CAAC,IAAI,MAAM,GAAG,CAAC;MACrB,KAAK,CAAC,CAAC,IAAI,CAAC;MACZ,KAAK,CAAC,SAAS,GAAG,OAAO;MACzB;IACF,KAAK,CAAC;MACJ,KAAK,CAAC,CAAC,IAAI,MAAM,GAAG,CAAC;MACrB,KAAK,CAAC,CAAC,IAAI,CAAC;MACZ,KAAK,CAAC,SAAS,GAAG,MAAM;MACxB;IACF,KAAK,CAAC;MACJ,KAAK,CAAC,CAAC,IAAI,MAAM,GAAG,CAAC,GAAG,CAAC;MACzB;IACF,KAAK,CAAC;MACJ,KAAK,CAAC,CAAC,IAAI,MAAM,GAAG,CAAC,GAAG,CAAC;MACzB;IACF,KAAK,CAAC;MACJ,KAAK,CAAC,CAAC,IAAI,KAAK,GAAG,CAAC;MACpB,KAAK,CAAC,SAAS,GAAG,MAAM;MACxB;IACF,KAAK,CAAC;MACJ,KAAK,CAAC,CAAC,IAAI,KAAK,GAAG,CAAC;MACpB,KAAK,CAAC,SAAS,GAAG,OAAO;MACzB;IACF;MACE;EAAM;EAEV,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC;EACjB,OAAO,KAAK,CAAC,aAAa,EAAE;AAC9B;AAEA;;;;;AAKG;AACH,OAAM,SAAU,YAAY,CAAC,KAAkB,EAAE,MAAgB,EAAE,MAA2B,EAAE,MAAY,EAAA;EAC1G,IAAM,MAAM,GAAG,IAAI,MAAM,EAAE;EAC3B,IAAI,CAAC,MAAM,EAAE,UAAC,KAAa,EAAA;IACzB,IAAM,UAAU,GAAG,KAAK,CAAC,IAAI,CAAC,UAAC,KAAK,EAAA;MAAK,OAAA,KAAK,CAAC,GAAG,CAAC,MAAM,CAAC,KAAK,MAAM;IAA5B,CAA4B,CAAW;IAChF,IAAI,CAAC,UAAU,CAAC,UAAU,EAAE,MAAM,CAAC,EAAE;MACnC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC;IACnB;EACH,CAAC,CAAC;EACF,MAAM,CAAC,OAAO,EAAE;AAClB;AAEA;;;;AAIG;AACH,OAAM,SAAU,OAAO,CAAC,KAAkB,EAAE,MAAgB,EAAE,MAA2B,EAAE,MAAY,EAAA;EACrG,IAAM,MAAM,GAAG,IAAI,MAAM,EAAE;EAC3B,IAAI,CAAC,MAAM,EAAE,UAAC,KAAa,EAAA;IACzB,IAAM,UAAU,GAAG,KAAK,CAAC,IAAI,CAAC,UAAC,KAAK,EAAA;MAAK,OAAA,KAAK,CAAC,GAAG,CAAC,MAAM,CAAC,KAAK,MAAM;IAA5B,CAA4B,CAAW;IAC1E,IAAA,EAAA,GAAW,UAAU,CAAC,IAAI,EAAE;MAA1B,CAAC,GAAA,EAAA,CAAA,CAAA;MAAE,CAAC,GAAA,EAAA,CAAA,CAAsB;IAClC,IAAI,OAAO,GAAG,KAAK;IACnB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE;MAC3B,IAAM,IAAI,GAAG,mBAAmB,CAAC,UAAU,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;MACrD,IAAI,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE;QACvB,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC;QACpB,OAAO,GAAG,IAAI;QACd;MACD;IACF;IACD,IAAI,CAAC,OAAO,EAAE;MACZ,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC;IACnB;EACH,CAAC,CAAC;EAEF,MAAM,CAAC,OAAO,EAAE;AAClB","sourcesContent":["import { each } from '@antv/util';\nimport { BBox, IGroup, IShape } from '../../../dependents';\nimport { LabelItem } from '../interface';\n\nconst MAX_TIMES = 100;\n\n/** @ignore */\ninterface Bitmap {\n  [key: number]: {\n    [key: number]: boolean;\n  };\n}\n\n/** @ignore */\ninterface GreedyCfg {\n  readonly xGap?: number;\n  readonly yGap?: number;\n}\n\n/**\n * @ignore\n * Greedy 贪婪算法\n */\nclass Greedy {\n  public readonly xGap: number;\n  /** optimizing for text overlapping detection: use a min text height as gap */\n  public readonly yGap: number;\n\n  private bitmap: Bitmap = {};\n\n  constructor(cfg: GreedyCfg = {}) {\n    const { xGap = 1, yGap = 8 } = cfg;\n    this.xGap = xGap;\n    this.yGap = yGap;\n  }\n\n  public hasGap(bbox: BBox): boolean {\n    let hasGap = true;\n    const bitmap = this.bitmap;\n    const minX = Math.round(bbox.minX);\n    const maxX = Math.round(bbox.maxX);\n    const minY = Math.round(bbox.minY);\n    const maxY = Math.round(bbox.maxY);\n    for (let i = minX; i <= maxX; i += 1) {\n      if (!bitmap[i]) {\n        bitmap[i] = {};\n        continue;\n      }\n      if (i === minX || i === maxX) {\n        for (let j = minY; j <= maxY; j++) {\n          if (bitmap[i][j]) {\n            hasGap = false;\n            break;\n          }\n        }\n      } else {\n        if (bitmap[i][minY] || bitmap[i][maxY]) {\n          hasGap = false;\n          break;\n        }\n      }\n    }\n    return hasGap;\n  }\n\n  public fillGap(bbox: BBox): void {\n    const bitmap = this.bitmap;\n    const minX = Math.round(bbox.minX);\n    const maxX = Math.round(bbox.maxX);\n    const minY = Math.round(bbox.minY);\n    const maxY = Math.round(bbox.maxY);\n    // filling grid\n    for (let i = minX; i <= maxX; i += 1) {\n      if (!bitmap[i]) {\n        bitmap[i] = {};\n      }\n    }\n    for (let i = minX; i <= maxX; i += this.xGap) {\n      for (let j = minY; j <= maxY; j += this.yGap) {\n        bitmap[i][j] = true;\n      }\n      bitmap[i][maxY] = true;\n    }\n\n    // filling y edges\n    if (this.yGap !== 1) {\n      for (let i = minY; i <= maxY; i += 1) {\n        bitmap[minX][i] = true;\n        bitmap[maxX][i] = true;\n      }\n    }\n\n    // filling x edges\n    if (this.xGap !== 1) {\n      for (let i = minX; i <= maxX; i += 1) {\n        bitmap[i][minY] = true;\n        bitmap[i][maxY] = true;\n      }\n    }\n  }\n\n  public destroy(): void {\n    this.bitmap = {};\n  }\n}\n\nfunction spiralFill(label: IShape, greedy: Greedy, maxTimes: number = MAX_TIMES) {\n  const dt = -1;\n  const { x, y } = label.attr();\n  const bbox = label.getCanvasBBox();\n  const maxDelta = Math.sqrt(bbox.width * bbox.width + bbox.height * bbox.height);\n  let dxdy;\n  let t = -dt;\n  let dx = 0;\n  let dy = 0;\n  const f = (param: number) => {\n    const nt = param * 0.1;\n    return [nt * Math.cos(nt), nt * Math.sin(nt)];\n  };\n\n  if (greedy.hasGap(bbox)) {\n    greedy.fillGap(bbox);\n    return true;\n  }\n  let canFill = false;\n  let times = 0;\n  const accessedCache = {};\n  while (Math.min(Math.abs(dx), Math.abs(dy)) < maxDelta && times < maxTimes) {\n    dxdy = f((t += dt));\n    dx = ~~dxdy[0];\n    dy = ~~dxdy[1];\n    if ((!dx && !dy) || accessedCache[`${dx}-${dy}`]) {\n      continue;\n    }\n    label.attr({ x: x + dx, y: y + dy });\n    if (dx + dy < 0) {\n      label.attr('textAlign', 'right');\n    }\n    times++;\n    if (greedy.hasGap(label.getCanvasBBox())) {\n      greedy.fillGap(label.getCanvasBBox());\n      canFill = true;\n      accessedCache[`${dx}-${dy}`] = true;\n      break;\n    }\n  }\n  return canFill;\n}\n\n/*\n *  根据如下规则尝试放置label\n *                5\n *        ------------------\n *        |    1   |   0   |\n *    8   —————————4————————   7\n *        |    2   |   3   |\n *        ——————————————————\n *                 6\n */\nfunction adjustLabelPosition(label: IShape, x: number, y: number, index: number) {\n  const { width, height } = label.getCanvasBBox();\n  const attrs = {\n    x,\n    y,\n    textAlign: 'center',\n  };\n  switch (index) {\n    case 0:\n      attrs.y -= height + 1;\n      attrs.x += 1;\n      attrs.textAlign = 'left';\n      break;\n    case 1:\n      attrs.y -= height + 1;\n      attrs.x -= 1;\n      attrs.textAlign = 'right';\n      break;\n    case 2:\n      attrs.y += height + 1;\n      attrs.x -= 1;\n      attrs.textAlign = 'right';\n      break;\n    case 3:\n      attrs.y += height + 1;\n      attrs.x += 1;\n      attrs.textAlign = 'left';\n      break;\n    case 5:\n      attrs.y -= height * 2 + 2;\n      break;\n    case 6:\n      attrs.y += height * 2 + 2;\n      break;\n    case 7:\n      attrs.x += width + 1;\n      attrs.textAlign = 'left';\n      break;\n    case 8:\n      attrs.x -= width + 1;\n      attrs.textAlign = 'right';\n      break;\n    default:\n      break;\n  }\n  label.attr(attrs);\n  return label.getCanvasBBox();\n}\n\n/**\n * @ignore\n * label 防遮挡布局：在不改变 label 位置的情况下对相互重叠的 label 进行调整。\n * 不同于 'overlap' 类型的布局，该布局不会对 label 的位置进行偏移调整。\n * @param labels 参与布局调整的 label 数组集合\n */\nexport function fixedOverlap(items: LabelItem[], labels: IGroup[], shapes: IShape[] | IGroup[], region: BBox) {\n  const greedy = new Greedy();\n  each(labels, (label: IGroup) => {\n    const labelShape = label.find((shape) => shape.get('type') === 'text') as IShape;\n    if (!spiralFill(labelShape, greedy)) {\n      label.remove(true);\n    }\n  });\n  greedy.destroy();\n}\n\n/**\n * @ignore\n * label 防遮挡布局：为了防止 label 之间相互覆盖同时保证尽可能多 的 label 展示，通过尝试将 label 向**四周偏移**来剔除放不下的 label\n * @param labels 参与布局调整的 label 数组集合\n */\nexport function overlap(items: LabelItem[], labels: IGroup[], shapes: IShape[] | IGroup[], region: BBox) {\n  const greedy = new Greedy();\n  each(labels, (label: IGroup) => {\n    const labelShape = label.find((shape) => shape.get('type') === 'text') as IShape;\n    const { x, y } = labelShape.attr();\n    let canFill = false;\n    for (let i = 0; i <= 8; i++) {\n      const bbox = adjustLabelPosition(labelShape, x, y, i);\n      if (greedy.hasGap(bbox)) {\n        greedy.fillGap(bbox);\n        canFill = true;\n        break;\n      }\n    }\n    if (!canFill) {\n      label.remove(true);\n    }\n  });\n\n  greedy.destroy();\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}