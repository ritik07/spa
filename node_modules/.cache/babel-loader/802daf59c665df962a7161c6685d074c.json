{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { AbstractShape } from '@antv/g-base';\nimport { setShadow, setTransform, setClip } from '../util/svg';\nimport { createDom } from '../util/dom';\nimport { refreshElement } from '../util/draw';\nimport { SVG_ATTR_MAP } from '../constant';\nimport * as Shape from './index';\nimport Group from '../group';\nimport { getBBoxMethod } from '@antv/g-base';\nvar ShapeBase = /** @class */function (_super) {\n  __extends(ShapeBase, _super);\n  function ShapeBase() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = 'svg';\n    _this.canFill = false;\n    _this.canStroke = false;\n    return _this;\n  }\n  ShapeBase.prototype.getDefaultAttrs = function () {\n    var attrs = _super.prototype.getDefaultAttrs.call(this);\n    // 设置默认值\n    return __assign(__assign({}, attrs), {\n      lineWidth: 1,\n      lineAppendWidth: 0,\n      strokeOpacity: 1,\n      fillOpacity: 1\n    });\n  };\n  // 覆盖基类的 afterAttrsChange 方法\n  ShapeBase.prototype.afterAttrsChange = function (targetAttrs) {\n    _super.prototype.afterAttrsChange.call(this, targetAttrs);\n    var canvas = this.get('canvas');\n    // 只有挂载到画布下，才对元素进行实际渲染\n    if (canvas && canvas.get('autoDraw')) {\n      var context = canvas.get('context');\n      this.draw(context, targetAttrs);\n    }\n  };\n  ShapeBase.prototype.getShapeBase = function () {\n    return Shape;\n  };\n  ShapeBase.prototype.getGroupBase = function () {\n    return Group;\n  };\n  /**\n   * 一些方法调用会引起画布变化\n   * @param {ChangeType} changeType 改变的类型\n   */\n  ShapeBase.prototype.onCanvasChange = function (changeType) {\n    refreshElement(this, changeType);\n  };\n  ShapeBase.prototype.calculateBBox = function () {\n    var el = this.get('el');\n    var bbox = null;\n    // 包围盒计算依赖于绘制，如果还没有生成对应的 Dom 元素，则包围盒的长宽均为 0\n    if (el) {\n      bbox = el.getBBox();\n    } else {\n      var bboxMethod = getBBoxMethod(this.get('type'));\n      if (bboxMethod) {\n        bbox = bboxMethod(this);\n      }\n    }\n    if (bbox) {\n      var x = bbox.x,\n        y = bbox.y,\n        width = bbox.width,\n        height = bbox.height;\n      var lineWidth = this.getHitLineWidth();\n      var halfWidth = lineWidth / 2;\n      var minX = x - halfWidth;\n      var minY = y - halfWidth;\n      var maxX = x + width + halfWidth;\n      var maxY = y + height + halfWidth;\n      return {\n        x: minX,\n        y: minY,\n        minX: minX,\n        minY: minY,\n        maxX: maxX,\n        maxY: maxY,\n        width: width + lineWidth,\n        height: height + lineWidth\n      };\n    }\n    return {\n      x: 0,\n      y: 0,\n      minX: 0,\n      minY: 0,\n      maxX: 0,\n      maxY: 0,\n      width: 0,\n      height: 0\n    };\n  };\n  ShapeBase.prototype.isFill = function () {\n    var _a = this.attr(),\n      fill = _a.fill,\n      fillStyle = _a.fillStyle;\n    return (fill || fillStyle || this.isClipShape()) && this.canFill;\n  };\n  ShapeBase.prototype.isStroke = function () {\n    var _a = this.attr(),\n      stroke = _a.stroke,\n      strokeStyle = _a.strokeStyle;\n    return (stroke || strokeStyle) && this.canStroke;\n  };\n  ShapeBase.prototype.draw = function (context, targetAttrs) {\n    var el = this.get('el');\n    if (this.get('destroyed')) {\n      if (el) {\n        el.parentNode.removeChild(el);\n      }\n    } else {\n      if (!el) {\n        createDom(this);\n      }\n      setClip(this, context);\n      this.createPath(context, targetAttrs);\n      this.shadow(context, targetAttrs);\n      this.strokeAndFill(context, targetAttrs);\n      this.transform(targetAttrs);\n    }\n  };\n  /**\n   * @protected\n   * 绘制图形的路径\n   * @param {Defs} context 上下文\n   * @param {ShapeAttrs} targetAttrs 渲染的目标属性\n   */\n  ShapeBase.prototype.createPath = function (context, targetAttrs) {};\n  // stroke and fill\n  ShapeBase.prototype.strokeAndFill = function (context, targetAttrs) {\n    var attrs = targetAttrs || this.attr();\n    var fill = attrs.fill,\n      fillStyle = attrs.fillStyle,\n      stroke = attrs.stroke,\n      strokeStyle = attrs.strokeStyle,\n      fillOpacity = attrs.fillOpacity,\n      strokeOpacity = attrs.strokeOpacity,\n      lineWidth = attrs.lineWidth;\n    var el = this.get('el');\n    if (this.canFill) {\n      // 初次渲染和更新渲染的逻辑有所不同: 初次渲染值为空时，需要设置为 none，否则就会是黑色，而更新渲染则不需要\n      if (!targetAttrs) {\n        this._setColor(context, 'fill', fill || fillStyle);\n      } else if ('fill' in attrs) {\n        this._setColor(context, 'fill', fill);\n      } else if ('fillStyle' in attrs) {\n        // compatible with fillStyle\n        this._setColor(context, 'fill', fillStyle);\n      }\n      if (fillOpacity) {\n        el.setAttribute(SVG_ATTR_MAP['fillOpacity'], fillOpacity);\n      }\n    }\n    if (this.canStroke && lineWidth > 0) {\n      if (!targetAttrs) {\n        this._setColor(context, 'stroke', stroke || strokeStyle);\n      } else if ('stroke' in attrs) {\n        this._setColor(context, 'stroke', stroke);\n      } else if ('strokeStyle' in attrs) {\n        // compatible with strokeStyle\n        this._setColor(context, 'stroke', strokeStyle);\n      }\n      if (strokeOpacity) {\n        el.setAttribute(SVG_ATTR_MAP['strokeOpacity'], strokeOpacity);\n      }\n      if (lineWidth) {\n        el.setAttribute(SVG_ATTR_MAP['lineWidth'], lineWidth);\n      }\n    }\n  };\n  ShapeBase.prototype._setColor = function (context, attr, value) {\n    var el = this.get('el');\n    if (!value) {\n      // need to set `none` to avoid default value\n      el.setAttribute(SVG_ATTR_MAP[attr], 'none');\n      return;\n    }\n    value = value.trim();\n    if (/^[r,R,L,l]{1}[\\s]*\\(/.test(value)) {\n      var id = context.find('gradient', value);\n      if (!id) {\n        id = context.addGradient(value);\n      }\n      el.setAttribute(SVG_ATTR_MAP[attr], \"url(#\" + id + \")\");\n    } else if (/^[p,P]{1}[\\s]*\\(/.test(value)) {\n      var id = context.find('pattern', value);\n      if (!id) {\n        id = context.addPattern(value);\n      }\n      el.setAttribute(SVG_ATTR_MAP[attr], \"url(#\" + id + \")\");\n    } else {\n      el.setAttribute(SVG_ATTR_MAP[attr], value);\n    }\n  };\n  ShapeBase.prototype.shadow = function (context, targetAttrs) {\n    var attrs = this.attr();\n    var _a = targetAttrs || attrs,\n      shadowOffsetX = _a.shadowOffsetX,\n      shadowOffsetY = _a.shadowOffsetY,\n      shadowBlur = _a.shadowBlur,\n      shadowColor = _a.shadowColor;\n    if (shadowOffsetX || shadowOffsetY || shadowBlur || shadowColor) {\n      setShadow(this, context);\n    }\n  };\n  ShapeBase.prototype.transform = function (targetAttrs) {\n    var attrs = this.attr();\n    var matrix = (targetAttrs || attrs).matrix;\n    if (matrix) {\n      setTransform(this);\n    }\n  };\n  ShapeBase.prototype.isInShape = function (refX, refY) {\n    return this.isPointInPath(refX, refY);\n  };\n  ShapeBase.prototype.isPointInPath = function (refX, refY) {\n    var el = this.get('el');\n    var canvas = this.get('canvas');\n    var bbox = canvas.get('el').getBoundingClientRect();\n    var clientX = refX + bbox.left;\n    var clientY = refY + bbox.top;\n    var element = document.elementFromPoint(clientX, clientY);\n    if (element && element.isEqualNode(el)) {\n      return true;\n    }\n    return false;\n  };\n  /**\n   * 获取线拾取的宽度\n   * @returns {number} 线的拾取宽度\n   */\n  ShapeBase.prototype.getHitLineWidth = function () {\n    var _a = this.attrs,\n      lineWidth = _a.lineWidth,\n      lineAppendWidth = _a.lineAppendWidth;\n    if (this.isStroke()) {\n      return lineWidth + lineAppendWidth;\n    }\n    return 0;\n  };\n  return ShapeBase;\n}(AbstractShape);\nexport default ShapeBase;","map":{"version":3,"sources":["../../src/shape/base.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __assign, __extends } from \"tslib\";\nimport { AbstractShape } from '@antv/g-base';\nimport { setShadow, setTransform, setClip } from '../util/svg';\nimport { createDom } from '../util/dom';\nimport { refreshElement } from '../util/draw';\nimport { SVG_ATTR_MAP } from '../constant';\nimport * as Shape from './index';\nimport Group from '../group';\nimport { getBBoxMethod } from '@antv/g-base';\nvar ShapeBase = /** @class */ (function (_super) {\n    __extends(ShapeBase, _super);\n    function ShapeBase() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.type = 'svg';\n        _this.canFill = false;\n        _this.canStroke = false;\n        return _this;\n    }\n    ShapeBase.prototype.getDefaultAttrs = function () {\n        var attrs = _super.prototype.getDefaultAttrs.call(this);\n        // 设置默认值\n        return __assign(__assign({}, attrs), { lineWidth: 1, lineAppendWidth: 0, strokeOpacity: 1, fillOpacity: 1 });\n    };\n    // 覆盖基类的 afterAttrsChange 方法\n    ShapeBase.prototype.afterAttrsChange = function (targetAttrs) {\n        _super.prototype.afterAttrsChange.call(this, targetAttrs);\n        var canvas = this.get('canvas');\n        // 只有挂载到画布下，才对元素进行实际渲染\n        if (canvas && canvas.get('autoDraw')) {\n            var context = canvas.get('context');\n            this.draw(context, targetAttrs);\n        }\n    };\n    ShapeBase.prototype.getShapeBase = function () {\n        return Shape;\n    };\n    ShapeBase.prototype.getGroupBase = function () {\n        return Group;\n    };\n    /**\n     * 一些方法调用会引起画布变化\n     * @param {ChangeType} changeType 改变的类型\n     */\n    ShapeBase.prototype.onCanvasChange = function (changeType) {\n        refreshElement(this, changeType);\n    };\n    ShapeBase.prototype.calculateBBox = function () {\n        var el = this.get('el');\n        var bbox = null;\n        // 包围盒计算依赖于绘制，如果还没有生成对应的 Dom 元素，则包围盒的长宽均为 0\n        if (el) {\n            bbox = el.getBBox();\n        }\n        else {\n            var bboxMethod = getBBoxMethod(this.get('type'));\n            if (bboxMethod) {\n                bbox = bboxMethod(this);\n            }\n        }\n        if (bbox) {\n            var x = bbox.x, y = bbox.y, width = bbox.width, height = bbox.height;\n            var lineWidth = this.getHitLineWidth();\n            var halfWidth = lineWidth / 2;\n            var minX = x - halfWidth;\n            var minY = y - halfWidth;\n            var maxX = x + width + halfWidth;\n            var maxY = y + height + halfWidth;\n            return {\n                x: minX,\n                y: minY,\n                minX: minX,\n                minY: minY,\n                maxX: maxX,\n                maxY: maxY,\n                width: width + lineWidth,\n                height: height + lineWidth,\n            };\n        }\n        return {\n            x: 0,\n            y: 0,\n            minX: 0,\n            minY: 0,\n            maxX: 0,\n            maxY: 0,\n            width: 0,\n            height: 0,\n        };\n    };\n    ShapeBase.prototype.isFill = function () {\n        var _a = this.attr(), fill = _a.fill, fillStyle = _a.fillStyle;\n        return (fill || fillStyle || this.isClipShape()) && this.canFill;\n    };\n    ShapeBase.prototype.isStroke = function () {\n        var _a = this.attr(), stroke = _a.stroke, strokeStyle = _a.strokeStyle;\n        return (stroke || strokeStyle) && this.canStroke;\n    };\n    ShapeBase.prototype.draw = function (context, targetAttrs) {\n        var el = this.get('el');\n        if (this.get('destroyed')) {\n            if (el) {\n                el.parentNode.removeChild(el);\n            }\n        }\n        else {\n            if (!el) {\n                createDom(this);\n            }\n            setClip(this, context);\n            this.createPath(context, targetAttrs);\n            this.shadow(context, targetAttrs);\n            this.strokeAndFill(context, targetAttrs);\n            this.transform(targetAttrs);\n        }\n    };\n    /**\n     * @protected\n     * 绘制图形的路径\n     * @param {Defs} context 上下文\n     * @param {ShapeAttrs} targetAttrs 渲染的目标属性\n     */\n    ShapeBase.prototype.createPath = function (context, targetAttrs) { };\n    // stroke and fill\n    ShapeBase.prototype.strokeAndFill = function (context, targetAttrs) {\n        var attrs = targetAttrs || this.attr();\n        var fill = attrs.fill, fillStyle = attrs.fillStyle, stroke = attrs.stroke, strokeStyle = attrs.strokeStyle, fillOpacity = attrs.fillOpacity, strokeOpacity = attrs.strokeOpacity, lineWidth = attrs.lineWidth;\n        var el = this.get('el');\n        if (this.canFill) {\n            // 初次渲染和更新渲染的逻辑有所不同: 初次渲染值为空时，需要设置为 none，否则就会是黑色，而更新渲染则不需要\n            if (!targetAttrs) {\n                this._setColor(context, 'fill', fill || fillStyle);\n            }\n            else if ('fill' in attrs) {\n                this._setColor(context, 'fill', fill);\n            }\n            else if ('fillStyle' in attrs) {\n                // compatible with fillStyle\n                this._setColor(context, 'fill', fillStyle);\n            }\n            if (fillOpacity) {\n                el.setAttribute(SVG_ATTR_MAP['fillOpacity'], fillOpacity);\n            }\n        }\n        if (this.canStroke && lineWidth > 0) {\n            if (!targetAttrs) {\n                this._setColor(context, 'stroke', stroke || strokeStyle);\n            }\n            else if ('stroke' in attrs) {\n                this._setColor(context, 'stroke', stroke);\n            }\n            else if ('strokeStyle' in attrs) {\n                // compatible with strokeStyle\n                this._setColor(context, 'stroke', strokeStyle);\n            }\n            if (strokeOpacity) {\n                el.setAttribute(SVG_ATTR_MAP['strokeOpacity'], strokeOpacity);\n            }\n            if (lineWidth) {\n                el.setAttribute(SVG_ATTR_MAP['lineWidth'], lineWidth);\n            }\n        }\n    };\n    ShapeBase.prototype._setColor = function (context, attr, value) {\n        var el = this.get('el');\n        if (!value) {\n            // need to set `none` to avoid default value\n            el.setAttribute(SVG_ATTR_MAP[attr], 'none');\n            return;\n        }\n        value = value.trim();\n        if (/^[r,R,L,l]{1}[\\s]*\\(/.test(value)) {\n            var id = context.find('gradient', value);\n            if (!id) {\n                id = context.addGradient(value);\n            }\n            el.setAttribute(SVG_ATTR_MAP[attr], \"url(#\" + id + \")\");\n        }\n        else if (/^[p,P]{1}[\\s]*\\(/.test(value)) {\n            var id = context.find('pattern', value);\n            if (!id) {\n                id = context.addPattern(value);\n            }\n            el.setAttribute(SVG_ATTR_MAP[attr], \"url(#\" + id + \")\");\n        }\n        else {\n            el.setAttribute(SVG_ATTR_MAP[attr], value);\n        }\n    };\n    ShapeBase.prototype.shadow = function (context, targetAttrs) {\n        var attrs = this.attr();\n        var _a = targetAttrs || attrs, shadowOffsetX = _a.shadowOffsetX, shadowOffsetY = _a.shadowOffsetY, shadowBlur = _a.shadowBlur, shadowColor = _a.shadowColor;\n        if (shadowOffsetX || shadowOffsetY || shadowBlur || shadowColor) {\n            setShadow(this, context);\n        }\n    };\n    ShapeBase.prototype.transform = function (targetAttrs) {\n        var attrs = this.attr();\n        var matrix = (targetAttrs || attrs).matrix;\n        if (matrix) {\n            setTransform(this);\n        }\n    };\n    ShapeBase.prototype.isInShape = function (refX, refY) {\n        return this.isPointInPath(refX, refY);\n    };\n    ShapeBase.prototype.isPointInPath = function (refX, refY) {\n        var el = this.get('el');\n        var canvas = this.get('canvas');\n        var bbox = canvas.get('el').getBoundingClientRect();\n        var clientX = refX + bbox.left;\n        var clientY = refY + bbox.top;\n        var element = document.elementFromPoint(clientX, clientY);\n        if (element && element.isEqualNode(el)) {\n            return true;\n        }\n        return false;\n    };\n    /**\n     * 获取线拾取的宽度\n     * @returns {number} 线的拾取宽度\n     */\n    ShapeBase.prototype.getHitLineWidth = function () {\n        var _a = this.attrs, lineWidth = _a.lineWidth, lineAppendWidth = _a.lineAppendWidth;\n        if (this.isStroke()) {\n            return lineWidth + lineAppendWidth;\n        }\n        return 0;\n    };\n    return ShapeBase;\n}(AbstractShape));\nexport default ShapeBase;\n//# sourceMappingURL=base.js.map"]},"metadata":{},"sourceType":"module"}