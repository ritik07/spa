{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { each, get, isArray, map, isNumber, isString } from '@antv/util';\nimport { getDistanceToCenter } from '../../util/coordinate';\nimport { getAngleByPoint } from '../../util/coordinate';\nimport GeometryLabel from './base';\nvar HALF_PI = Math.PI / 2;\n/**\n * 极坐标下的图形 label\n */\nvar PolarLabel = /** @class */function (_super) {\n  __extends(PolarLabel, _super);\n  function PolarLabel() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * @override\n   * @desc 获取 label offset\n   * polar & theta coordinate support「string」type, should transform to 「number」\n   */\n  PolarLabel.prototype.getLabelOffset = function (offset) {\n    var coordinate = this.getCoordinate();\n    var actualOffset = 0;\n    if (isNumber(offset)) {\n      actualOffset = offset;\n    } else if (isString(offset) && offset.indexOf('%') !== -1) {\n      var r = coordinate.getRadius();\n      if (coordinate.innerRadius > 0) {\n        r = r * (1 - coordinate.innerRadius);\n      }\n      actualOffset = parseFloat(offset) * 0.01 * r;\n    }\n    return actualOffset;\n  };\n  /**\n   * @override\n   * 获取 labelItems, 增加切片 percent\n   * @param mapppingArray\n   */\n  PolarLabel.prototype.getLabelItems = function (mapppingArray) {\n    var items = _super.prototype.getLabelItems.call(this, mapppingArray);\n    var yScale = this.geometry.getYScale();\n    return map(items, function (item) {\n      if (item && yScale) {\n        var percent = yScale.scale(get(item.data, yScale.field));\n        return __assign(__assign({}, item), {\n          percent: percent\n        });\n      }\n      return item;\n    });\n  };\n  /**\n   * @override\n   * 获取文本的对齐方式\n   * @param point\n   */\n  PolarLabel.prototype.getLabelAlign = function (point) {\n    var coordinate = this.getCoordinate();\n    var align;\n    if (point.labelEmit) {\n      align = point.angle <= Math.PI / 2 && point.angle >= -Math.PI / 2 ? 'left' : 'right';\n    } else if (!coordinate.isTransposed) {\n      align = 'center';\n    } else {\n      var center = coordinate.getCenter();\n      var offset = point.offset;\n      if (Math.abs(point.x - center.x) < 1) {\n        align = 'center';\n      } else if (point.angle > Math.PI || point.angle <= 0) {\n        align = offset > 0 ? 'left' : 'right';\n      } else {\n        align = offset > 0 ? 'right' : 'left';\n      }\n    }\n    return align;\n  };\n  /**\n   * @override\n   * 获取 label 的位置\n   * @param labelCfg\n   * @param mappingData\n   * @param index\n   */\n  PolarLabel.prototype.getLabelPoint = function (labelCfg, mappingData, index) {\n    var factor = 1;\n    var arcPoint;\n    var content = labelCfg.content[index];\n    if (this.isToMiddle(mappingData)) {\n      arcPoint = this.getMiddlePoint(mappingData.points);\n    } else {\n      if (labelCfg.content.length === 1 && index === 0) {\n        index = 1;\n      } else if (index === 0) {\n        factor = -1;\n      }\n      arcPoint = this.getArcPoint(mappingData, index);\n    }\n    var offset = labelCfg.offset * factor;\n    var middleAngle = this.getPointAngle(arcPoint);\n    var isLabelEmit = labelCfg.labelEmit;\n    var labelPositionCfg = this.getCirclePoint(middleAngle, offset, arcPoint, isLabelEmit);\n    if (labelPositionCfg.r === 0) {\n      // 如果文本位置位于圆心，则不展示\n      labelPositionCfg.content = '';\n    } else {\n      labelPositionCfg.content = content;\n      labelPositionCfg.angle = middleAngle;\n      labelPositionCfg.color = mappingData.color;\n    }\n    labelPositionCfg.rotate = labelCfg.autoRotate ? this.getLabelRotate(middleAngle, offset, isLabelEmit) : labelCfg.rotate;\n    labelPositionCfg.start = {\n      x: arcPoint.x,\n      y: arcPoint.y\n    };\n    return labelPositionCfg;\n  };\n  /**\n   * 获取圆弧的位置\n   */\n  PolarLabel.prototype.getArcPoint = function (mappingData, index) {\n    if (index === void 0) {\n      index = 0;\n    }\n    if (!isArray(mappingData.x) && !isArray(mappingData.y)) {\n      return {\n        x: mappingData.x,\n        y: mappingData.y\n      };\n    }\n    return {\n      x: isArray(mappingData.x) ? mappingData.x[index] : mappingData.x,\n      y: isArray(mappingData.y) ? mappingData.y[index] : mappingData.y\n    };\n  };\n  /**\n   * 计算坐标线点在极坐标系下角度\n   * @param point\n   */\n  PolarLabel.prototype.getPointAngle = function (point) {\n    return getAngleByPoint(this.getCoordinate(), point);\n  };\n  /**\n   * 获取坐标点与圆心形成的圆的位置信息\n   * @param angle\n   * @param offset\n   * @param point\n   * @param isLabelEmit\n   */\n  PolarLabel.prototype.getCirclePoint = function (angle, offset, point, isLabelEmit) {\n    var coordinate = this.getCoordinate();\n    var center = coordinate.getCenter();\n    var r = getDistanceToCenter(coordinate, point);\n    if (r === 0) {\n      return __assign(__assign({}, center), {\n        r: r\n      });\n    }\n    var labelAngle = angle;\n    if (coordinate.isTransposed && r > offset && !isLabelEmit) {\n      var appendAngle = Math.asin(offset / (2 * r));\n      labelAngle = angle + appendAngle * 2;\n    } else {\n      r = r + offset;\n    }\n    return {\n      x: center.x + r * Math.cos(labelAngle),\n      y: center.y + r * Math.sin(labelAngle),\n      r: r\n    };\n  };\n  /**\n   * 获取 label 的旋转角度\n   * @param angle\n   * @param offset\n   * @param isLabelEmit\n   */\n  PolarLabel.prototype.getLabelRotate = function (angle, offset, isLabelEmit) {\n    var rotate = angle + HALF_PI;\n    if (isLabelEmit) {\n      rotate -= HALF_PI;\n    }\n    if (rotate) {\n      if (rotate > HALF_PI) {\n        rotate = rotate - Math.PI;\n      } else if (rotate < -HALF_PI) {\n        rotate = rotate + Math.PI;\n      }\n    }\n    return rotate;\n  };\n  // 获取中心的位置\n  PolarLabel.prototype.getMiddlePoint = function (points) {\n    var coordinate = this.getCoordinate();\n    var count = points.length;\n    var middlePoint = {\n      x: 0,\n      y: 0\n    };\n    each(points, function (point) {\n      middlePoint.x += point.x;\n      middlePoint.y += point.y;\n    });\n    middlePoint.x /= count;\n    middlePoint.y /= count;\n    middlePoint = coordinate.convert(middlePoint);\n    return middlePoint;\n  };\n  // 是否居中\n  PolarLabel.prototype.isToMiddle = function (mappingData) {\n    return mappingData.x.length > 2;\n  };\n  return PolarLabel;\n}(GeometryLabel);\nexport default PolarLabel;","map":{"version":3,"sources":["../../../src/geometry/label/polar.ts"],"names":[],"mappings":";AAAA,SAAS,IAAI,EAAE,GAAG,EAAE,OAAO,EAAE,GAAG,EAAE,QAAQ,EAAE,QAAQ,QAAQ,YAAY;AAExE,SAAS,mBAAmB,QAAQ,uBAAuB;AAC3D,SAAS,eAAe,QAAQ,uBAAuB;AACvD,OAAO,aAAa,MAAM,QAAQ;AAGlC,IAAM,OAAO,GAAG,IAAI,CAAC,EAAE,GAAG,CAAC;AAE3B;;AAEG;AACH,IAAA,UAAA,GAAA,aAAA,UAAA,MAAA,EAAA;EAAwC,SAAA,CAAA,UAAA,EAAA,MAAA,CAAA;EAAxC,SAAA,UAAA,GAAA;;EAoNA;EAnNE;;;;AAIG;EACO,UAAA,CAAA,SAAA,CAAA,cAAc,GAAxB,UAAyB,MAAuB,EAAA;IAC9C,IAAM,UAAU,GAAG,IAAI,CAAC,aAAa,EAAE;IACvC,IAAI,YAAY,GAAG,CAAC;IACpB,IAAI,QAAQ,CAAC,MAAM,CAAC,EAAE;MACpB,YAAY,GAAG,MAAM;KACtB,MAAM,IAAI,QAAQ,CAAC,MAAM,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE;MACzD,IAAI,CAAC,GAAG,UAAU,CAAC,SAAS,EAAE;MAC9B,IAAI,UAAU,CAAC,WAAW,GAAG,CAAC,EAAE;QAC9B,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,UAAU,CAAC,WAAW,CAAC;MACrC;MACD,YAAY,GAAG,UAAU,CAAC,MAAM,CAAC,GAAG,IAAI,GAAG,CAAC;IAC7C;IAED,OAAO,YAAY;EACrB,CAAC;EAED;;;;AAIG;EACI,UAAA,CAAA,SAAA,CAAA,aAAa,GAApB,UAAqB,aAA6B,EAAA;IAChD,IAAM,KAAK,GAAG,MAAA,CAAA,SAAA,CAAM,aAAa,CAAA,IAAA,CAAA,IAAA,EAAC,aAAa,CAAC;IAChD,IAAM,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE;IAExC,OAAO,GAAG,CAAC,KAAK,EAAE,UAAC,IAAI,EAAA;MACrB,IAAI,IAAI,IAAI,MAAM,EAAE;QAClB,IAAM,OAAO,GAAG,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE,MAAM,CAAC,KAAK,CAAC,CAAC;QAC1D,OAAA,QAAA,CAAA,QAAA,CAAA,CAAA,CAAA,EAAY,IAAI,CAAA,EAAA;UAAE,OAAO,EAAA;QAAA,CAAA,CAAA;MAC1B;MACD,OAAO,IAAI;IACb,CAAC,CAAC;EACJ,CAAC;EACD;;;;AAIG;EACO,UAAA,CAAA,SAAA,CAAA,aAAa,GAAvB,UAAwB,KAAgB,EAAA;IACtC,IAAM,UAAU,GAAG,IAAI,CAAC,aAAa,EAAE;IACvC,IAAI,KAAK;IACT,IAAI,KAAK,CAAC,SAAS,EAAE;MACnB,KAAK,GAAG,KAAK,CAAC,KAAK,IAAI,IAAI,CAAC,EAAE,GAAG,CAAC,IAAI,KAAK,CAAC,KAAK,IAAI,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,GAAG,MAAM,GAAG,OAAO;KACrF,MAAM,IAAI,CAAC,UAAU,CAAC,YAAY,EAAE;MACnC,KAAK,GAAG,QAAQ;KACjB,MAAM;MACL,IAAM,MAAM,GAAG,UAAU,CAAC,SAAS,EAAE;MACrC,IAAM,MAAM,GAAG,KAAK,CAAC,MAAM;MAC3B,IAAI,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE;QACpC,KAAK,GAAG,QAAQ;OACjB,MAAM,IAAI,KAAK,CAAC,KAAK,GAAG,IAAI,CAAC,EAAE,IAAI,KAAK,CAAC,KAAK,IAAI,CAAC,EAAE;QACpD,KAAK,GAAG,MAAM,GAAG,CAAC,GAAG,MAAM,GAAG,OAAO;OACtC,MAAM;QACL,KAAK,GAAG,MAAM,GAAG,CAAC,GAAG,OAAO,GAAG,MAAM;MACtC;IACF;IACD,OAAO,KAAK;EACd,CAAC;EAED;;;;;;AAMG;EACO,UAAA,CAAA,SAAA,CAAA,aAAa,GAAvB,UAAwB,QAAkB,EAAE,WAAyB,EAAE,KAAa,EAAA;IAClF,IAAI,MAAM,GAAG,CAAC;IACd,IAAI,QAAQ;IACZ,IAAM,OAAO,GAAG,QAAQ,CAAC,OAAO,CAAC,KAAK,CAAC;IACvC,IAAI,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,EAAE;MAChC,QAAQ,GAAG,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,MAAiB,CAAC;KAC9D,MAAM;MACL,IAAI,QAAQ,CAAC,OAAO,CAAC,MAAM,KAAK,CAAC,IAAI,KAAK,KAAK,CAAC,EAAE;QAChD,KAAK,GAAG,CAAC;OACV,MAAM,IAAI,KAAK,KAAK,CAAC,EAAE;QACtB,MAAM,GAAG,CAAC,CAAC;MACZ;MACD,QAAQ,GAAG,IAAI,CAAC,WAAW,CAAC,WAAW,EAAE,KAAK,CAAC;IAChD;IAED,IAAM,MAAM,GAAG,QAAQ,CAAC,MAAM,GAAG,MAAM;IACvC,IAAM,WAAW,GAAG,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC;IAChD,IAAM,WAAW,GAAG,QAAQ,CAAC,SAAS;IACtC,IAAM,gBAAgB,GAA6B,IAAI,CAAC,cAAc,CAAC,WAAW,EAAE,MAAM,EAAE,QAAQ,EAAE,WAAW,CAAC;IAClH,IAAI,gBAAgB,CAAC,CAAC,KAAK,CAAC,EAAE;MAC5B;MACA,gBAAgB,CAAC,OAAO,GAAG,EAAE;KAC9B,MAAM;MACL,gBAAgB,CAAC,OAAO,GAAG,OAAO;MAClC,gBAAgB,CAAC,KAAK,GAAG,WAAW;MACpC,gBAAgB,CAAC,KAAK,GAAG,WAAW,CAAC,KAAK;IAC3C;IAED,gBAAgB,CAAC,MAAM,GAAG,QAAQ,CAAC,UAAU,GACzC,IAAI,CAAC,cAAc,CAAC,WAAW,EAAE,MAAM,EAAE,WAAW,CAAC,GACrD,QAAQ,CAAC,MAAM;IACnB,gBAAgB,CAAC,KAAK,GAAG;MACvB,CAAC,EAAE,QAAQ,CAAC,CAAC;MACb,CAAC,EAAE,QAAQ,CAAC;KACb;IACD,OAAO,gBAAgB;EACzB,CAAC;EAED;;AAEG;EACO,UAAA,CAAA,SAAA,CAAA,WAAW,GAArB,UAAsB,WAAyB,EAAE,KAAiB,EAAA;IAAjB,IAAA,KAAA,KAAA,KAAA,CAAA,EAAA;MAAA,KAAA,GAAA,CAAiB;IAAA;IAChE,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC,CAAC,EAAE;MACtD,OAAO;QACL,CAAC,EAAE,WAAW,CAAC,CAAC;QAChB,CAAC,EAAE,WAAW,CAAC;OAChB;IACF;IAED,OAAO;MACL,CAAC,EAAE,OAAO,CAAC,WAAW,CAAC,CAAC,CAAC,GAAG,WAAW,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,WAAW,CAAC,CAAC;MAChE,CAAC,EAAE,OAAO,CAAC,WAAW,CAAC,CAAC,CAAC,GAAG,WAAW,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,WAAW,CAAC;KAChE;EACH,CAAC;EAED;;;AAGG;EACO,UAAA,CAAA,SAAA,CAAA,aAAa,GAAvB,UAAwB,KAAY,EAAA;IAClC,OAAO,eAAe,CAAC,IAAI,CAAC,aAAa,EAAE,EAAE,KAAK,CAAC;EACrD,CAAC;EAED;;;;;;AAMG;EACO,UAAA,CAAA,SAAA,CAAA,cAAc,GAAxB,UAAyB,KAAa,EAAE,MAAc,EAAE,KAAY,EAAE,WAAoB,EAAA;IACxF,IAAM,UAAU,GAAG,IAAI,CAAC,aAAa,EAAE;IACvC,IAAM,MAAM,GAAG,UAAU,CAAC,SAAS,EAAE;IACrC,IAAI,CAAC,GAAG,mBAAmB,CAAC,UAAU,EAAE,KAAK,CAAC;IAC9C,IAAI,CAAC,KAAK,CAAC,EAAE;MACX,OAAA,QAAA,CAAA,QAAA,CAAA,CAAA,CAAA,EACK,MAAM,CAAA,EAAA;QACT,CAAC,EAAA;MAAA,CAAA,CAAA;IAEJ;IAED,IAAI,UAAU,GAAG,KAAK;IACtB,IAAI,UAAU,CAAC,YAAY,IAAI,CAAC,GAAG,MAAM,IAAI,CAAC,WAAW,EAAE;MACzD,IAAM,WAAW,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;MAC/C,UAAU,GAAG,KAAK,GAAG,WAAW,GAAG,CAAC;KACrC,MAAM;MACL,CAAC,GAAG,CAAC,GAAG,MAAM;IACf;IAED,OAAO;MACL,CAAC,EAAE,MAAM,CAAC,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC;MACtC,CAAC,EAAE,MAAM,CAAC,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC;MACtC,CAAC,EAAA;KACF;EACH,CAAC;EAED;;;;;AAKG;EACO,UAAA,CAAA,SAAA,CAAA,cAAc,GAAxB,UAAyB,KAAa,EAAE,MAAc,EAAE,WAAoB,EAAA;IAC1E,IAAI,MAAM,GAAG,KAAK,GAAG,OAAO;IAC5B,IAAI,WAAW,EAAE;MACf,MAAM,IAAI,OAAO;IAClB;IACD,IAAI,MAAM,EAAE;MACV,IAAI,MAAM,GAAG,OAAO,EAAE;QACpB,MAAM,GAAG,MAAM,GAAG,IAAI,CAAC,EAAE;OAC1B,MAAM,IAAI,MAAM,GAAG,CAAC,OAAO,EAAE;QAC5B,MAAM,GAAG,MAAM,GAAG,IAAI,CAAC,EAAE;MAC1B;IACF;IACD,OAAO,MAAM;EACf,CAAC;EAED;EACQ,UAAA,CAAA,SAAA,CAAA,cAAc,GAAtB,UAAuB,MAAe,EAAA;IACpC,IAAM,UAAU,GAAG,IAAI,CAAC,aAAa,EAAE;IACvC,IAAM,KAAK,GAAG,MAAM,CAAC,MAAM;IAC3B,IAAI,WAAW,GAAG;MAChB,CAAC,EAAE,CAAC;MACJ,CAAC,EAAE;KACJ;IACD,IAAI,CAAC,MAAM,EAAE,UAAC,KAAY,EAAA;MACxB,WAAW,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC;MACxB,WAAW,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC;IAC1B,CAAC,CAAC;IACF,WAAW,CAAC,CAAC,IAAI,KAAK;IACtB,WAAW,CAAC,CAAC,IAAI,KAAK;IAEtB,WAAW,GAAG,UAAU,CAAC,OAAO,CAAC,WAAW,CAAC;IAC7C,OAAO,WAAW;EACpB,CAAC;EAED;EACQ,UAAA,CAAA,SAAA,CAAA,UAAU,GAAlB,UAAmB,WAAyB,EAAA;IAC1C,OAAQ,WAAW,CAAC,CAAc,CAAC,MAAM,GAAG,CAAC;EAC/C,CAAC;EACH,OAAA,UAAC;AAAD,CAAC,CApNuC,aAAa,CAAA","sourcesContent":["import { each, get, isArray, map, isNumber, isString } from '@antv/util';\nimport { MappingDatum, Point } from '../../interface';\nimport { getDistanceToCenter } from '../../util/coordinate';\nimport { getAngleByPoint } from '../../util/coordinate';\nimport GeometryLabel from './base';\nimport { LabelCfg, LabelItem, PolarLabelItem, LabelPointCfg, Writeable } from './interface';\n\nconst HALF_PI = Math.PI / 2;\n\n/**\n * 极坐标下的图形 label\n */\nexport default class PolarLabel extends GeometryLabel {\n  /**\n   * @override\n   * @desc 获取 label offset\n   * polar & theta coordinate support「string」type, should transform to 「number」\n   */\n  protected getLabelOffset(offset: number | string): number {\n    const coordinate = this.getCoordinate();\n    let actualOffset = 0;\n    if (isNumber(offset)) {\n      actualOffset = offset;\n    } else if (isString(offset) && offset.indexOf('%') !== -1) {\n      let r = coordinate.getRadius();\n      if (coordinate.innerRadius > 0) {\n        r = r * (1 - coordinate.innerRadius);\n      }\n      actualOffset = parseFloat(offset) * 0.01 * r;\n    }\n\n    return actualOffset;\n  }\n\n  /**\n   * @override\n   * 获取 labelItems, 增加切片 percent\n   * @param mapppingArray\n   */\n  public getLabelItems(mapppingArray: MappingDatum[]): PolarLabelItem[] {\n    const items = super.getLabelItems(mapppingArray);\n    const yScale = this.geometry.getYScale();\n\n    return map(items, (item) => {\n      if (item && yScale) {\n        const percent = yScale.scale(get(item.data, yScale.field));\n        return { ...item, percent };\n      }\n      return item;\n    });\n  }\n  /**\n   * @override\n   * 获取文本的对齐方式\n   * @param point\n   */\n  protected getLabelAlign(point: LabelItem) {\n    const coordinate = this.getCoordinate();\n    let align;\n    if (point.labelEmit) {\n      align = point.angle <= Math.PI / 2 && point.angle >= -Math.PI / 2 ? 'left' : 'right';\n    } else if (!coordinate.isTransposed) {\n      align = 'center';\n    } else {\n      const center = coordinate.getCenter();\n      const offset = point.offset;\n      if (Math.abs(point.x - center.x) < 1) {\n        align = 'center';\n      } else if (point.angle > Math.PI || point.angle <= 0) {\n        align = offset > 0 ? 'left' : 'right';\n      } else {\n        align = offset > 0 ? 'right' : 'left';\n      }\n    }\n    return align;\n  }\n\n  /**\n   * @override\n   * 获取 label 的位置\n   * @param labelCfg\n   * @param mappingData\n   * @param index\n   */\n  protected getLabelPoint(labelCfg: LabelCfg, mappingData: MappingDatum, index: number): LabelPointCfg {\n    let factor = 1;\n    let arcPoint;\n    const content = labelCfg.content[index];\n    if (this.isToMiddle(mappingData)) {\n      arcPoint = this.getMiddlePoint(mappingData.points as Point[]);\n    } else {\n      if (labelCfg.content.length === 1 && index === 0) {\n        index = 1;\n      } else if (index === 0) {\n        factor = -1;\n      }\n      arcPoint = this.getArcPoint(mappingData, index);\n    }\n\n    const offset = labelCfg.offset * factor;\n    const middleAngle = this.getPointAngle(arcPoint);\n    const isLabelEmit = labelCfg.labelEmit;\n    const labelPositionCfg: Writeable<LabelPointCfg> = this.getCirclePoint(middleAngle, offset, arcPoint, isLabelEmit);\n    if (labelPositionCfg.r === 0) {\n      // 如果文本位置位于圆心，则不展示\n      labelPositionCfg.content = '';\n    } else {\n      labelPositionCfg.content = content;\n      labelPositionCfg.angle = middleAngle;\n      labelPositionCfg.color = mappingData.color;\n    }\n\n    labelPositionCfg.rotate = labelCfg.autoRotate\n      ? this.getLabelRotate(middleAngle, offset, isLabelEmit)\n      : labelCfg.rotate;\n    labelPositionCfg.start = {\n      x: arcPoint.x,\n      y: arcPoint.y,\n    };\n    return labelPositionCfg;\n  }\n\n  /**\n   * 获取圆弧的位置\n   */\n  protected getArcPoint(mappingData: MappingDatum, index: number = 0): Point {\n    if (!isArray(mappingData.x) && !isArray(mappingData.y)) {\n      return {\n        x: mappingData.x,\n        y: mappingData.y,\n      };\n    }\n\n    return {\n      x: isArray(mappingData.x) ? mappingData.x[index] : mappingData.x,\n      y: isArray(mappingData.y) ? mappingData.y[index] : mappingData.y,\n    };\n  }\n\n  /**\n   * 计算坐标线点在极坐标系下角度\n   * @param point\n   */\n  protected getPointAngle(point: Point): number {\n    return getAngleByPoint(this.getCoordinate(), point);\n  }\n\n  /**\n   * 获取坐标点与圆心形成的圆的位置信息\n   * @param angle\n   * @param offset\n   * @param point\n   * @param isLabelEmit\n   */\n  protected getCirclePoint(angle: number, offset: number, point: Point, isLabelEmit: boolean) {\n    const coordinate = this.getCoordinate();\n    const center = coordinate.getCenter();\n    let r = getDistanceToCenter(coordinate, point);\n    if (r === 0) {\n      return {\n        ...center,\n        r,\n      };\n    }\n\n    let labelAngle = angle;\n    if (coordinate.isTransposed && r > offset && !isLabelEmit) {\n      const appendAngle = Math.asin(offset / (2 * r));\n      labelAngle = angle + appendAngle * 2;\n    } else {\n      r = r + offset;\n    }\n\n    return {\n      x: center.x + r * Math.cos(labelAngle),\n      y: center.y + r * Math.sin(labelAngle),\n      r,\n    };\n  }\n\n  /**\n   * 获取 label 的旋转角度\n   * @param angle\n   * @param offset\n   * @param isLabelEmit\n   */\n  protected getLabelRotate(angle: number, offset: number, isLabelEmit: boolean) {\n    let rotate = angle + HALF_PI;\n    if (isLabelEmit) {\n      rotate -= HALF_PI;\n    }\n    if (rotate) {\n      if (rotate > HALF_PI) {\n        rotate = rotate - Math.PI;\n      } else if (rotate < -HALF_PI) {\n        rotate = rotate + Math.PI;\n      }\n    }\n    return rotate;\n  }\n\n  // 获取中心的位置\n  private getMiddlePoint(points: Point[]) {\n    const coordinate = this.getCoordinate();\n    const count = points.length;\n    let middlePoint = {\n      x: 0,\n      y: 0,\n    };\n    each(points, (point: Point) => {\n      middlePoint.x += point.x;\n      middlePoint.y += point.y;\n    });\n    middlePoint.x /= count;\n    middlePoint.y /= count;\n\n    middlePoint = coordinate.convert(middlePoint);\n    return middlePoint;\n  }\n\n  // 是否居中\n  private isToMiddle(mappingData: MappingDatum) {\n    return (mappingData.x as number[]).length > 2;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}