{"ast":null,"code":"import isPointInPolygon from './point-in-polygon';\nimport getLineIntersect from './get-line-intersect';\nimport { each } from '@antv/util';\nfunction parseToLines(points) {\n  var lines = [];\n  var count = points.length;\n  for (var i = 0; i < count - 1; i++) {\n    var point = points[i];\n    var next = points[i + 1];\n    lines.push({\n      from: {\n        x: point[0],\n        y: point[1]\n      },\n      to: {\n        x: next[0],\n        y: next[1]\n      }\n    });\n  }\n  if (lines.length > 1) {\n    var first = points[0];\n    var last = points[count - 1];\n    lines.push({\n      from: {\n        x: last[0],\n        y: last[1]\n      },\n      to: {\n        x: first[0],\n        y: first[1]\n      }\n    });\n  }\n  return lines;\n}\nfunction lineIntersectPolygon(lines, line) {\n  var isIntersect = false;\n  each(lines, function (l) {\n    if (getLineIntersect(l.from, l.to, line.from, line.to)) {\n      isIntersect = true;\n      return false;\n    }\n  });\n  return isIntersect;\n}\nfunction getBBox(points) {\n  var xArr = points.map(function (p) {\n    return p[0];\n  });\n  var yArr = points.map(function (p) {\n    return p[1];\n  });\n  return {\n    minX: Math.min.apply(null, xArr),\n    maxX: Math.max.apply(null, xArr),\n    minY: Math.min.apply(null, yArr),\n    maxY: Math.max.apply(null, yArr)\n  };\n}\nfunction intersectBBox(box1, box2) {\n  return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);\n}\nexport default function isPolygonsIntersect(points1, points2) {\n  // 空数组，或者一个点返回 false\n  if (points1.length < 2 || points2.length < 2) {\n    return false;\n  }\n  var bbox1 = getBBox(points1);\n  var bbox2 = getBBox(points2);\n  // 判定包围盒是否相交，比判定点是否在多边形内要快的多，可以筛选掉大多数情况\n  if (!intersectBBox(bbox1, bbox2)) {\n    return false;\n  }\n  var isIn = false;\n  // 判定点是否在多边形内部，一旦有一个点在另一个多边形内，则返回\n  each(points2, function (point) {\n    if (isPointInPolygon(points1, point[0], point[1])) {\n      isIn = true;\n      return false;\n    }\n  });\n  if (isIn) {\n    return true;\n  }\n  // 两个多边形都需要判定\n  each(points1, function (point) {\n    if (isPointInPolygon(points2, point[0], point[1])) {\n      isIn = true;\n      return false;\n    }\n  });\n  if (isIn) {\n    return true;\n  }\n  var lines1 = parseToLines(points1);\n  var lines2 = parseToLines(points2);\n  var isIntersect = false;\n  each(lines2, function (line) {\n    if (lineIntersectPolygon(lines1, line)) {\n      isIntersect = true;\n      return false;\n    }\n  });\n  return isIntersect;\n}","map":{"version":3,"sources":["../src/is-polygons-intersect.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import isPointInPolygon from './point-in-polygon';\nimport getLineIntersect from './get-line-intersect';\nimport { each } from '@antv/util';\nfunction parseToLines(points) {\n    var lines = [];\n    var count = points.length;\n    for (var i = 0; i < count - 1; i++) {\n        var point = points[i];\n        var next = points[i + 1];\n        lines.push({\n            from: {\n                x: point[0],\n                y: point[1]\n            },\n            to: {\n                x: next[0],\n                y: next[1]\n            }\n        });\n    }\n    if (lines.length > 1) {\n        var first = points[0];\n        var last = points[count - 1];\n        lines.push({\n            from: {\n                x: last[0],\n                y: last[1]\n            },\n            to: {\n                x: first[0],\n                y: first[1]\n            }\n        });\n    }\n    return lines;\n}\nfunction lineIntersectPolygon(lines, line) {\n    var isIntersect = false;\n    each(lines, function (l) {\n        if (getLineIntersect(l.from, l.to, line.from, line.to)) {\n            isIntersect = true;\n            return false;\n        }\n    });\n    return isIntersect;\n}\nfunction getBBox(points) {\n    var xArr = points.map(function (p) { return p[0]; });\n    var yArr = points.map(function (p) { return p[1]; });\n    return {\n        minX: Math.min.apply(null, xArr),\n        maxX: Math.max.apply(null, xArr),\n        minY: Math.min.apply(null, yArr),\n        maxY: Math.max.apply(null, yArr)\n    };\n}\nfunction intersectBBox(box1, box2) {\n    return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);\n}\nexport default function isPolygonsIntersect(points1, points2) {\n    // 空数组，或者一个点返回 false\n    if (points1.length < 2 || points2.length < 2) {\n        return false;\n    }\n    var bbox1 = getBBox(points1);\n    var bbox2 = getBBox(points2);\n    // 判定包围盒是否相交，比判定点是否在多边形内要快的多，可以筛选掉大多数情况\n    if (!intersectBBox(bbox1, bbox2)) {\n        return false;\n    }\n    var isIn = false;\n    // 判定点是否在多边形内部，一旦有一个点在另一个多边形内，则返回\n    each(points2, function (point) {\n        if (isPointInPolygon(points1, point[0], point[1])) {\n            isIn = true;\n            return false;\n        }\n    });\n    if (isIn) {\n        return true;\n    }\n    // 两个多边形都需要判定\n    each(points1, function (point) {\n        if (isPointInPolygon(points2, point[0], point[1])) {\n            isIn = true;\n            return false;\n        }\n    });\n    if (isIn) {\n        return true;\n    }\n    var lines1 = parseToLines(points1);\n    var lines2 = parseToLines(points2);\n    var isIntersect = false;\n    each(lines2, function (line) {\n        if (lineIntersectPolygon(lines1, line)) {\n            isIntersect = true;\n            return false;\n        }\n    });\n    return isIntersect;\n}\n//# sourceMappingURL=is-polygons-intersect.js.map"]},"metadata":{},"sourceType":"module"}