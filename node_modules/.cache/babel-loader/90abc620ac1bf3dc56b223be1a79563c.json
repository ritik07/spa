{"ast":null,"code":"import line from './line';\nimport { distance } from './util';\nfunction analyzePoints(points) {\n  // 计算每段的长度和总的长度\n  var totalLength = 0;\n  var segments = [];\n  for (var i = 0; i < points.length - 1; i++) {\n    var from = points[i];\n    var to = points[i + 1];\n    var length_1 = distance(from[0], from[1], to[0], to[1]);\n    var seg = {\n      from: from,\n      to: to,\n      length: length_1\n    };\n    segments.push(seg);\n    totalLength += length_1;\n  }\n  return {\n    segments: segments,\n    totalLength: totalLength\n  };\n}\nexport function lengthOfSegment(points) {\n  if (points.length < 2) {\n    return 0;\n  }\n  var totalLength = 0;\n  for (var i = 0; i < points.length - 1; i++) {\n    var from = points[i];\n    var to = points[i + 1];\n    totalLength += distance(from[0], from[1], to[0], to[1]);\n  }\n  return totalLength;\n}\n/**\n * 按照比例在数据片段中获取点\n * @param {array} points 点的集合\n * @param {number} t 百分比 0-1\n * @return {object} 点的坐标\n */\nexport function pointAtSegments(points, t) {\n  // 边界判断\n  if (t > 1 || t < 0 || points.length < 2) {\n    return null;\n  }\n  var _a = analyzePoints(points),\n    segments = _a.segments,\n    totalLength = _a.totalLength;\n  // 多个点有可能重合\n  if (totalLength === 0) {\n    return {\n      x: points[0][0],\n      y: points[0][1]\n    };\n  }\n  // 计算比例\n  var startRatio = 0;\n  var point = null;\n  for (var i = 0; i < segments.length; i++) {\n    var seg = segments[i];\n    var from = seg.from,\n      to = seg.to;\n    var currentRatio = seg.length / totalLength;\n    if (t >= startRatio && t <= startRatio + currentRatio) {\n      var localRatio = (t - startRatio) / currentRatio;\n      point = line.pointAt(from[0], from[1], to[0], to[1], localRatio);\n      break;\n    }\n    startRatio += currentRatio;\n  }\n  return point;\n}\n/**\n * 按照比例在数据片段中获取切线的角度\n * @param {array} points 点的集合\n * @param {number} t 百分比 0-1\n */\nexport function angleAtSegments(points, t) {\n  // 边界判断\n  if (t > 1 || t < 0 || points.length < 2) {\n    return 0;\n  }\n  var _a = analyzePoints(points),\n    segments = _a.segments,\n    totalLength = _a.totalLength;\n  // 计算比例\n  var startRatio = 0;\n  var angle = 0;\n  for (var i = 0; i < segments.length; i++) {\n    var seg = segments[i];\n    var from = seg.from,\n      to = seg.to;\n    var currentRatio = seg.length / totalLength;\n    if (t >= startRatio && t <= startRatio + currentRatio) {\n      angle = Math.atan2(to[1] - from[1], to[0] - from[0]);\n      break;\n    }\n    startRatio += currentRatio;\n  }\n  return angle;\n}\nexport function distanceAtSegment(points, x, y) {\n  var minDistance = Infinity;\n  for (var i = 0; i < points.length - 1; i++) {\n    var point = points[i];\n    var nextPoint = points[i + 1];\n    var distance_1 = line.pointDistance(point[0], point[1], nextPoint[0], nextPoint[1], x, y);\n    if (distance_1 < minDistance) {\n      minDistance = distance_1;\n    }\n  }\n  return minDistance;\n}","map":{"version":3,"sources":["../src/segments.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import line from './line';\nimport { distance } from './util';\nfunction analyzePoints(points) {\n    // 计算每段的长度和总的长度\n    var totalLength = 0;\n    var segments = [];\n    for (var i = 0; i < points.length - 1; i++) {\n        var from = points[i];\n        var to = points[i + 1];\n        var length_1 = distance(from[0], from[1], to[0], to[1]);\n        var seg = {\n            from: from,\n            to: to,\n            length: length_1,\n        };\n        segments.push(seg);\n        totalLength += length_1;\n    }\n    return { segments: segments, totalLength: totalLength };\n}\nexport function lengthOfSegment(points) {\n    if (points.length < 2) {\n        return 0;\n    }\n    var totalLength = 0;\n    for (var i = 0; i < points.length - 1; i++) {\n        var from = points[i];\n        var to = points[i + 1];\n        totalLength += distance(from[0], from[1], to[0], to[1]);\n    }\n    return totalLength;\n}\n/**\n * 按照比例在数据片段中获取点\n * @param {array} points 点的集合\n * @param {number} t 百分比 0-1\n * @return {object} 点的坐标\n */\nexport function pointAtSegments(points, t) {\n    // 边界判断\n    if (t > 1 || t < 0 || points.length < 2) {\n        return null;\n    }\n    var _a = analyzePoints(points), segments = _a.segments, totalLength = _a.totalLength;\n    // 多个点有可能重合\n    if (totalLength === 0) {\n        return {\n            x: points[0][0],\n            y: points[0][1],\n        };\n    }\n    // 计算比例\n    var startRatio = 0;\n    var point = null;\n    for (var i = 0; i < segments.length; i++) {\n        var seg = segments[i];\n        var from = seg.from, to = seg.to;\n        var currentRatio = seg.length / totalLength;\n        if (t >= startRatio && t <= startRatio + currentRatio) {\n            var localRatio = (t - startRatio) / currentRatio;\n            point = line.pointAt(from[0], from[1], to[0], to[1], localRatio);\n            break;\n        }\n        startRatio += currentRatio;\n    }\n    return point;\n}\n/**\n * 按照比例在数据片段中获取切线的角度\n * @param {array} points 点的集合\n * @param {number} t 百分比 0-1\n */\nexport function angleAtSegments(points, t) {\n    // 边界判断\n    if (t > 1 || t < 0 || points.length < 2) {\n        return 0;\n    }\n    var _a = analyzePoints(points), segments = _a.segments, totalLength = _a.totalLength;\n    // 计算比例\n    var startRatio = 0;\n    var angle = 0;\n    for (var i = 0; i < segments.length; i++) {\n        var seg = segments[i];\n        var from = seg.from, to = seg.to;\n        var currentRatio = seg.length / totalLength;\n        if (t >= startRatio && t <= startRatio + currentRatio) {\n            angle = Math.atan2(to[1] - from[1], to[0] - from[0]);\n            break;\n        }\n        startRatio += currentRatio;\n    }\n    return angle;\n}\nexport function distanceAtSegment(points, x, y) {\n    var minDistance = Infinity;\n    for (var i = 0; i < points.length - 1; i++) {\n        var point = points[i];\n        var nextPoint = points[i + 1];\n        var distance_1 = line.pointDistance(point[0], point[1], nextPoint[0], nextPoint[1], x, y);\n        if (distance_1 < minDistance) {\n            minDistance = distance_1;\n        }\n    }\n    return minDistance;\n}\n//# sourceMappingURL=segments.js.map"]},"metadata":{},"sourceType":"module"}