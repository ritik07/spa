{"ast":null,"code":"import { distance } from './util';\nvar EPSILON = 0.0001;\n/**\n * 使用牛顿切割法求最近的点\n * @param {number[]} xArr      点的 x 数组\n * @param {number[]} yArr      点的 y 数组\n * @param {number}   x         指定的点 x\n * @param {number}   y         指定的点 y\n * @param {Function} tCallback 差值函数\n */\nexport function nearestPoint(xArr, yArr, x, y, tCallback, length) {\n  var t;\n  var d = Infinity;\n  var v0 = [x, y];\n  var segNum = 20;\n  if (length && length > 200) {\n    segNum = length / 10;\n  }\n  var increaseRate = 1 / segNum;\n  var interval = increaseRate / 10;\n  for (var i = 0; i <= segNum; i++) {\n    var _t = i * increaseRate;\n    var v1 = [tCallback.apply(null, xArr.concat([_t])), tCallback.apply(null, yArr.concat([_t]))];\n    var d1 = distance(v0[0], v0[1], v1[0], v1[1]);\n    if (d1 < d) {\n      t = _t;\n      d = d1;\n    }\n  }\n  // 提前终止\n  if (t === 0) {\n    return {\n      x: xArr[0],\n      y: yArr[0]\n    };\n  }\n  if (t === 1) {\n    var count = xArr.length;\n    return {\n      x: xArr[count - 1],\n      y: yArr[count - 1]\n    };\n  }\n  d = Infinity;\n  for (var i = 0; i < 32; i++) {\n    if (interval < EPSILON) {\n      break;\n    }\n    var prev = t - interval;\n    var next = t + interval;\n    var v1 = [tCallback.apply(null, xArr.concat([prev])), tCallback.apply(null, yArr.concat([prev]))];\n    var d1 = distance(v0[0], v0[1], v1[0], v1[1]);\n    if (prev >= 0 && d1 < d) {\n      t = prev;\n      d = d1;\n    } else {\n      var v2 = [tCallback.apply(null, xArr.concat([next])), tCallback.apply(null, yArr.concat([next]))];\n      var d2 = distance(v0[0], v0[1], v2[0], v2[1]);\n      if (next <= 1 && d2 < d) {\n        t = next;\n        d = d2;\n      } else {\n        interval *= 0.5;\n      }\n    }\n  }\n  return {\n    x: tCallback.apply(null, xArr.concat([t])),\n    y: tCallback.apply(null, yArr.concat([t]))\n  };\n}\n// 近似求解 https://community.khronos.org/t/3d-cubic-bezier-segment-length/62363/2\nexport function snapLength(xArr, yArr) {\n  var totalLength = 0;\n  var count = xArr.length;\n  for (var i = 0; i < count; i++) {\n    var x = xArr[i];\n    var y = yArr[i];\n    var nextX = xArr[(i + 1) % count];\n    var nextY = yArr[(i + 1) % count];\n    totalLength += distance(x, y, nextX, nextY);\n  }\n  return totalLength / 2;\n}","map":{"version":3,"sources":["../src/bezier.ts"],"names":[],"mappings":"AAAA,SAAS,QAAQ,QAAQ,QAAQ;AAGjC,IAAM,OAAO,GAAG,MAAM;AACtB;;;;;;;AAOG;AACH,OAAM,SAAU,YAAY,CAC1B,IAAc,EACd,IAAc,EACd,CAAS,EACT,CAAS,EACT,SAAuC,EACvC,MAAe,EAAA;EAEf,IAAI,CAAS;EACb,IAAI,CAAC,GAAG,QAAQ;EAChB,IAAM,EAAE,GAAe,CAAC,CAAC,EAAE,CAAC,CAAC;EAE7B,IAAI,MAAM,GAAG,EAAE;EACf,IAAI,MAAM,IAAI,MAAM,GAAG,GAAG,EAAE;IAC1B,MAAM,GAAG,MAAM,GAAG,EAAE;EACrB;EACD,IAAM,YAAY,GAAG,CAAC,GAAG,MAAM;EAE/B,IAAI,QAAQ,GAAG,YAAY,GAAG,EAAE;EAEhC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,MAAM,EAAE,CAAC,EAAE,EAAE;IAChC,IAAM,EAAE,GAAG,CAAC,GAAG,YAAY;IAC3B,IAAM,EAAE,GAAe,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,SAAS,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;IAE3G,IAAM,EAAE,GAAG,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC;IAC/C,IAAI,EAAE,GAAG,CAAC,EAAE;MACV,CAAC,GAAG,EAAE;MACN,CAAC,GAAG,EAAE;IACP;EACF;EACD;EACA,IAAI,CAAC,KAAK,CAAC,EAAE;IACX,OAAO;MACL,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC;MACV,CAAC,EAAE,IAAI,CAAC,CAAC;KACV;EACF;EACD,IAAI,CAAC,KAAK,CAAC,EAAE;IACX,IAAM,KAAK,GAAG,IAAI,CAAC,MAAM;IACzB,OAAO;MACL,CAAC,EAAE,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC;MAClB,CAAC,EAAE,IAAI,CAAC,KAAK,GAAG,CAAC;KAClB;EACF;EACD,CAAC,GAAG,QAAQ;EAEZ,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,EAAE,EAAE;IAC3B,IAAI,QAAQ,GAAG,OAAO,EAAE;MACtB;IACD;IAED,IAAM,IAAI,GAAG,CAAC,GAAG,QAAQ;IACzB,IAAM,IAAI,GAAG,CAAC,GAAG,QAAQ;IAEzB,IAAM,EAAE,GAAG,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,SAAS,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IAEnG,IAAM,EAAE,GAAG,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC;IAC/C,IAAI,IAAI,IAAI,CAAC,IAAI,EAAE,GAAG,CAAC,EAAE;MACvB,CAAC,GAAG,IAAI;MACR,CAAC,GAAG,EAAE;KACP,MAAM;MACL,IAAM,EAAE,GAAG,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,SAAS,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;MACnG,IAAM,EAAE,GAAG,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC;MAC/C,IAAI,IAAI,IAAI,CAAC,IAAI,EAAE,GAAG,CAAC,EAAE;QACvB,CAAC,GAAG,IAAI;QACR,CAAC,GAAG,EAAE;OACP,MAAM;QACL,QAAQ,IAAI,GAAG;MAChB;IACF;EACF;EAED,OAAO;IACL,CAAC,EAAE,SAAS,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAC1C,CAAC,EAAE,SAAS,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;GAC1C;AACH;AAEA;AACA,OAAM,SAAU,UAAU,CAAC,IAAc,EAAE,IAAc,EAAA;EACvD,IAAI,WAAW,GAAG,CAAC;EACnB,IAAM,KAAK,GAAG,IAAI,CAAC,MAAM;EACzB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,EAAE,CAAC,EAAE,EAAE;IAC9B,IAAM,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC;IACjB,IAAM,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC;IACjB,IAAM,KAAK,GAAG,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,IAAI,KAAK,CAAC;IACnC,IAAM,KAAK,GAAG,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,IAAI,KAAK,CAAC;IACnC,WAAW,IAAI,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,KAAK,EAAE,KAAK,CAAC;EAC5C;EACD,OAAO,WAAW,GAAG,CAAC;AACxB","sourceRoot":"","sourcesContent":["import { distance } from './util';\nvar EPSILON = 0.0001;\n/**\n * 使用牛顿切割法求最近的点\n * @param {number[]} xArr      点的 x 数组\n * @param {number[]} yArr      点的 y 数组\n * @param {number}   x         指定的点 x\n * @param {number}   y         指定的点 y\n * @param {Function} tCallback 差值函数\n */\nexport function nearestPoint(xArr, yArr, x, y, tCallback, length) {\n    var t;\n    var d = Infinity;\n    var v0 = [x, y];\n    var segNum = 20;\n    if (length && length > 200) {\n        segNum = length / 10;\n    }\n    var increaseRate = 1 / segNum;\n    var interval = increaseRate / 10;\n    for (var i = 0; i <= segNum; i++) {\n        var _t = i * increaseRate;\n        var v1 = [tCallback.apply(null, xArr.concat([_t])), tCallback.apply(null, yArr.concat([_t]))];\n        var d1 = distance(v0[0], v0[1], v1[0], v1[1]);\n        if (d1 < d) {\n            t = _t;\n            d = d1;\n        }\n    }\n    // 提前终止\n    if (t === 0) {\n        return {\n            x: xArr[0],\n            y: yArr[0],\n        };\n    }\n    if (t === 1) {\n        var count = xArr.length;\n        return {\n            x: xArr[count - 1],\n            y: yArr[count - 1],\n        };\n    }\n    d = Infinity;\n    for (var i = 0; i < 32; i++) {\n        if (interval < EPSILON) {\n            break;\n        }\n        var prev = t - interval;\n        var next = t + interval;\n        var v1 = [tCallback.apply(null, xArr.concat([prev])), tCallback.apply(null, yArr.concat([prev]))];\n        var d1 = distance(v0[0], v0[1], v1[0], v1[1]);\n        if (prev >= 0 && d1 < d) {\n            t = prev;\n            d = d1;\n        }\n        else {\n            var v2 = [tCallback.apply(null, xArr.concat([next])), tCallback.apply(null, yArr.concat([next]))];\n            var d2 = distance(v0[0], v0[1], v2[0], v2[1]);\n            if (next <= 1 && d2 < d) {\n                t = next;\n                d = d2;\n            }\n            else {\n                interval *= 0.5;\n            }\n        }\n    }\n    return {\n        x: tCallback.apply(null, xArr.concat([t])),\n        y: tCallback.apply(null, yArr.concat([t])),\n    };\n}\n// 近似求解 https://community.khronos.org/t/3d-cubic-bezier-segment-length/62363/2\nexport function snapLength(xArr, yArr) {\n    var totalLength = 0;\n    var count = xArr.length;\n    for (var i = 0; i < count; i++) {\n        var x = xArr[i];\n        var y = yArr[i];\n        var nextX = xArr[(i + 1) % count];\n        var nextY = yArr[(i + 1) % count];\n        totalLength += distance(x, y, nextX, nextY);\n    }\n    return totalLength / 2;\n}\n//# sourceMappingURL=bezier.js.map"]},"metadata":{},"sourceType":"module"}