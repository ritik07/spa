{"ast":null,"code":"import { toArray } from '@antv/util';\nimport { SHAPE_TO_TAGS } from '../constant';\n/**\n * 创建并返回图形的 svg 元素\n * @param type svg类型\n */\nexport function createSVGElement(type) {\n  return document.createElementNS('http://www.w3.org/2000/svg', type);\n}\n/**\n * 创建并返回图形的 dom 元素\n * @param  {IShape} shape 图形\n * @return {SVGElement}\n */\nexport function createDom(shape) {\n  var type = SHAPE_TO_TAGS[shape.type];\n  var parent = shape.getParent();\n  if (!type) {\n    throw new Error(\"the type \" + shape.type + \" is not supported by svg\");\n  }\n  var element = createSVGElement(type);\n  if (shape.get('id')) {\n    element.id = shape.get('id');\n  }\n  shape.set('el', element);\n  shape.set('attrs', {});\n  // 对于 defs 下的 dom 节点，parent 为空，通过 context 统一挂载到 defs 节点下\n  if (parent) {\n    var parentNode = parent.get('el');\n    if (parentNode) {\n      parentNode.appendChild(element);\n    } else {\n      // parentNode maybe null for group\n      parentNode = parent.createDom();\n      parent.set('el', parentNode);\n      parentNode.appendChild(element);\n    }\n  }\n  return element;\n}\n/**\n * 对 dom 元素进行排序\n * @param {IElement} element  元素\n * @param {sorter}   function 排序函数\n */\nexport function sortDom(element, sorter) {\n  var el = element.get('el');\n  var childList = toArray(el.children).sort(sorter);\n  // create empty fragment\n  var fragment = document.createDocumentFragment();\n  childList.forEach(function (child) {\n    fragment.appendChild(child);\n  });\n  el.appendChild(fragment);\n}\n/**\n * 将 dom 元素移动到父元素下的指定位置\n * @param {SVGElement} element     dom 元素\n * @param {number}     targetIndex 目标位置(从 0 开始)\n */\nexport function moveTo(element, targetIndex) {\n  var parentNode = element.parentNode;\n  var siblings = Array.from(parentNode.childNodes).filter(\n  // 要求为元素节点，且不能为 defs 节点\n  function (node) {\n    return node.nodeType === 1 && node.nodeName.toLowerCase() !== 'defs';\n  });\n  // 获取目标节点\n  var target = siblings[targetIndex];\n  var currentIndex = siblings.indexOf(element);\n  // 如果目标节点存在\n  if (target) {\n    // 当前索引 > 目标索引，直接插入到目标节点之前即可\n    if (currentIndex > targetIndex) {\n      parentNode.insertBefore(element, target);\n    } else if (currentIndex < targetIndex) {\n      // 当前索引 < 目标索引\n      // 获取目标节点的下一个节点\n      var targetNext = siblings[targetIndex + 1];\n      // 如果目标节点的下一个节点存在，插入到该节点之前\n      if (targetNext) {\n        parentNode.insertBefore(element, targetNext);\n      } else {\n        // 如果该节点不存在，则追加到末尾\n        parentNode.appendChild(element);\n      }\n    }\n  } else {\n    parentNode.appendChild(element);\n  }\n}","map":{"version":3,"sources":["../../src/util/dom.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { toArray } from '@antv/util';\nimport { SHAPE_TO_TAGS } from '../constant';\n/**\n * 创建并返回图形的 svg 元素\n * @param type svg类型\n */\nexport function createSVGElement(type) {\n    return document.createElementNS('http://www.w3.org/2000/svg', type);\n}\n/**\n * 创建并返回图形的 dom 元素\n * @param  {IShape} shape 图形\n * @return {SVGElement}\n */\nexport function createDom(shape) {\n    var type = SHAPE_TO_TAGS[shape.type];\n    var parent = shape.getParent();\n    if (!type) {\n        throw new Error(\"the type \" + shape.type + \" is not supported by svg\");\n    }\n    var element = createSVGElement(type);\n    if (shape.get('id')) {\n        element.id = shape.get('id');\n    }\n    shape.set('el', element);\n    shape.set('attrs', {});\n    // 对于 defs 下的 dom 节点，parent 为空，通过 context 统一挂载到 defs 节点下\n    if (parent) {\n        var parentNode = parent.get('el');\n        if (parentNode) {\n            parentNode.appendChild(element);\n        }\n        else {\n            // parentNode maybe null for group\n            parentNode = parent.createDom();\n            parent.set('el', parentNode);\n            parentNode.appendChild(element);\n        }\n    }\n    return element;\n}\n/**\n * 对 dom 元素进行排序\n * @param {IElement} element  元素\n * @param {sorter}   function 排序函数\n */\nexport function sortDom(element, sorter) {\n    var el = element.get('el');\n    var childList = toArray(el.children).sort(sorter);\n    // create empty fragment\n    var fragment = document.createDocumentFragment();\n    childList.forEach(function (child) {\n        fragment.appendChild(child);\n    });\n    el.appendChild(fragment);\n}\n/**\n * 将 dom 元素移动到父元素下的指定位置\n * @param {SVGElement} element     dom 元素\n * @param {number}     targetIndex 目标位置(从 0 开始)\n */\nexport function moveTo(element, targetIndex) {\n    var parentNode = element.parentNode;\n    var siblings = Array.from(parentNode.childNodes).filter(\n    // 要求为元素节点，且不能为 defs 节点\n    function (node) { return node.nodeType === 1 && node.nodeName.toLowerCase() !== 'defs'; });\n    // 获取目标节点\n    var target = siblings[targetIndex];\n    var currentIndex = siblings.indexOf(element);\n    // 如果目标节点存在\n    if (target) {\n        // 当前索引 > 目标索引，直接插入到目标节点之前即可\n        if (currentIndex > targetIndex) {\n            parentNode.insertBefore(element, target);\n        }\n        else if (currentIndex < targetIndex) {\n            // 当前索引 < 目标索引\n            // 获取目标节点的下一个节点\n            var targetNext = siblings[targetIndex + 1];\n            // 如果目标节点的下一个节点存在，插入到该节点之前\n            if (targetNext) {\n                parentNode.insertBefore(element, targetNext);\n            }\n            else {\n                // 如果该节点不存在，则追加到末尾\n                parentNode.appendChild(element);\n            }\n        }\n    }\n    else {\n        parentNode.appendChild(element);\n    }\n}\n//# sourceMappingURL=dom.js.map"]},"metadata":{},"sourceType":"module"}