{"ast":null,"code":"import { __extends } from \"tslib\";\nimport * as _ from '@antv/util';\nimport { DODGE_RATIO, MARGIN_RATIO } from '../constant';\nimport Adjust from './adjust';\nvar Dodge = /** @class */function (_super) {\n  __extends(Dodge, _super);\n  function Dodge(cfg) {\n    var _this = _super.call(this, cfg) || this;\n    _this.cacheMap = {};\n    _this.adjustDataArray = [];\n    _this.mergeData = [];\n    var _a = cfg.marginRatio,\n      marginRatio = _a === void 0 ? MARGIN_RATIO : _a,\n      _b = cfg.dodgeRatio,\n      dodgeRatio = _b === void 0 ? DODGE_RATIO : _b,\n      dodgeBy = cfg.dodgeBy,\n      intervalPadding = cfg.intervalPadding,\n      dodgePadding = cfg.dodgePadding,\n      xDimensionLength = cfg.xDimensionLength,\n      groupNum = cfg.groupNum,\n      defaultSize = cfg.defaultSize,\n      maxColumnWidth = cfg.maxColumnWidth,\n      minColumnWidth = cfg.minColumnWidth,\n      columnWidthRatio = cfg.columnWidthRatio,\n      customOffset = cfg.customOffset;\n    _this.marginRatio = marginRatio;\n    _this.dodgeRatio = dodgeRatio;\n    _this.dodgeBy = dodgeBy;\n    _this.intervalPadding = intervalPadding;\n    _this.dodgePadding = dodgePadding;\n    _this.xDimensionLegenth = xDimensionLength;\n    _this.groupNum = groupNum;\n    _this.defaultSize = defaultSize;\n    _this.maxColumnWidth = maxColumnWidth;\n    _this.minColumnWidth = minColumnWidth;\n    _this.columnWidthRatio = columnWidthRatio;\n    _this.customOffset = customOffset;\n    return _this;\n  }\n  Dodge.prototype.process = function (groupDataArray) {\n    var groupedDataArray = _.clone(groupDataArray);\n    // 将数据数组展开一层\n    var mergeData = _.flatten(groupedDataArray);\n    var dodgeBy = this.dodgeBy;\n    // 如果指定了分组 dim 的字段\n    var adjustDataArray = dodgeBy ? _.group(mergeData, dodgeBy) : groupedDataArray;\n    this.cacheMap = {};\n    this.adjustDataArray = adjustDataArray;\n    this.mergeData = mergeData;\n    this.adjustData(adjustDataArray, mergeData);\n    this.adjustDataArray = [];\n    this.mergeData = [];\n    return groupedDataArray;\n  };\n  Dodge.prototype.adjustDim = function (dim, values, data, frameIndex) {\n    var _this = this;\n    var customOffset = this.customOffset;\n    var map = this.getDistribution(dim);\n    var groupData = this.groupData(data, dim); // 根据值分组\n    _.each(groupData, function (group, key) {\n      var range;\n      // xField 中只有一个值，不需要做 dodge\n      if (values.length === 1) {\n        range = {\n          pre: values[0] - 1,\n          next: values[0] + 1\n        };\n      } else {\n        // 如果有多个，则需要获取调整的范围\n        range = _this.getAdjustRange(dim, parseFloat(key), values);\n      }\n      _.each(group, function (d) {\n        var value = d[dim];\n        var valueArr = map[value];\n        var valIndex = valueArr.indexOf(frameIndex);\n        if (!_.isNil(customOffset)) {\n          var pre = range.pre,\n            next = range.next;\n          d[dim] = _.isFunction(customOffset) ? customOffset(d, range) : (pre + next) / 2 + customOffset;\n        } else {\n          d[dim] = _this.getDodgeOffset(range, valIndex, valueArr.length);\n        }\n      });\n    });\n    return [];\n  };\n  Dodge.prototype.getDodgeOffset = function (range, idx, len) {\n    var _a = this,\n      dodgeRatio = _a.dodgeRatio,\n      marginRatio = _a.marginRatio,\n      intervalPadding = _a.intervalPadding,\n      dodgePadding = _a.dodgePadding;\n    var pre = range.pre,\n      next = range.next;\n    var tickLength = next - pre;\n    var position;\n    // 分多种输入情况\n    if (!_.isNil(intervalPadding) && _.isNil(dodgePadding) && intervalPadding >= 0) {\n      // 仅配置intervalPadding\n      var offset = this.getIntervalOnlyOffset(len, idx);\n      position = pre + offset;\n    } else if (!_.isNil(dodgePadding) && _.isNil(intervalPadding) && dodgePadding >= 0) {\n      // 仅配置dodgePadding\n      var offset = this.getDodgeOnlyOffset(len, idx);\n      position = pre + offset;\n    } else if (!_.isNil(intervalPadding) && !_.isNil(dodgePadding) && intervalPadding >= 0 && dodgePadding >= 0) {\n      // 同时配置intervalPadding和dodgePadding\n      var offset = this.getIntervalAndDodgeOffset(len, idx);\n      position = pre + offset;\n    } else {\n      // 默认情况\n      var width = tickLength * dodgeRatio / len;\n      var margin = marginRatio * width;\n      var offset = 1 / 2 * (tickLength - len * width - (len - 1) * margin) + ((idx + 1) * width + idx * margin) - 1 / 2 * width - 1 / 2 * tickLength;\n      position = (pre + next) / 2 + offset;\n    }\n    return position;\n  };\n  Dodge.prototype.getIntervalOnlyOffset = function (len, idx) {\n    var _a = this,\n      defaultSize = _a.defaultSize,\n      intervalPadding = _a.intervalPadding,\n      xDimensionLegenth = _a.xDimensionLegenth,\n      groupNum = _a.groupNum,\n      dodgeRatio = _a.dodgeRatio,\n      maxColumnWidth = _a.maxColumnWidth,\n      minColumnWidth = _a.minColumnWidth,\n      columnWidthRatio = _a.columnWidthRatio;\n    var normalizedIntervalPadding = intervalPadding / xDimensionLegenth;\n    var normalizedDodgePadding = (1 - (groupNum - 1) * normalizedIntervalPadding) / groupNum * dodgeRatio / (len - 1);\n    var geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len - 1)) / len;\n    // 根据columnWidthRatio/defaultSize/maxColumnWidth/minColumnWidth调整宽度\n    geomWidth = !_.isNil(columnWidthRatio) ? 1 / groupNum / len * columnWidthRatio : geomWidth;\n    if (!_.isNil(maxColumnWidth)) {\n      var normalizedMaxWidht = maxColumnWidth / xDimensionLegenth;\n      geomWidth = Math.min(geomWidth, normalizedMaxWidht);\n    }\n    if (!_.isNil(minColumnWidth)) {\n      var normalizedMinWidht = minColumnWidth / xDimensionLegenth;\n      geomWidth = Math.max(geomWidth, normalizedMinWidht);\n    }\n    geomWidth = defaultSize ? defaultSize / xDimensionLegenth : geomWidth;\n    // 调整组内间隔\n    normalizedDodgePadding = ((1 - (groupNum - 1) * normalizedIntervalPadding) / groupNum - len * geomWidth) / (len - 1);\n    var offset = ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding + 1 / 2 * normalizedIntervalPadding) * groupNum - normalizedIntervalPadding / 2;\n    return offset;\n  };\n  Dodge.prototype.getDodgeOnlyOffset = function (len, idx) {\n    var _a = this,\n      defaultSize = _a.defaultSize,\n      dodgePadding = _a.dodgePadding,\n      xDimensionLegenth = _a.xDimensionLegenth,\n      groupNum = _a.groupNum,\n      marginRatio = _a.marginRatio,\n      maxColumnWidth = _a.maxColumnWidth,\n      minColumnWidth = _a.minColumnWidth,\n      columnWidthRatio = _a.columnWidthRatio;\n    var normalizedDodgePadding = dodgePadding / xDimensionLegenth;\n    var normalizedIntervalPadding = 1 * marginRatio / (groupNum - 1);\n    var geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len - 1)) / len;\n    // 根据columnWidthRatio/defaultSize/maxColumnWidth/minColumnWidth调整宽度\n    geomWidth = columnWidthRatio ? 1 / groupNum / len * columnWidthRatio : geomWidth;\n    if (!_.isNil(maxColumnWidth)) {\n      var normalizedMaxWidht = maxColumnWidth / xDimensionLegenth;\n      geomWidth = Math.min(geomWidth, normalizedMaxWidht);\n    }\n    if (!_.isNil(minColumnWidth)) {\n      var normalizedMinWidht = minColumnWidth / xDimensionLegenth;\n      geomWidth = Math.max(geomWidth, normalizedMinWidht);\n    }\n    geomWidth = defaultSize ? defaultSize / xDimensionLegenth : geomWidth;\n    // 调整组间距\n    normalizedIntervalPadding = (1 - (geomWidth * len + normalizedDodgePadding * (len - 1)) * groupNum) / (groupNum - 1);\n    var offset = ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding + 1 / 2 * normalizedIntervalPadding) * groupNum - normalizedIntervalPadding / 2;\n    return offset;\n  };\n  Dodge.prototype.getIntervalAndDodgeOffset = function (len, idx) {\n    var _a = this,\n      intervalPadding = _a.intervalPadding,\n      dodgePadding = _a.dodgePadding,\n      xDimensionLegenth = _a.xDimensionLegenth,\n      groupNum = _a.groupNum;\n    var normalizedIntervalPadding = intervalPadding / xDimensionLegenth;\n    var normalizedDodgePadding = dodgePadding / xDimensionLegenth;\n    var geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len - 1)) / len;\n    var offset = ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding + 1 / 2 * normalizedIntervalPadding) * groupNum - normalizedIntervalPadding / 2;\n    return offset;\n  };\n  Dodge.prototype.getDistribution = function (dim) {\n    var groupedDataArray = this.adjustDataArray;\n    var cacheMap = this.cacheMap;\n    var map = cacheMap[dim];\n    if (!map) {\n      map = {};\n      _.each(groupedDataArray, function (data, index) {\n        var values = _.valuesOfKey(data, dim);\n        if (!values.length) {\n          values.push(0);\n        }\n        _.each(values, function (val) {\n          if (!map[val]) {\n            map[val] = [];\n          }\n          map[val].push(index);\n        });\n      });\n      cacheMap[dim] = map;\n    }\n    return map;\n  };\n  return Dodge;\n}(Adjust);\nexport default Dodge;","map":{"version":3,"sources":["../../src/adjusts/dodge.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __extends } from \"tslib\";\nimport * as _ from '@antv/util';\nimport { DODGE_RATIO, MARGIN_RATIO } from '../constant';\nimport Adjust from './adjust';\nvar Dodge = /** @class */ (function (_super) {\n    __extends(Dodge, _super);\n    function Dodge(cfg) {\n        var _this = _super.call(this, cfg) || this;\n        _this.cacheMap = {};\n        _this.adjustDataArray = [];\n        _this.mergeData = [];\n        var _a = cfg.marginRatio, marginRatio = _a === void 0 ? MARGIN_RATIO : _a, _b = cfg.dodgeRatio, dodgeRatio = _b === void 0 ? DODGE_RATIO : _b, dodgeBy = cfg.dodgeBy, intervalPadding = cfg.intervalPadding, dodgePadding = cfg.dodgePadding, xDimensionLength = cfg.xDimensionLength, groupNum = cfg.groupNum, defaultSize = cfg.defaultSize, maxColumnWidth = cfg.maxColumnWidth, minColumnWidth = cfg.minColumnWidth, columnWidthRatio = cfg.columnWidthRatio, customOffset = cfg.customOffset;\n        _this.marginRatio = marginRatio;\n        _this.dodgeRatio = dodgeRatio;\n        _this.dodgeBy = dodgeBy;\n        _this.intervalPadding = intervalPadding;\n        _this.dodgePadding = dodgePadding;\n        _this.xDimensionLegenth = xDimensionLength;\n        _this.groupNum = groupNum;\n        _this.defaultSize = defaultSize;\n        _this.maxColumnWidth = maxColumnWidth;\n        _this.minColumnWidth = minColumnWidth;\n        _this.columnWidthRatio = columnWidthRatio;\n        _this.customOffset = customOffset;\n        return _this;\n    }\n    Dodge.prototype.process = function (groupDataArray) {\n        var groupedDataArray = _.clone(groupDataArray);\n        // 将数据数组展开一层\n        var mergeData = _.flatten(groupedDataArray);\n        var dodgeBy = this.dodgeBy;\n        // 如果指定了分组 dim 的字段\n        var adjustDataArray = dodgeBy ? _.group(mergeData, dodgeBy) : groupedDataArray;\n        this.cacheMap = {};\n        this.adjustDataArray = adjustDataArray;\n        this.mergeData = mergeData;\n        this.adjustData(adjustDataArray, mergeData);\n        this.adjustDataArray = [];\n        this.mergeData = [];\n        return groupedDataArray;\n    };\n    Dodge.prototype.adjustDim = function (dim, values, data, frameIndex) {\n        var _this = this;\n        var customOffset = this.customOffset;\n        var map = this.getDistribution(dim);\n        var groupData = this.groupData(data, dim); // 根据值分组\n        _.each(groupData, function (group, key) {\n            var range;\n            // xField 中只有一个值，不需要做 dodge\n            if (values.length === 1) {\n                range = {\n                    pre: values[0] - 1,\n                    next: values[0] + 1,\n                };\n            }\n            else {\n                // 如果有多个，则需要获取调整的范围\n                range = _this.getAdjustRange(dim, parseFloat(key), values);\n            }\n            _.each(group, function (d) {\n                var value = d[dim];\n                var valueArr = map[value];\n                var valIndex = valueArr.indexOf(frameIndex);\n                if (!_.isNil(customOffset)) {\n                    var pre = range.pre, next = range.next;\n                    d[dim] = _.isFunction(customOffset) ? customOffset(d, range) : (pre + next) / 2 + customOffset;\n                }\n                else {\n                    d[dim] = _this.getDodgeOffset(range, valIndex, valueArr.length);\n                }\n            });\n        });\n        return [];\n    };\n    Dodge.prototype.getDodgeOffset = function (range, idx, len) {\n        var _a = this, dodgeRatio = _a.dodgeRatio, marginRatio = _a.marginRatio, intervalPadding = _a.intervalPadding, dodgePadding = _a.dodgePadding;\n        var pre = range.pre, next = range.next;\n        var tickLength = next - pre;\n        var position;\n        // 分多种输入情况\n        if (!_.isNil(intervalPadding) && _.isNil(dodgePadding) && intervalPadding >= 0) {\n            // 仅配置intervalPadding\n            var offset = this.getIntervalOnlyOffset(len, idx);\n            position = pre + offset;\n        }\n        else if (!_.isNil(dodgePadding) && _.isNil(intervalPadding) && dodgePadding >= 0) {\n            // 仅配置dodgePadding\n            var offset = this.getDodgeOnlyOffset(len, idx);\n            position = pre + offset;\n        }\n        else if (!_.isNil(intervalPadding) &&\n            !_.isNil(dodgePadding) &&\n            intervalPadding >= 0 &&\n            dodgePadding >= 0) {\n            // 同时配置intervalPadding和dodgePadding\n            var offset = this.getIntervalAndDodgeOffset(len, idx);\n            position = pre + offset;\n        }\n        else {\n            // 默认情况\n            var width = (tickLength * dodgeRatio) / len;\n            var margin = marginRatio * width;\n            var offset = (1 / 2) * (tickLength - len * width - (len - 1) * margin) +\n                ((idx + 1) * width + idx * margin) -\n                (1 / 2) * width -\n                (1 / 2) * tickLength;\n            position = (pre + next) / 2 + offset;\n        }\n        return position;\n    };\n    Dodge.prototype.getIntervalOnlyOffset = function (len, idx) {\n        var _a = this, defaultSize = _a.defaultSize, intervalPadding = _a.intervalPadding, xDimensionLegenth = _a.xDimensionLegenth, groupNum = _a.groupNum, dodgeRatio = _a.dodgeRatio, maxColumnWidth = _a.maxColumnWidth, minColumnWidth = _a.minColumnWidth, columnWidthRatio = _a.columnWidthRatio;\n        var normalizedIntervalPadding = intervalPadding / xDimensionLegenth;\n        var normalizedDodgePadding = (1 - (groupNum - 1) * normalizedIntervalPadding) / groupNum * dodgeRatio / (len - 1);\n        var geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len - 1)) / len;\n        // 根据columnWidthRatio/defaultSize/maxColumnWidth/minColumnWidth调整宽度\n        geomWidth = (!_.isNil(columnWidthRatio)) ? 1 / groupNum / len * columnWidthRatio : geomWidth;\n        if (!_.isNil(maxColumnWidth)) {\n            var normalizedMaxWidht = maxColumnWidth / xDimensionLegenth;\n            geomWidth = Math.min(geomWidth, normalizedMaxWidht);\n        }\n        if (!_.isNil(minColumnWidth)) {\n            var normalizedMinWidht = minColumnWidth / xDimensionLegenth;\n            geomWidth = Math.max(geomWidth, normalizedMinWidht);\n        }\n        geomWidth = defaultSize ? (defaultSize / xDimensionLegenth) : geomWidth;\n        // 调整组内间隔\n        normalizedDodgePadding = ((1 - (groupNum - 1) * normalizedIntervalPadding) / groupNum - len * geomWidth) / (len - 1);\n        var offset = ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding +\n            (1 / 2) * normalizedIntervalPadding) * groupNum -\n            normalizedIntervalPadding / 2;\n        return offset;\n    };\n    Dodge.prototype.getDodgeOnlyOffset = function (len, idx) {\n        var _a = this, defaultSize = _a.defaultSize, dodgePadding = _a.dodgePadding, xDimensionLegenth = _a.xDimensionLegenth, groupNum = _a.groupNum, marginRatio = _a.marginRatio, maxColumnWidth = _a.maxColumnWidth, minColumnWidth = _a.minColumnWidth, columnWidthRatio = _a.columnWidthRatio;\n        var normalizedDodgePadding = dodgePadding / xDimensionLegenth;\n        var normalizedIntervalPadding = 1 * marginRatio / (groupNum - 1);\n        var geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len - 1)) / len;\n        // 根据columnWidthRatio/defaultSize/maxColumnWidth/minColumnWidth调整宽度\n        geomWidth = columnWidthRatio ? 1 / groupNum / len * columnWidthRatio : geomWidth;\n        if (!_.isNil(maxColumnWidth)) {\n            var normalizedMaxWidht = maxColumnWidth / xDimensionLegenth;\n            geomWidth = Math.min(geomWidth, normalizedMaxWidht);\n        }\n        if (!_.isNil(minColumnWidth)) {\n            var normalizedMinWidht = minColumnWidth / xDimensionLegenth;\n            geomWidth = Math.max(geomWidth, normalizedMinWidht);\n        }\n        geomWidth = defaultSize ? (defaultSize / xDimensionLegenth) : geomWidth;\n        // 调整组间距\n        normalizedIntervalPadding = (1 - (geomWidth * len + normalizedDodgePadding * (len - 1)) * groupNum) / (groupNum - 1);\n        var offset = ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding +\n            (1 / 2) * normalizedIntervalPadding) * groupNum -\n            normalizedIntervalPadding / 2;\n        return offset;\n    };\n    Dodge.prototype.getIntervalAndDodgeOffset = function (len, idx) {\n        var _a = this, intervalPadding = _a.intervalPadding, dodgePadding = _a.dodgePadding, xDimensionLegenth = _a.xDimensionLegenth, groupNum = _a.groupNum;\n        var normalizedIntervalPadding = intervalPadding / xDimensionLegenth;\n        var normalizedDodgePadding = dodgePadding / xDimensionLegenth;\n        var geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len - 1)) / len;\n        var offset = ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding +\n            (1 / 2) * normalizedIntervalPadding) * groupNum -\n            normalizedIntervalPadding / 2;\n        return offset;\n    };\n    Dodge.prototype.getDistribution = function (dim) {\n        var groupedDataArray = this.adjustDataArray;\n        var cacheMap = this.cacheMap;\n        var map = cacheMap[dim];\n        if (!map) {\n            map = {};\n            _.each(groupedDataArray, function (data, index) {\n                var values = _.valuesOfKey(data, dim);\n                if (!values.length) {\n                    values.push(0);\n                }\n                _.each(values, function (val) {\n                    if (!map[val]) {\n                        map[val] = [];\n                    }\n                    map[val].push(index);\n                });\n            });\n            cacheMap[dim] = map;\n        }\n        return map;\n    };\n    return Dodge;\n}(Adjust));\nexport default Dodge;\n//# sourceMappingURL=dodge.js.map"]},"metadata":{},"sourceType":"module"}