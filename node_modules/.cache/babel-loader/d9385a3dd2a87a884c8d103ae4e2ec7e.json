{"ast":null,"code":"import { __values } from \"tslib\";\nimport { each, get, isNil, deepMix, groupBy } from '@antv/util';\nimport { polarToCartesian } from '../../../../util/graphics';\nimport { antiCollision } from './util';\nimport { translate } from '../../../../util/transform';\n/** 拐点偏移量, 暂不可配置 */\nvar INFLECTION_OFFSET = 4;\n/** 标签偏移量, distance between label and edge: offsetX */\nvar LABEL_OFFSET_X = 4;\n/** 标签与牵引线的偏移量 */\nvar LABEL_TEXT_LINE_OFFSET = 4;\nfunction drawLabelline(item, coordinate, inRight) {\n  /** 坐标圆心 */\n  var center = coordinate.getCenter();\n  /** 圆半径 */\n  var radius = coordinate.getRadius();\n  var startPoint = {\n    x: item.x - (inRight ? LABEL_TEXT_LINE_OFFSET : -LABEL_TEXT_LINE_OFFSET),\n    y: item.y\n  };\n  var inflectionPoint = polarToCartesian(center.x, center.y, radius + INFLECTION_OFFSET, item.angle);\n  var p1 = {\n    x: startPoint.x,\n    y: startPoint.y\n  };\n  var p2 = {\n    x: inflectionPoint.x,\n    y: inflectionPoint.y\n  };\n  var endPoint = polarToCartesian(center.x, center.y, radius, item.angle);\n  var path = '';\n  // 文本被调整下去了，则添加拐点连接线\n  if (startPoint.y !== inflectionPoint.y) {\n    var offset = inRight ? 4 : -4;\n    p1.y = startPoint.y;\n    /** 是否在第一象限 */\n    if (item.angle < 0 && item.angle >= -Math.PI / 2) {\n      p1.x = Math.max(inflectionPoint.x, startPoint.x - offset);\n      if (startPoint.y < inflectionPoint.y) {\n        p2.y = p1.y;\n      } else {\n        p2.y = inflectionPoint.y;\n        p2.x = Math.max(p2.x, p1.x - offset);\n      }\n    }\n    /** 是否在 第二象限 */\n    if (item.angle > 0 && item.angle < Math.PI / 2) {\n      p1.x = Math.max(inflectionPoint.x, startPoint.x - offset);\n      if (startPoint.y > inflectionPoint.y) {\n        p2.y = p1.y;\n      } else {\n        p2.y = inflectionPoint.y;\n        p2.x = Math.max(p2.x, p1.x - offset);\n      }\n    }\n    /** 是否在 第三象限 */\n    if (item.angle > Math.PI / 2) {\n      p1.x = Math.min(inflectionPoint.x, startPoint.x - offset);\n      if (startPoint.y > inflectionPoint.y) {\n        p2.y = p1.y;\n      } else {\n        p2.y = inflectionPoint.y;\n        p2.x = Math.min(p2.x, p1.x - offset);\n      }\n    }\n    /** 是否在 第四象限 */\n    if (item.angle < -Math.PI / 2) {\n      p1.x = Math.min(inflectionPoint.x, startPoint.x - offset);\n      if (startPoint.y < inflectionPoint.y) {\n        p2.y = p1.y;\n      } else {\n        p2.y = inflectionPoint.y;\n        p2.x = Math.min(p2.x, p1.x - offset);\n      }\n    }\n  }\n  path = [\"M \".concat(startPoint.x, \",\").concat(startPoint.y), \"L \".concat(p1.x, \",\").concat(p1.y), \"L \".concat(p2.x, \",\").concat(p2.y), \"L \".concat(inflectionPoint.x, \",\").concat(inflectionPoint.y), \"L \".concat(endPoint.x, \",\").concat(endPoint.y)].join(' ');\n  item.labelLine = deepMix({}, item.labelLine, {\n    path: path\n  });\n}\n/**\n * 饼图标签 spider 布局, 只适用于 pie-spider 的标签类型\n * region 应该是 labelsRenderer 容器的范围限制(便于后续组件间布局)\n */\nexport function pieSpiderLabelLayout(items, labels, shapes, region) {\n  var e_1, _a;\n  /** 坐标系 */\n  var coordinate = labels[0] && labels[0].get('coordinate');\n  if (!coordinate) {\n    return;\n  }\n  /** 坐标圆心 */\n  var center = coordinate.getCenter();\n  /** 圆半径 */\n  var radius = coordinate.getRadius();\n  /** label shapes */\n  var labelsMap = {};\n  try {\n    for (var labels_1 = __values(labels), labels_1_1 = labels_1.next(); !labels_1_1.done; labels_1_1 = labels_1.next()) {\n      var labelShape = labels_1_1.value;\n      labelsMap[labelShape.get('id')] = labelShape;\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (labels_1_1 && !labels_1_1.done && (_a = labels_1.return)) _a.call(labels_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n  var labelHeight = get(items[0], 'labelHeight', 14);\n  var labelOffset = Math.max(get(items[0], 'offset', 0), INFLECTION_OFFSET);\n  // step 1: adjust items to spider\n  each(items, function (item) {\n    if (!item) return;\n    var label = get(labelsMap, [item.id]);\n    if (!label) return;\n    var inRight = item.x > center.x || item.x === center.x && item.y > center.y;\n    var offsetX = !isNil(item.offsetX) ? item.offsetX : LABEL_OFFSET_X;\n    var inflectionPoint = polarToCartesian(center.x, center.y, radius + INFLECTION_OFFSET, item.angle);\n    var totalOffset = labelOffset + offsetX;\n    item.x = center.x + (inRight ? 1 : -1) * (radius + totalOffset);\n    item.y = inflectionPoint.y;\n  });\n  var start = coordinate.start,\n    end = coordinate.end;\n  var LEFT_HALF_KEY = 'left';\n  var RIGHT_HALF_KEY = 'right';\n  // step 1: separate labels\n  var separateLabels = groupBy(items, function (item) {\n    return item.x < center.x ? LEFT_HALF_KEY : RIGHT_HALF_KEY;\n  });\n  // step2: calculate totalHeight\n  var totalHeight = (radius + labelOffset) * 2 + labelHeight;\n  each(separateLabels, function (half) {\n    var halfHeight = half.length * labelHeight;\n    if (halfHeight > totalHeight) {\n      totalHeight = Math.min(halfHeight, Math.abs(start.y - end.y));\n    }\n  });\n  /** labels 容器的范围(后续根据组件的布局设计进行调整) */\n  var labelsContainerRange = {\n    minX: start.x,\n    maxX: end.x,\n    minY: center.y - totalHeight / 2,\n    maxY: center.y + totalHeight / 2\n  };\n  // step 3: antiCollision\n  each(separateLabels, function (half, key) {\n    var maxLabelsCountForOneSide = totalHeight / labelHeight;\n    if (half.length > maxLabelsCountForOneSide) {\n      half.sort(function (a, b) {\n        // sort by percentage DESC\n        return b.percent - a.percent;\n      });\n      each(half, function (labelItem, idx) {\n        if (idx > maxLabelsCountForOneSide) {\n          labelsMap[labelItem.id].set('visible', false);\n          labelItem.invisible = true;\n        }\n      });\n    }\n    antiCollision(half, labelHeight, labelsContainerRange);\n  });\n  var startY = labelsContainerRange.minY;\n  var endY = labelsContainerRange.maxY;\n  // step4: applyTo labels and adjust labelLines\n  each(separateLabels, function (half, key) {\n    var inRight = key === RIGHT_HALF_KEY;\n    each(half, function (item) {\n      var label = get(labelsMap, item && [item.id]);\n      if (!label) {\n        return;\n      }\n      // out of range, hidden\n      if (item.y < startY || item.y > endY) {\n        label.set('visible', false);\n        return;\n      }\n      var labelContent = label.getChildByIndex(0);\n      var box = labelContent.getCanvasBBox();\n      var originalPos = {\n        x: inRight ? box.x : box.maxX,\n        y: box.y + box.height / 2 /** vertical-align: middle */\n      };\n      translate(labelContent, item.x - originalPos.x /** 从 pos.x 移动到 item.x */, item.y - originalPos.y);\n      // adjust labelLines\n      if (item.labelLine) {\n        drawLabelline(item, coordinate, inRight);\n      }\n    });\n  });\n}","map":{"version":3,"sources":["../../../../../src/geometry/label/layout/pie/spider.ts"],"names":[],"mappings":"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","sourcesContent":["import { BBox, IGroup, IShape } from '@antv/g-base';\nimport { each, get, isNil, deepMix, groupBy } from '@antv/util';\nimport { polarToCartesian } from '../../../../util/graphics';\nimport { LabelItem, PolarLabelItem } from '../../interface';\nimport { antiCollision } from './util';\nimport { translate } from '../../../../util/transform';\nimport { Coordinate } from '@antv/coord';\n\n/** 拐点偏移量, 暂不可配置 */\nconst INFLECTION_OFFSET = 4;\n/** 标签偏移量, distance between label and edge: offsetX */\nconst LABEL_OFFSET_X = 4;\n/** 标签与牵引线的偏移量 */\nconst LABEL_TEXT_LINE_OFFSET = 4;\n\nfunction drawLabelline(item: PolarLabelItem, coordinate: Coordinate, inRight: boolean) {\n  /** 坐标圆心 */\n  const center = coordinate.getCenter();\n  /** 圆半径 */\n  const radius = coordinate.getRadius();\n  const startPoint = {\n    x: item.x - (inRight ? LABEL_TEXT_LINE_OFFSET : -LABEL_TEXT_LINE_OFFSET),\n    y: item.y,\n  };\n  const inflectionPoint = polarToCartesian(center.x, center.y, radius + INFLECTION_OFFSET, item.angle);\n  const p1 = { x: startPoint.x, y: startPoint.y };\n  const p2 = { x: inflectionPoint.x, y: inflectionPoint.y };\n\n  const endPoint = polarToCartesian(center.x, center.y, radius, item.angle);\n  let path = '';\n\n  // 文本被调整下去了，则添加拐点连接线\n  if (startPoint.y !== inflectionPoint.y) {\n    const offset = inRight ? 4 : -4;\n    p1.y = startPoint.y;\n\n    /** 是否在第一象限 */\n    if (item.angle < 0 && item.angle >= -Math.PI / 2) {\n      p1.x = Math.max(inflectionPoint.x, startPoint.x - offset);\n      if (startPoint.y < inflectionPoint.y) {\n        p2.y = p1.y;\n      } else {\n        p2.y = inflectionPoint.y;\n        p2.x = Math.max(p2.x, p1.x - offset);\n      }\n    }\n    /** 是否在 第二象限 */\n    if (item.angle > 0 && item.angle < Math.PI / 2) {\n      p1.x = Math.max(inflectionPoint.x, startPoint.x - offset);\n      if (startPoint.y > inflectionPoint.y) {\n        p2.y = p1.y;\n      } else {\n        p2.y = inflectionPoint.y;\n        p2.x = Math.max(p2.x, p1.x - offset);\n      }\n    }\n    /** 是否在 第三象限 */\n    if (item.angle > Math.PI / 2) {\n      p1.x = Math.min(inflectionPoint.x, startPoint.x - offset);\n      if (startPoint.y > inflectionPoint.y) {\n        p2.y = p1.y;\n      } else {\n        p2.y = inflectionPoint.y;\n        p2.x = Math.min(p2.x, p1.x - offset);\n      }\n    }\n    /** 是否在 第四象限 */\n    if (item.angle < -Math.PI / 2) {\n      p1.x = Math.min(inflectionPoint.x, startPoint.x - offset);\n      if (startPoint.y < inflectionPoint.y) {\n        p2.y = p1.y;\n      } else {\n        p2.y = inflectionPoint.y;\n        p2.x = Math.min(p2.x, p1.x - offset);\n      }\n    }\n  }\n\n  path = [\n    `M ${startPoint.x},${startPoint.y}`,\n    `L ${p1.x},${p1.y}`,\n    `L ${p2.x},${p2.y}`,\n    `L ${inflectionPoint.x},${inflectionPoint.y}`,\n    `L ${endPoint.x},${endPoint.y}`,\n  ].join(' ');\n  item.labelLine = deepMix({}, item.labelLine, { path });\n}\n\n/**\n * 饼图标签 spider 布局, 只适用于 pie-spider 的标签类型\n * region 应该是 labelsRenderer 容器的范围限制(便于后续组件间布局)\n */\nexport function pieSpiderLabelLayout(items: LabelItem[], labels: IGroup[], shapes: IShape[] | IGroup[], region: BBox) {\n  /** 坐标系 */\n  const coordinate = labels[0] && labels[0].get('coordinate');\n  if (!coordinate) {\n    return;\n  }\n\n  /** 坐标圆心 */\n  const center = coordinate.getCenter();\n  /** 圆半径 */\n  const radius = coordinate.getRadius();\n  /** label shapes */\n  const labelsMap: Record<string /** id */, IGroup> = {};\n  for (const labelShape of labels) {\n    labelsMap[labelShape.get('id')] = labelShape;\n  }\n\n  const labelHeight: number = get(items[0], 'labelHeight', 14);\n  const labelOffset: number = Math.max(get(items[0], 'offset', 0), INFLECTION_OFFSET);\n\n  // step 1: adjust items to spider\n  each(items, (item) => {\n    if (!item) return;\n    const label = get(labelsMap, [item.id]);\n    if (!label) return;\n\n    const inRight = item.x > center.x || (item.x === center.x && item.y > center.y);\n    const offsetX = !isNil(item.offsetX) ? item.offsetX : LABEL_OFFSET_X;\n    const inflectionPoint = polarToCartesian(center.x, center.y, radius + INFLECTION_OFFSET, item.angle);\n\n    const totalOffset = labelOffset + offsetX;\n    item.x = center.x + (inRight ? 1 : -1) * (radius + totalOffset);\n    item.y = inflectionPoint.y;\n  });\n\n  const { start, end } = coordinate;\n  const LEFT_HALF_KEY = 'left';\n  const RIGHT_HALF_KEY = 'right';\n  // step 1: separate labels\n  const separateLabels = groupBy(items, (item) => (item.x < center.x ? LEFT_HALF_KEY : RIGHT_HALF_KEY));\n\n  // step2: calculate totalHeight\n  let totalHeight = (radius + labelOffset) * 2 + labelHeight;\n\n  each(separateLabels, (half: PolarLabelItem[]) => {\n    const halfHeight = half.length * labelHeight;\n    if (halfHeight > totalHeight) {\n      totalHeight = Math.min(halfHeight, Math.abs(start.y - end.y));\n    }\n  });\n\n  /** labels 容器的范围(后续根据组件的布局设计进行调整) */\n  const labelsContainerRange = {\n    minX: start.x,\n    maxX: end.x,\n    minY: center.y - totalHeight / 2,\n    maxY: center.y + totalHeight / 2,\n  };\n\n  // step 3: antiCollision\n  each(separateLabels, (half, key) => {\n    const maxLabelsCountForOneSide = totalHeight / labelHeight;\n    if (half.length > maxLabelsCountForOneSide) {\n      half.sort((a, b) => {\n        // sort by percentage DESC\n        return b.percent - a.percent;\n      });\n\n      each(half, (labelItem: PolarLabelItem, idx) => {\n        if (idx > maxLabelsCountForOneSide) {\n          labelsMap[labelItem.id].set('visible', false);\n          labelItem.invisible = true;\n        }\n      });\n    }\n    antiCollision(half, labelHeight, labelsContainerRange);\n  });\n\n  const startY = labelsContainerRange.minY;\n  const endY = labelsContainerRange.maxY;\n\n  // step4: applyTo labels and adjust labelLines\n  each(separateLabels, (half, key) => {\n    const inRight = key === RIGHT_HALF_KEY;\n\n    each(half, (item) => {\n      const label: IGroup = get(labelsMap, item && [item.id]);\n      if (!label) {\n        return;\n      }\n      // out of range, hidden\n      if (item.y < startY || item.y > endY) {\n        label.set('visible', false);\n        return;\n      }\n\n      const labelContent = label.getChildByIndex(0);\n      const box = labelContent.getCanvasBBox();\n      const originalPos = { x: inRight ? box.x : box.maxX, y: box.y + box.height / 2 /** vertical-align: middle */ };\n\n      translate(labelContent as any, item.x - originalPos.x /** 从 pos.x 移动到 item.x */, item.y - originalPos.y);\n\n      // adjust labelLines\n      if (item.labelLine) {\n        drawLabelline(item, coordinate, inRight);\n      }\n    });\n  });\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}