{"ast":null,"code":"import { __extends } from \"tslib\";\nimport Coordinate from './base';\n/**\n * 笛卡尔坐标系\n * https://www.zhihu.com/question/20665303\n */\nvar Cartesian = /** @class */function (_super) {\n  __extends(Cartesian, _super);\n  function Cartesian(cfg) {\n    var _this = _super.call(this, cfg) || this;\n    _this.isRect = true;\n    _this.type = 'cartesian';\n    _this.initial();\n    return _this;\n  }\n  Cartesian.prototype.initial = function () {\n    _super.prototype.initial.call(this);\n    var start = this.start;\n    var end = this.end;\n    this.x = {\n      start: start.x,\n      end: end.x\n    };\n    this.y = {\n      start: start.y,\n      end: end.y\n    };\n  };\n  Cartesian.prototype.convertPoint = function (point) {\n    var _a;\n    var x = point.x,\n      y = point.y;\n    // 交换\n    if (this.isTransposed) {\n      _a = [y, x], x = _a[0], y = _a[1];\n    }\n    return {\n      x: this.convertDim(x, 'x'),\n      y: this.convertDim(y, 'y')\n    };\n  };\n  Cartesian.prototype.invertPoint = function (point) {\n    var _a;\n    var x = this.invertDim(point.x, 'x');\n    var y = this.invertDim(point.y, 'y');\n    if (this.isTransposed) {\n      _a = [y, x], x = _a[0], y = _a[1];\n    }\n    return {\n      x: x,\n      y: y\n    };\n  };\n  return Cartesian;\n}(Coordinate);\nexport default Cartesian;","map":{"version":3,"sources":["../../src/coord/cartesian.ts"],"names":[],"mappings":";AACA,OAAO,UAAU,MAAM,QAAQ;AAE/B;;;AAGG;AACH,IAAA,SAAA,GAAA,aAAA,UAAA,MAAA,EAAA;EAAuC,SAAA,CAAA,SAAA,EAAA,MAAA,CAAA;EAIrC,SAAA,SAAA,CAAY,GAAkB,EAAA;IAA9B,IAAA,KAAA,GACE,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,GAAG,CAAC,IAAA,IAAA;IAJI,KAAA,CAAA,MAAM,GAAY,IAAI;IACtB,KAAA,CAAA,IAAI,GAAW,WAAW;IAKxC,KAAI,CAAC,OAAO,EAAE;;EAChB;EAEO,SAAA,CAAA,SAAA,CAAA,OAAO,GAAd,YAAA;IACE,MAAA,CAAA,SAAA,CAAM,OAAO,CAAA,IAAA,CAAA,IAAA,CAAE;IAEf,IAAM,KAAK,GAAG,IAAI,CAAC,KAAK;IACxB,IAAM,GAAG,GAAG,IAAI,CAAC,GAAG;IAEpB,IAAI,CAAC,CAAC,GAAG;MACP,KAAK,EAAE,KAAK,CAAC,CAAC;MACd,GAAG,EAAE,GAAG,CAAC;KACV;IACD,IAAI,CAAC,CAAC,GAAG;MACP,KAAK,EAAE,KAAK,CAAC,CAAC;MACd,GAAG,EAAE,GAAG,CAAC;KACV;EACH,CAAC;EAEM,SAAA,CAAA,SAAA,CAAA,YAAY,GAAnB,UAAoB,KAAY,EAAA;;IACxB,IAAA,CAAC,GAAQ,KAAK,CAAA,CAAb;MAAE,CAAC,GAAK,KAAK,CAAA,CAAV;IAEV;IACA,IAAI,IAAI,CAAC,YAAY,EAAE;MACrB,EAAA,GAAS,CAAC,CAAC,EAAE,CAAC,CAAC,EAAd,CAAC,GAAA,EAAA,CAAA,CAAA,CAAA,EAAE,CAAC,GAAA,EAAA,CAAA,CAAA,CAAA;IACN;IACD,OAAO;MACL,CAAC,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC,EAAE,GAAG,CAAC;MAC1B,CAAC,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC,EAAE,GAAG;KAC1B;EACH,CAAC;EAEM,SAAA,CAAA,SAAA,CAAA,WAAW,GAAlB,UAAmB,KAAY,EAAA;;IAC7B,IAAI,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,EAAE,GAAG,CAAC;IACpC,IAAI,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,EAAE,GAAG,CAAC;IAEpC,IAAI,IAAI,CAAC,YAAY,EAAE;MACrB,EAAA,GAAS,CAAC,CAAC,EAAE,CAAC,CAAC,EAAd,CAAC,GAAA,EAAA,CAAA,CAAA,CAAA,EAAE,CAAC,GAAA,EAAA,CAAA,CAAA,CAAA;IACN;IAED,OAAO;MAAE,CAAC,EAAA,CAAA;MAAE,CAAC,EAAA;IAAA,CAAE;EACjB,CAAC;EACH,OAAA,SAAC;AAAD,CAAC,CAjDsC,UAAU,CAAA","sourceRoot":"","sourcesContent":["import { __extends } from \"tslib\";\nimport Coordinate from './base';\n/**\n * 笛卡尔坐标系\n * https://www.zhihu.com/question/20665303\n */\nvar Cartesian = /** @class */ (function (_super) {\n    __extends(Cartesian, _super);\n    function Cartesian(cfg) {\n        var _this = _super.call(this, cfg) || this;\n        _this.isRect = true;\n        _this.type = 'cartesian';\n        _this.initial();\n        return _this;\n    }\n    Cartesian.prototype.initial = function () {\n        _super.prototype.initial.call(this);\n        var start = this.start;\n        var end = this.end;\n        this.x = {\n            start: start.x,\n            end: end.x,\n        };\n        this.y = {\n            start: start.y,\n            end: end.y,\n        };\n    };\n    Cartesian.prototype.convertPoint = function (point) {\n        var _a;\n        var x = point.x, y = point.y;\n        // 交换\n        if (this.isTransposed) {\n            _a = [y, x], x = _a[0], y = _a[1];\n        }\n        return {\n            x: this.convertDim(x, 'x'),\n            y: this.convertDim(y, 'y'),\n        };\n    };\n    Cartesian.prototype.invertPoint = function (point) {\n        var _a;\n        var x = this.invertDim(point.x, 'x');\n        var y = this.invertDim(point.y, 'y');\n        if (this.isTransposed) {\n            _a = [y, x], x = _a[0], y = _a[1];\n        }\n        return { x: x, y: y };\n    };\n    return Cartesian;\n}(Coordinate));\nexport default Cartesian;\n//# sourceMappingURL=cartesian.js.map"]},"metadata":{},"sourceType":"module"}