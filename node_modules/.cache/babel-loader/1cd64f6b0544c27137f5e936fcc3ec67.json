{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { ext, vec2, vec3 } from '@antv/matrix-util';\nimport { isNumberEqual } from '@antv/util';\nimport Coordinate from './base';\nvar Polar = /** @class */function (_super) {\n  __extends(Polar, _super);\n  function Polar(cfg) {\n    var _this = _super.call(this, cfg) || this;\n    _this.isPolar = true;\n    _this.type = 'polar';\n    var _a = cfg.startAngle,\n      startAngle = _a === void 0 ? -Math.PI / 2 : _a,\n      _b = cfg.endAngle,\n      endAngle = _b === void 0 ? Math.PI * 3 / 2 : _b,\n      _c = cfg.innerRadius,\n      innerRadius = _c === void 0 ? 0 : _c,\n      radius = cfg.radius;\n    _this.startAngle = startAngle;\n    _this.endAngle = endAngle;\n    _this.innerRadius = innerRadius;\n    _this.radius = radius;\n    _this.initial();\n    return _this;\n  }\n  Polar.prototype.initial = function () {\n    _super.prototype.initial.call(this);\n    while (this.endAngle < this.startAngle) {\n      this.endAngle += Math.PI * 2;\n    }\n    var oneBox = this.getOneBox();\n    var oneWidth = oneBox.maxX - oneBox.minX;\n    var oneHeight = oneBox.maxY - oneBox.minY;\n    var left = Math.abs(oneBox.minX) / oneWidth;\n    var top = Math.abs(oneBox.minY) / oneHeight;\n    var maxRadius;\n    if (this.height / oneHeight > this.width / oneWidth) {\n      // width 为主\n      maxRadius = this.width / oneWidth;\n      this.circleCenter = {\n        x: this.center.x - (0.5 - left) * this.width,\n        y: this.center.y - (0.5 - top) * maxRadius * oneHeight\n      };\n    } else {\n      // height 为主\n      maxRadius = this.height / oneHeight;\n      this.circleCenter = {\n        x: this.center.x - (0.5 - left) * maxRadius * oneWidth,\n        y: this.center.y - (0.5 - top) * this.height\n      };\n    }\n    this.polarRadius = this.radius;\n    if (!this.radius) {\n      this.polarRadius = maxRadius;\n    } else if (this.radius > 0 && this.radius <= 1) {\n      this.polarRadius = maxRadius * this.radius;\n    } else if (this.radius <= 0 || this.radius > maxRadius) {\n      this.polarRadius = maxRadius;\n    }\n    this.x = {\n      start: this.startAngle,\n      end: this.endAngle\n    };\n    this.y = {\n      start: this.innerRadius * this.polarRadius,\n      end: this.polarRadius\n    };\n  };\n  Polar.prototype.getRadius = function () {\n    return this.polarRadius;\n  };\n  Polar.prototype.convertPoint = function (point) {\n    var _a;\n    var center = this.getCenter();\n    var x = point.x,\n      y = point.y;\n    if (this.isTransposed) {\n      _a = [y, x], x = _a[0], y = _a[1];\n    }\n    x = this.convertDim(x, 'x');\n    y = this.convertDim(y, 'y');\n    return {\n      x: center.x + Math.cos(x) * y,\n      y: center.y + Math.sin(x) * y\n    };\n  };\n  Polar.prototype.invertPoint = function (point) {\n    var _a;\n    var center = this.getCenter();\n    var vPoint = [point.x - center.x, point.y - center.y];\n    var _b = this,\n      startAngle = _b.startAngle,\n      endAngle = _b.endAngle;\n    if (this.isReflect('x')) {\n      _a = [endAngle, startAngle], startAngle = _a[0], endAngle = _a[1];\n    }\n    var m = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n    ext.leftRotate(m, m, startAngle);\n    var vStart3 = [1, 0, 0];\n    vec3.transformMat3(vStart3, vStart3, m);\n    var vStart2 = [vStart3[0], vStart3[1]];\n    var angle = ext.angleTo(vStart2, vPoint, endAngle < startAngle);\n    if (isNumberEqual(angle, Math.PI * 2)) {\n      angle = 0;\n    }\n    var radius = vec2.length(vPoint);\n    var xPercent = angle / (endAngle - startAngle);\n    xPercent = endAngle - startAngle > 0 ? xPercent : -xPercent;\n    var yPercent = this.invertDim(radius, 'y');\n    var rst = {\n      x: 0,\n      y: 0\n    };\n    rst.x = this.isTransposed ? yPercent : xPercent;\n    rst.y = this.isTransposed ? xPercent : yPercent;\n    return rst;\n  };\n  Polar.prototype.getCenter = function () {\n    return this.circleCenter;\n  };\n  Polar.prototype.getOneBox = function () {\n    var startAngle = this.startAngle;\n    var endAngle = this.endAngle;\n    if (Math.abs(endAngle - startAngle) >= Math.PI * 2) {\n      return {\n        minX: -1,\n        maxX: 1,\n        minY: -1,\n        maxY: 1\n      };\n    }\n    var xs = [0, Math.cos(startAngle), Math.cos(endAngle)];\n    var ys = [0, Math.sin(startAngle), Math.sin(endAngle)];\n    for (var i = Math.min(startAngle, endAngle); i < Math.max(startAngle, endAngle); i += Math.PI / 18) {\n      xs.push(Math.cos(i));\n      ys.push(Math.sin(i));\n    }\n    return {\n      minX: Math.min.apply(Math, xs),\n      maxX: Math.max.apply(Math, xs),\n      minY: Math.min.apply(Math, ys),\n      maxY: Math.max.apply(Math, ys)\n    };\n  };\n  return Polar;\n}(Coordinate);\nexport default Polar;","map":{"version":3,"sources":["../../src/coord/polar.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __extends } from \"tslib\";\nimport { ext, vec2, vec3 } from '@antv/matrix-util';\nimport { isNumberEqual } from '@antv/util';\nimport Coordinate from './base';\nvar Polar = /** @class */ (function (_super) {\n    __extends(Polar, _super);\n    function Polar(cfg) {\n        var _this = _super.call(this, cfg) || this;\n        _this.isPolar = true;\n        _this.type = 'polar';\n        var _a = cfg.startAngle, startAngle = _a === void 0 ? -Math.PI / 2 : _a, _b = cfg.endAngle, endAngle = _b === void 0 ? (Math.PI * 3) / 2 : _b, _c = cfg.innerRadius, innerRadius = _c === void 0 ? 0 : _c, radius = cfg.radius;\n        _this.startAngle = startAngle;\n        _this.endAngle = endAngle;\n        _this.innerRadius = innerRadius;\n        _this.radius = radius;\n        _this.initial();\n        return _this;\n    }\n    Polar.prototype.initial = function () {\n        _super.prototype.initial.call(this);\n        while (this.endAngle < this.startAngle) {\n            this.endAngle += Math.PI * 2;\n        }\n        var oneBox = this.getOneBox();\n        var oneWidth = oneBox.maxX - oneBox.minX;\n        var oneHeight = oneBox.maxY - oneBox.minY;\n        var left = Math.abs(oneBox.minX) / oneWidth;\n        var top = Math.abs(oneBox.minY) / oneHeight;\n        var maxRadius;\n        if (this.height / oneHeight > this.width / oneWidth) {\n            // width 为主\n            maxRadius = this.width / oneWidth;\n            this.circleCenter = {\n                x: this.center.x - (0.5 - left) * this.width,\n                y: this.center.y - (0.5 - top) * maxRadius * oneHeight,\n            };\n        }\n        else {\n            // height 为主\n            maxRadius = this.height / oneHeight;\n            this.circleCenter = {\n                x: this.center.x - (0.5 - left) * maxRadius * oneWidth,\n                y: this.center.y - (0.5 - top) * this.height,\n            };\n        }\n        this.polarRadius = this.radius;\n        if (!this.radius) {\n            this.polarRadius = maxRadius;\n        }\n        else if (this.radius > 0 && this.radius <= 1) {\n            this.polarRadius = maxRadius * this.radius;\n        }\n        else if (this.radius <= 0 || this.radius > maxRadius) {\n            this.polarRadius = maxRadius;\n        }\n        this.x = {\n            start: this.startAngle,\n            end: this.endAngle,\n        };\n        this.y = {\n            start: this.innerRadius * this.polarRadius,\n            end: this.polarRadius,\n        };\n    };\n    Polar.prototype.getRadius = function () {\n        return this.polarRadius;\n    };\n    Polar.prototype.convertPoint = function (point) {\n        var _a;\n        var center = this.getCenter();\n        var x = point.x, y = point.y;\n        if (this.isTransposed) {\n            _a = [y, x], x = _a[0], y = _a[1];\n        }\n        x = this.convertDim(x, 'x');\n        y = this.convertDim(y, 'y');\n        return {\n            x: center.x + Math.cos(x) * y,\n            y: center.y + Math.sin(x) * y,\n        };\n    };\n    Polar.prototype.invertPoint = function (point) {\n        var _a;\n        var center = this.getCenter();\n        var vPoint = [point.x - center.x, point.y - center.y];\n        var _b = this, startAngle = _b.startAngle, endAngle = _b.endAngle;\n        if (this.isReflect('x')) {\n            _a = [endAngle, startAngle], startAngle = _a[0], endAngle = _a[1];\n        }\n        var m = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n        ext.leftRotate(m, m, startAngle);\n        var vStart3 = [1, 0, 0];\n        vec3.transformMat3(vStart3, vStart3, m);\n        var vStart2 = [vStart3[0], vStart3[1]];\n        var angle = ext.angleTo(vStart2, vPoint, endAngle < startAngle);\n        if (isNumberEqual(angle, Math.PI * 2)) {\n            angle = 0;\n        }\n        var radius = vec2.length(vPoint);\n        var xPercent = angle / (endAngle - startAngle);\n        xPercent = endAngle - startAngle > 0 ? xPercent : -xPercent;\n        var yPercent = this.invertDim(radius, 'y');\n        var rst = { x: 0, y: 0 };\n        rst.x = this.isTransposed ? yPercent : xPercent;\n        rst.y = this.isTransposed ? xPercent : yPercent;\n        return rst;\n    };\n    Polar.prototype.getCenter = function () {\n        return this.circleCenter;\n    };\n    Polar.prototype.getOneBox = function () {\n        var startAngle = this.startAngle;\n        var endAngle = this.endAngle;\n        if (Math.abs(endAngle - startAngle) >= Math.PI * 2) {\n            return {\n                minX: -1,\n                maxX: 1,\n                minY: -1,\n                maxY: 1,\n            };\n        }\n        var xs = [0, Math.cos(startAngle), Math.cos(endAngle)];\n        var ys = [0, Math.sin(startAngle), Math.sin(endAngle)];\n        for (var i = Math.min(startAngle, endAngle); i < Math.max(startAngle, endAngle); i += Math.PI / 18) {\n            xs.push(Math.cos(i));\n            ys.push(Math.sin(i));\n        }\n        return {\n            minX: Math.min.apply(Math, xs),\n            maxX: Math.max.apply(Math, xs),\n            minY: Math.min.apply(Math, ys),\n            maxY: Math.max.apply(Math, ys),\n        };\n    };\n    return Polar;\n}(Coordinate));\nexport default Polar;\n//# sourceMappingURL=polar.js.map"]},"metadata":{},"sourceType":"module"}