{"ast":null,"code":"import line from './line';\nimport { distance, isNumberEqual, getBBoxByArray, piMod } from './util';\nimport { nearestPoint } from './bezier';\n// 差值公式\nfunction quadraticAt(p0, p1, p2, t) {\n  var onet = 1 - t;\n  return onet * onet * p0 + 2 * t * onet * p1 + t * t * p2;\n}\n// 求极值\nfunction extrema(p0, p1, p2) {\n  var a = p0 + p2 - 2 * p1;\n  if (isNumberEqual(a, 0)) {\n    return [0.5];\n  }\n  var rst = (p0 - p1) / a;\n  if (rst <= 1 && rst >= 0) {\n    return [rst];\n  }\n  return [];\n}\nfunction derivativeAt(p0, p1, p2, t) {\n  return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);\n}\n// 分割贝塞尔曲线\nfunction divideQuadratic(x1, y1, x2, y2, x3, y3, t) {\n  // 划分点\n  var xt = quadraticAt(x1, x2, x3, t);\n  var yt = quadraticAt(y1, y2, y3, t);\n  // 分割的第一条曲线的控制点\n  var controlPoint1 = line.pointAt(x1, y1, x2, y2, t);\n  // 分割的第二条曲线的控制点\n  var controlPoint2 = line.pointAt(x2, y2, x3, y3, t);\n  return [[x1, y1, controlPoint1.x, controlPoint1.y, xt, yt], [xt, yt, controlPoint2.x, controlPoint2.y, x3, y3]];\n}\n// 使用迭代法取贝塞尔曲线的长度\nfunction quadraticLength(x1, y1, x2, y2, x3, y3, iterationCount) {\n  if (iterationCount === 0) {\n    return (distance(x1, y1, x2, y2) + distance(x2, y2, x3, y3) + distance(x1, y1, x3, y3)) / 2;\n  }\n  var quadratics = divideQuadratic(x1, y1, x2, y2, x3, y3, 0.5);\n  var left = quadratics[0];\n  var right = quadratics[1];\n  left.push(iterationCount - 1);\n  right.push(iterationCount - 1);\n  return quadraticLength.apply(null, left) + quadraticLength.apply(null, right);\n}\nexport default {\n  box: function (x1, y1, x2, y2, x3, y3) {\n    var xExtrema = extrema(x1, x2, x3)[0];\n    var yExtrema = extrema(y1, y2, y3)[0];\n    // 控制点不加入 box 的计算\n    var xArr = [x1, x3];\n    var yArr = [y1, y3];\n    if (xExtrema !== undefined) {\n      xArr.push(quadraticAt(x1, x2, x3, xExtrema));\n    }\n    if (yExtrema !== undefined) {\n      yArr.push(quadraticAt(y1, y2, y3, yExtrema));\n    }\n    return getBBoxByArray(xArr, yArr);\n  },\n  length: function (x1, y1, x2, y2, x3, y3) {\n    return quadraticLength(x1, y1, x2, y2, x3, y3, 3);\n  },\n  nearestPoint: function (x1, y1, x2, y2, x3, y3, x0, y0) {\n    return nearestPoint([x1, x2, x3], [y1, y2, y3], x0, y0, quadraticAt);\n  },\n  pointDistance: function (x1, y1, x2, y2, x3, y3, x0, y0) {\n    var point = this.nearestPoint(x1, y1, x2, y2, x3, y3, x0, y0);\n    return distance(point.x, point.y, x0, y0);\n  },\n  interpolationAt: quadraticAt,\n  pointAt: function (x1, y1, x2, y2, x3, y3, t) {\n    return {\n      x: quadraticAt(x1, x2, x3, t),\n      y: quadraticAt(y1, y2, y3, t)\n    };\n  },\n  divide: function (x1, y1, x2, y2, x3, y3, t) {\n    return divideQuadratic(x1, y1, x2, y2, x3, y3, t);\n  },\n  tangentAngle: function (x1, y1, x2, y2, x3, y3, t) {\n    var dx = derivativeAt(x1, x2, x3, t);\n    var dy = derivativeAt(y1, y2, y3, t);\n    var angle = Math.atan2(dy, dx);\n    return piMod(angle);\n  }\n};","map":{"version":3,"sources":["../src/quadratic.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import line from './line';\nimport { distance, isNumberEqual, getBBoxByArray, piMod } from './util';\nimport { nearestPoint } from './bezier';\n// 差值公式\nfunction quadraticAt(p0, p1, p2, t) {\n    var onet = 1 - t;\n    return onet * onet * p0 + 2 * t * onet * p1 + t * t * p2;\n}\n// 求极值\nfunction extrema(p0, p1, p2) {\n    var a = p0 + p2 - 2 * p1;\n    if (isNumberEqual(a, 0)) {\n        return [0.5];\n    }\n    var rst = (p0 - p1) / a;\n    if (rst <= 1 && rst >= 0) {\n        return [rst];\n    }\n    return [];\n}\nfunction derivativeAt(p0, p1, p2, t) {\n    return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);\n}\n// 分割贝塞尔曲线\nfunction divideQuadratic(x1, y1, x2, y2, x3, y3, t) {\n    // 划分点\n    var xt = quadraticAt(x1, x2, x3, t);\n    var yt = quadraticAt(y1, y2, y3, t);\n    // 分割的第一条曲线的控制点\n    var controlPoint1 = line.pointAt(x1, y1, x2, y2, t);\n    // 分割的第二条曲线的控制点\n    var controlPoint2 = line.pointAt(x2, y2, x3, y3, t);\n    return [\n        [x1, y1, controlPoint1.x, controlPoint1.y, xt, yt],\n        [xt, yt, controlPoint2.x, controlPoint2.y, x3, y3],\n    ];\n}\n// 使用迭代法取贝塞尔曲线的长度\nfunction quadraticLength(x1, y1, x2, y2, x3, y3, iterationCount) {\n    if (iterationCount === 0) {\n        return (distance(x1, y1, x2, y2) + distance(x2, y2, x3, y3) + distance(x1, y1, x3, y3)) / 2;\n    }\n    var quadratics = divideQuadratic(x1, y1, x2, y2, x3, y3, 0.5);\n    var left = quadratics[0];\n    var right = quadratics[1];\n    left.push(iterationCount - 1);\n    right.push(iterationCount - 1);\n    return quadraticLength.apply(null, left) + quadraticLength.apply(null, right);\n}\nexport default {\n    box: function (x1, y1, x2, y2, x3, y3) {\n        var xExtrema = extrema(x1, x2, x3)[0];\n        var yExtrema = extrema(y1, y2, y3)[0];\n        // 控制点不加入 box 的计算\n        var xArr = [x1, x3];\n        var yArr = [y1, y3];\n        if (xExtrema !== undefined) {\n            xArr.push(quadraticAt(x1, x2, x3, xExtrema));\n        }\n        if (yExtrema !== undefined) {\n            yArr.push(quadraticAt(y1, y2, y3, yExtrema));\n        }\n        return getBBoxByArray(xArr, yArr);\n    },\n    length: function (x1, y1, x2, y2, x3, y3) {\n        return quadraticLength(x1, y1, x2, y2, x3, y3, 3);\n    },\n    nearestPoint: function (x1, y1, x2, y2, x3, y3, x0, y0) {\n        return nearestPoint([x1, x2, x3], [y1, y2, y3], x0, y0, quadraticAt);\n    },\n    pointDistance: function (x1, y1, x2, y2, x3, y3, x0, y0) {\n        var point = this.nearestPoint(x1, y1, x2, y2, x3, y3, x0, y0);\n        return distance(point.x, point.y, x0, y0);\n    },\n    interpolationAt: quadraticAt,\n    pointAt: function (x1, y1, x2, y2, x3, y3, t) {\n        return {\n            x: quadraticAt(x1, x2, x3, t),\n            y: quadraticAt(y1, y2, y3, t),\n        };\n    },\n    divide: function (x1, y1, x2, y2, x3, y3, t) {\n        return divideQuadratic(x1, y1, x2, y2, x3, y3, t);\n    },\n    tangentAngle: function (x1, y1, x2, y2, x3, y3, t) {\n        var dx = derivativeAt(x1, x2, x3, t);\n        var dy = derivativeAt(y1, y2, y3, t);\n        var angle = Math.atan2(dy, dx);\n        return piMod(angle);\n    },\n};\n//# sourceMappingURL=quadratic.js.map"]},"metadata":{},"sourceType":"module"}