{"ast":null,"code":"/**\n * @fileoverview 椭圆的一些计算，\n *  - 周长计算参考：https://www.mathsisfun.com/geometry/ellipse-perimeter.html\n *  - 距离计算参考：https://wet-robots.ghost.io/simple-method-for-distance-to-ellipse/\n * @author dxq613@gmail.com\n */\nimport { distance, piMod } from './util';\nfunction copysign(v1, v2) {\n  var absv = Math.abs(v1);\n  return v2 > 0 ? absv : absv * -1;\n}\nexport default {\n  /**\n   * 包围盒计算\n   * @param {number} x  椭圆中心 x\n   * @param {number} y  椭圆中心 y\n   * @param {number} rx 椭圆 x 方向半径\n   * @param {number} ry 椭圆 y 方向半径\n   * @return {object} 包围盒\n   */\n  box: function (x, y, rx, ry) {\n    return {\n      x: x - rx,\n      y: y - ry,\n      width: rx * 2,\n      height: ry * 2\n    };\n  },\n  /**\n   * 计算周长，使用近似法\n   * @param {number} x  椭圆中心 x\n   * @param {number} y  椭圆中心 y\n   * @param {number} rx 椭圆 x 方向半径\n   * @param {number} ry 椭圆 y 方向半径\n   * @return {number} 椭圆周长\n   */\n  length: function (x, y, rx, ry) {\n    return Math.PI * (3 * (rx + ry) - Math.sqrt((3 * rx + ry) * (rx + 3 * ry)));\n  },\n  /**\n   * 距离椭圆最近的点\n   * @param {number} x  椭圆中心 x\n   * @param {number} y  椭圆中心 y\n   * @param {number} rx 椭圆 x 方向半径\n   * @param {number} ry 椭圆 y 方向半径\n   * @param {number} x0  指定的点 x\n   * @param {number} y0  指定的点 y\n   * @return {object} 椭圆上距离指定点最近的点\n   */\n  nearestPoint: function (x, y, rx, ry, x0, y0) {\n    var a = rx;\n    var b = ry;\n    // 假如椭圆半径为0则返回圆心\n    if (a === 0 || b === 0) {\n      return {\n        x: x,\n        y: y\n      };\n    }\n    // 转换成 0， 0 为中心的椭圆计算\n    var relativeX = x0 - x;\n    var relativeY = y0 - y;\n    var px = Math.abs(relativeX);\n    var py = Math.abs(relativeY);\n    var squareA = a * a;\n    var squareB = b * b;\n    // const angle0 = Math.atan2(relativeY, relativeX);\n    var t = Math.PI / 4;\n    var nearestX; // 椭圆上的任一点\n    var nearestY;\n    // 迭代 4 次\n    for (var i = 0; i < 4; i++) {\n      nearestX = a * Math.cos(t);\n      nearestY = b * Math.sin(t);\n      var ex = (squareA - squareB) * Math.pow(Math.cos(t), 3) / a;\n      var ey = (squareB - squareA) * Math.pow(Math.sin(t), 3) / b;\n      var rx1 = nearestX - ex;\n      var ry1 = nearestY - ey;\n      var qx = px - ex;\n      var qy = py - ey;\n      var r = Math.hypot(ry1, rx1);\n      var q = Math.hypot(qy, qx);\n      var delta_c = r * Math.asin((rx1 * qy - ry1 * qx) / (r * q));\n      var delta_t = delta_c / Math.sqrt(squareA + squareB - nearestX * nearestX - nearestY * nearestY);\n      t += delta_t;\n      t = Math.min(Math.PI / 2, Math.max(0, t));\n    }\n    return {\n      x: x + copysign(nearestX, relativeX),\n      y: y + copysign(nearestY, relativeY)\n    };\n  },\n  /**\n   * 点到椭圆最近的距离\n   * @param {number} x  椭圆中心 x\n   * @param {number} y  椭圆中心 y\n   * @param {number} rx 椭圆 x 方向半径\n   * @param {number} ry 椭圆 y 方向半径\n   * @param {number} x0  指定的点 x\n   * @param {number} y0  指定的点 y\n   * @return {number} 点到椭圆的距离\n   */\n  pointDistance: function (x, y, rx, ry, x0, y0) {\n    var nearestPoint = this.nearestPoint(x, y, rx, ry, x0, y0);\n    return distance(nearestPoint.x, nearestPoint.y, x0, y0);\n  },\n  /**\n   * 根据比例获取点\n   * @param {number} x 椭圆中心 x\n   * @param {number} y 椭圆中心 y\n   * @param {number} rx 椭圆 x 方向半径\n   * @param {number} ry 椭圆 y 方向半径\n   * @param {number} t 指定比例，x轴方向为 0\n   * @return {object} 点\n   */\n  pointAt: function (x, y, rx, ry, t) {\n    var angle = 2 * Math.PI * t; // 按照角度进行计算，而不按照周长计算\n    return {\n      x: x + rx * Math.cos(angle),\n      y: y + ry * Math.sin(angle)\n    };\n  },\n  /**\n   * 根据比例计算切线角度\n   * @param {number} x 椭圆中心 x\n   * @param {number} y 椭圆中心 y\n   * @param {number} rx 椭圆 x 方向半径\n   * @param {number} ry 椭圆 y 方向半径\n   * @param {number} t 指定比例 0 - 1 之间，x轴方向为 0。在 0-1 范围之外是循环还是返回 null，还需要调整\n   * @return {number} 角度，在 0 - 2PI 之间\n   */\n  tangentAngle: function (x, y, rx, ry, t) {\n    var angle = 2 * Math.PI * t; // 按照角度进行计算，而不按照周长计算\n    // 直接使用 x,y 的导数计算， x' = -rx * sin(t); y' = ry * cos(t);\n    var tangentAngle = Math.atan2(ry * Math.cos(angle), -rx * Math.sin(angle));\n    // 也可以使用指定点的切线方程计算，成本有些高\n    // const point = this.pointAt(0, 0, rx, ry, t); // 椭圆的切线同椭圆的中心不相关\n    // let tangentAngle = -1 * Math.atan((ry * ry * point.x) / (rx * rx * point.y));\n    // if (angle >= 0 && angle <= Math.PI) {\n    //   tangentAngle += Math.PI;\n    // }\n    return piMod(tangentAngle);\n  }\n};","map":{"version":3,"sources":["../src/ellipse.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @fileoverview 椭圆的一些计算，\n *  - 周长计算参考：https://www.mathsisfun.com/geometry/ellipse-perimeter.html\n *  - 距离计算参考：https://wet-robots.ghost.io/simple-method-for-distance-to-ellipse/\n * @author dxq613@gmail.com\n */\nimport { distance, piMod } from './util';\nfunction copysign(v1, v2) {\n    var absv = Math.abs(v1);\n    return v2 > 0 ? absv : absv * -1;\n}\nexport default {\n    /**\n     * 包围盒计算\n     * @param {number} x  椭圆中心 x\n     * @param {number} y  椭圆中心 y\n     * @param {number} rx 椭圆 x 方向半径\n     * @param {number} ry 椭圆 y 方向半径\n     * @return {object} 包围盒\n     */\n    box: function (x, y, rx, ry) {\n        return {\n            x: x - rx,\n            y: y - ry,\n            width: rx * 2,\n            height: ry * 2,\n        };\n    },\n    /**\n     * 计算周长，使用近似法\n     * @param {number} x  椭圆中心 x\n     * @param {number} y  椭圆中心 y\n     * @param {number} rx 椭圆 x 方向半径\n     * @param {number} ry 椭圆 y 方向半径\n     * @return {number} 椭圆周长\n     */\n    length: function (x, y, rx, ry) {\n        return Math.PI * (3 * (rx + ry) - Math.sqrt((3 * rx + ry) * (rx + 3 * ry)));\n    },\n    /**\n     * 距离椭圆最近的点\n     * @param {number} x  椭圆中心 x\n     * @param {number} y  椭圆中心 y\n     * @param {number} rx 椭圆 x 方向半径\n     * @param {number} ry 椭圆 y 方向半径\n     * @param {number} x0  指定的点 x\n     * @param {number} y0  指定的点 y\n     * @return {object} 椭圆上距离指定点最近的点\n     */\n    nearestPoint: function (x, y, rx, ry, x0, y0) {\n        var a = rx;\n        var b = ry;\n        // 假如椭圆半径为0则返回圆心\n        if (a === 0 || b === 0) {\n            return {\n                x: x,\n                y: y,\n            };\n        }\n        // 转换成 0， 0 为中心的椭圆计算\n        var relativeX = x0 - x;\n        var relativeY = y0 - y;\n        var px = Math.abs(relativeX);\n        var py = Math.abs(relativeY);\n        var squareA = a * a;\n        var squareB = b * b;\n        // const angle0 = Math.atan2(relativeY, relativeX);\n        var t = Math.PI / 4;\n        var nearestX; // 椭圆上的任一点\n        var nearestY;\n        // 迭代 4 次\n        for (var i = 0; i < 4; i++) {\n            nearestX = a * Math.cos(t);\n            nearestY = b * Math.sin(t);\n            var ex = ((squareA - squareB) * Math.pow(Math.cos(t), 3)) / a;\n            var ey = ((squareB - squareA) * Math.pow(Math.sin(t), 3)) / b;\n            var rx1 = nearestX - ex;\n            var ry1 = nearestY - ey;\n            var qx = px - ex;\n            var qy = py - ey;\n            var r = Math.hypot(ry1, rx1);\n            var q = Math.hypot(qy, qx);\n            var delta_c = r * Math.asin((rx1 * qy - ry1 * qx) / (r * q));\n            var delta_t = delta_c / Math.sqrt(squareA + squareB - nearestX * nearestX - nearestY * nearestY);\n            t += delta_t;\n            t = Math.min(Math.PI / 2, Math.max(0, t));\n        }\n        return {\n            x: x + copysign(nearestX, relativeX),\n            y: y + copysign(nearestY, relativeY),\n        };\n    },\n    /**\n     * 点到椭圆最近的距离\n     * @param {number} x  椭圆中心 x\n     * @param {number} y  椭圆中心 y\n     * @param {number} rx 椭圆 x 方向半径\n     * @param {number} ry 椭圆 y 方向半径\n     * @param {number} x0  指定的点 x\n     * @param {number} y0  指定的点 y\n     * @return {number} 点到椭圆的距离\n     */\n    pointDistance: function (x, y, rx, ry, x0, y0) {\n        var nearestPoint = this.nearestPoint(x, y, rx, ry, x0, y0);\n        return distance(nearestPoint.x, nearestPoint.y, x0, y0);\n    },\n    /**\n     * 根据比例获取点\n     * @param {number} x 椭圆中心 x\n     * @param {number} y 椭圆中心 y\n     * @param {number} rx 椭圆 x 方向半径\n     * @param {number} ry 椭圆 y 方向半径\n     * @param {number} t 指定比例，x轴方向为 0\n     * @return {object} 点\n     */\n    pointAt: function (x, y, rx, ry, t) {\n        var angle = 2 * Math.PI * t; // 按照角度进行计算，而不按照周长计算\n        return {\n            x: x + rx * Math.cos(angle),\n            y: y + ry * Math.sin(angle),\n        };\n    },\n    /**\n     * 根据比例计算切线角度\n     * @param {number} x 椭圆中心 x\n     * @param {number} y 椭圆中心 y\n     * @param {number} rx 椭圆 x 方向半径\n     * @param {number} ry 椭圆 y 方向半径\n     * @param {number} t 指定比例 0 - 1 之间，x轴方向为 0。在 0-1 范围之外是循环还是返回 null，还需要调整\n     * @return {number} 角度，在 0 - 2PI 之间\n     */\n    tangentAngle: function (x, y, rx, ry, t) {\n        var angle = 2 * Math.PI * t; // 按照角度进行计算，而不按照周长计算\n        // 直接使用 x,y 的导数计算， x' = -rx * sin(t); y' = ry * cos(t);\n        var tangentAngle = Math.atan2(ry * Math.cos(angle), -rx * Math.sin(angle));\n        // 也可以使用指定点的切线方程计算，成本有些高\n        // const point = this.pointAt(0, 0, rx, ry, t); // 椭圆的切线同椭圆的中心不相关\n        // let tangentAngle = -1 * Math.atan((ry * ry * point.x) / (rx * rx * point.y));\n        // if (angle >= 0 && angle <= Math.PI) {\n        //   tangentAngle += Math.PI;\n        // }\n        return piMod(tangentAngle);\n    },\n};\n//# sourceMappingURL=ellipse.js.map"]},"metadata":{},"sourceType":"module"}